<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Blast Belt Royale</title>
<meta name="description" content="12-ship AI battle royale in an asteroid field. Watch, spectate, and enjoy the chaos.">
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Blast Belt Royale">
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    overflow: hidden;
    font-family: 'Share Tech Mono', monospace;
    color: #fff;
    cursor: crosshair;
  }

  #game {
    display: block;
    position: fixed;
    top: 0; left: 0;
    cursor: crosshair;
  }

  #hud {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 10;
    pointer-events: none;
    padding: 12px 20px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }

  #title-block {
    text-align: left;
  }

  #title-block h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: 900;
    letter-spacing: 6px;
    color: #fff;
    text-shadow: 0 0 20px rgba(255,255,255,0.3);
    margin-bottom: 2px;
  }

  #title-block .subtitle {
    font-size: 10px;
    letter-spacing: 4px;
    color: rgba(255,255,255,0.4);
    text-transform: uppercase;
  }

  #alive-counter {
    position: fixed;
    bottom: 12px;
    right: 16px;
    z-index: 10;
    pointer-events: none;
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    font-weight: 700;
    color: rgba(255,255,255,0.5);
    letter-spacing: 3px;
    display: flex;
    align-items: baseline;
    gap: 6px;
  }

  #alive-counter #alive-num {
    font-size: 16px;
    font-weight: 900;
    color: #fff;
    text-shadow: 0 0 20px rgba(255,100,100,0.4);
  }

  #camera-mode {
    position: fixed;
    bottom: 12px;
    left: 16px;
    z-index: 10;
    pointer-events: none;
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 3px;
    color: rgba(255,255,255,0.4);
    display: flex;
    align-items: baseline;
    gap: 8px;
    transition: opacity 0.3s;
  }

  #camera-mode .hint {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 1px;
    color: rgba(255,255,255,0.2);
  }

  #camera-mode.manual #camera-mode-text {
    color: rgba(100,180,255,0.7);
  }

  /* Scoreboard drawn on canvas */

  #killfeed {
    position: fixed;
    top: 60px;
    right: 20px;
    z-index: 10;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    gap: 4px;
    align-items: flex-end;
  }

  .kill-msg {
    font-size: 11px;
    padding: 4px 10px;
    background: rgba(0,0,0,0.6);
    border-radius: 3px;
    animation: killSlide 3s ease-out forwards;
    white-space: nowrap;
    border-left: 2px solid;
  }

  @keyframes killSlide {
    0% { opacity: 0; transform: translateX(30px); }
    10% { opacity: 1; transform: translateX(0); }
    80% { opacity: 1; }
    100% { opacity: 0; transform: translateY(-10px); }
  }

  #pregame-overlay {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding-bottom: 0;
    background: radial-gradient(
      ellipse at center,
      rgba(0,0,0,0.7) 0%,
      rgba(0,0,0,0.4) 50%,
      rgba(0,0,0,0.15) 100%
    );
  }

  #pregame-overlay.hidden {
    display: none;
  }

  #pregame-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 64px;
    font-weight: 900;
    letter-spacing: 12px;
    color: #fff;
    text-shadow: 0 0 40px rgba(255,255,255,0.3), 0 2px 20px rgba(0,0,0,0.8);
  }

  #pregame-sub {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    letter-spacing: 10px;
    color: rgba(255,255,255,0.5);
    margin-top: 4px;
    margin-bottom: 28px;
    text-shadow: 0 1px 10px rgba(0,0,0,0.8);
  }

  #pregame-roster {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    width: 420px;
    margin-bottom: 36px;
  }

  .roster-tag {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 5px 12px;
    border-radius: 3px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    letter-spacing: 2px;
    border: 1px solid;
    background: rgba(0,0,0,0.5) !important;
    opacity: 0;
    animation: rosterIn 0.3s ease forwards;
  }

  .roster-tag .ship-icon {
    width: 22px;
    height: 22px;
    flex-shrink: 0;
  }

  @keyframes rosterIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }


  /* Mode selector buttons */
  #mode-selector {
    display: flex; gap: 8px; margin-bottom: 20px;
  }
  .mode-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 13px; font-weight: 700;
    letter-spacing: 4px;
    padding: 10px 28px;
    background: rgba(0,0,0,0.5);
    border: 2px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.5);
    cursor: pointer; transition: all 0.3s;
  }
  .mode-btn:hover { border-color: rgba(255,255,255,0.4); color: rgba(255,255,255,0.7); }
  .mode-btn.active {
    border-color: rgba(68,255,136,0.5);
    color: rgba(68,255,136,0.9);
    background: rgba(68,255,136,0.08);
  }

  /* Team builder area */
  #team-builder { display: none; width: 90%; max-width: 900px; margin-bottom: 20px; }
  #team-builder.active { display: flex; flex-direction: column; align-items: center; gap: 12px; }

  /* Ship picker grid */
  #ship-picker {
    display: grid; grid-template-columns: repeat(4, 1fr);
    gap: 5px; width: 100%; max-width: 700px;
  }
  .picker-ship {
    display: flex; align-items: center;
    gap: 6px; padding: 5px 10px;
    border-radius: 3px; cursor: pointer;
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 2px;
    border: 1px solid rgba(255,255,255,0.15);
    background: rgba(0,0,0,0.5);
    opacity: 0.7; transition: all 0.2s;
  }
  .picker-ship:hover { opacity: 1; border-color: rgba(255,255,255,0.4); }
  .picker-ship .ship-icon { width: 22px; height: 22px; flex-shrink: 0; }

  .picker-label {
    font-family: 'Orbitron', sans-serif; font-size: 11px;
    letter-spacing: 4px; color: rgba(255,255,255,0.3);
    margin-bottom: 2px;
  }

  /* Team columns */
  #team-columns {
    display: flex; gap: 8px; width: 100%;
    justify-content: center; flex-wrap: wrap;
  }
  .team-col {
    flex: 1; min-width: 140px; max-width: 220px;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 4px; padding: 6px;
    display: flex; flex-direction: column; gap: 0;
    background: rgba(0,0,0,0.3);
    height: 380px;
  }
  .team-col-header {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px; font-weight: 700;
    letter-spacing: 3px; text-align: center;
    cursor: pointer; padding: 4px 0;
    flex-shrink: 0;
  }
  .team-col-header:hover { text-decoration: underline; }
  .team-slots-area {
    flex: 1; display: flex; flex-direction: column;
    gap: 3px; overflow: hidden; padding: 2px 0;
  }
  .team-slot {
    display: flex; align-items: center; gap: 5px;
    padding: 3px 6px; border-radius: 3px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    flex-shrink: 1; min-height: 0;
  }
  .team-slot .ship-icon { width: 22px; height: 22px; flex-shrink: 0; }
  .team-slot-name { font-family: 'Share Tech Mono', monospace; font-size: 10px; flex: 1; }
  .team-slot-remove {
    font-size: 11px; cursor: pointer; color: rgba(255,255,255,0.3);
    padding: 0 4px; transition: color 0.2s;
  }
  .team-slot-remove:hover { color: #ff4444; }
  .team-add-slot {
    display: flex; align-items: center; justify-content: center;
    padding: 4px; border-radius: 3px; cursor: pointer;
    border: 1px dashed rgba(255,255,255,0.15);
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; color: rgba(255,255,255,0.3);
    transition: all 0.2s; flex-shrink: 0;
  }
  .team-add-slot:hover { border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.5); }
  .team-add-slot.target { border-color: rgba(68,255,136,0.4); color: rgba(68,255,136,0.6); }
  .team-col-remove {
    text-align: center; font-size: 8px; color: rgba(255,255,255,0.2);
    cursor: pointer; padding: 2px 0; flex-shrink: 0;
  }
  .team-col-remove:hover { color: #ff4444; }
  /* Per-team loadout buttons */
  .team-loadout-row { display: flex; gap: 3px; margin-bottom: 4px; flex-shrink: 0; }
  .team-wpn-btn {
    flex: 1; padding: 4px 3px; font-family: 'Share Tech Mono', monospace;
    font-size: 10px; text-align: center; cursor: pointer;
    border: 1px solid rgba(255,255,255,0.15); border-radius: 3px;
    background: rgba(0,0,0,0.3); color: rgba(255,255,255,0.5);
    transition: all 0.2s; white-space: nowrap; overflow: hidden;
  }
  .team-wpn-btn:hover { border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.7); background: rgba(255,255,255,0.06); }
  .team-wpn-btn.active { color: rgba(68,255,136,0.8); border-color: rgba(68,255,136,0.3); background: rgba(68,255,136,0.04); }
  .team-wpn-dropdown {
    position: fixed; z-index: 200; background: rgba(15,15,20,0.95);
    border: 1px solid rgba(255,255,255,0.15); border-radius: 4px;
    padding: 4px 0; min-width: 130px; max-height: 280px; overflow-y: auto;
  }
  .team-wpn-item {
    display: flex; align-items: center; gap: 6px; padding: 4px 10px;
    font-family: 'Share Tech Mono', monospace; font-size: 10px;
    color: rgba(255,255,255,0.7); cursor: pointer;
  }
  .team-wpn-item:hover { background: rgba(255,255,255,0.06); }
  .team-wpn-item input[type="checkbox"] { margin: 0; accent-color: #44ff88; }
  .add-team-col {
    min-width: 60px; max-width: 80px;
    border: 1px dashed rgba(255,255,255,0.15);
    border-radius: 4px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Orbitron', sans-serif; font-size: 10px;
    letter-spacing: 2px; color: rgba(255,255,255,0.3);
    opacity: 0.5; transition: all 0.2s;
    min-height: 380px;
  }
  .add-team-col:hover { opacity: 0.8; border-color: rgba(255,255,255,0.3); }

  #start-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    font-weight: 700;
    letter-spacing: 6px;
    padding: 14px 40px;
    background: rgba(0,0,0,0.5);
    border: 2px solid rgba(255,255,255,0.4);
    color: #fff;
    cursor: pointer;
    transition: all 0.3s;
  }

  #countdown-overlay {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: radial-gradient(
      ellipse at center,
      rgba(0,0,0,0.6) 0%,
      rgba(0,0,0,0.3) 50%,
      rgba(0,0,0,0.1) 100%
    );
    pointer-events: none;
  }
  #countdown-overlay.hidden { display: none; }
  #countdown-timer {
    font-family: 'Orbitron', sans-serif;
    font-size: 36px;
    font-weight: 700;
    letter-spacing: 6px;
    color: #fff;
    text-shadow: 0 0 30px rgba(255,255,255,0.4);
    margin-bottom: 4px;
  }
  #countdown-loadout {
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    letter-spacing: 6px;
    color: rgba(255,255,255,0.5);
    margin-bottom: 20px;
  }
  #countdown-roster {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 9px;
    max-width: 1250px;
    margin-bottom: 36px;
  }
  .cd-ship-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    padding: 9px 20px;
    border-radius: 5px;
    border: 1px solid;
    background: rgba(0,0,0,0.6);
    opacity: 0;
    animation: cdCardIn 0.25s ease forwards;
  }
  .cd-ship-card .cd-ship-header {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .cd-ship-card .cd-ship-name {
    font-family: 'Share Tech Mono', monospace;
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 3px;
    padding-left: 0;
  }
  .cd-ship-card .cd-ship-detail {
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    letter-spacing: 1.5px;
    color: rgba(255,255,255,0.45);
    line-height: 1.3;
    text-align: center;
  }
  @keyframes cdCardIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
  }
  #countdown-bets {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: 700;
    letter-spacing: 8px;
    color: rgba(255,255,255,0.6);
    text-shadow: 0 0 20px rgba(255,255,255,0.2);
    animation: betsPulse 1s ease-in-out infinite;
  }
  @keyframes betsPulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  #start-btn:hover {
    background: rgba(255,255,255,0.15);
    border-color: #fff;
    box-shadow: 0 0 30px rgba(255,255,255,0.2);
  }

  #winner-overlay {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0);
    backdrop-filter: blur(0px);
    overflow: hidden;
  }

  #winner-overlay.show {
    display: flex;
    animation: fadeOverlay 0.8s ease forwards;
    padding: 30px 0;
  }

  @keyframes fadeOverlay {
    from { background: rgba(0,0,0,0); backdrop-filter: blur(0px); }
    to { background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); }
  }

  #winner-overlay h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    letter-spacing: 10px;
    color: rgba(255,255,255,0.4);
    margin-bottom: 12px;
    opacity: 0;
    animation: rankSlide 0.4s ease forwards;
    animation-delay: 0.1s;
  }

  #winner-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 64px;
    font-weight: 900;
    text-shadow: 0 0 60px currentColor;
    margin-bottom: 10px;
    opacity: 0;
    animation: rankSlide 0.4s ease forwards;
    animation-delay: 0.2s;
  }

  #rankings {
    display: flex;
    flex-direction: column;
    gap: 0;
    margin-top: 24px;
    width: 560px;
    transform-origin: top center;
  }

  .rank-row {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 16px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    opacity: 0;
    animation: rankSlide 0.4s ease forwards;
  }

  .rank-row .rank-num {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: 900;
    width: 32px;
    text-align: right;
    color: rgba(255,255,255,0.3);
  }

  .rank-row.top1 .rank-num { color: #ffd700; }
  .rank-row.top2 .rank-num { color: #c0c0c0; }
  .rank-row.top3 .rank-num { color: #cd7f32; }

  .rank-row .ship-icon {
    width: 32px;
    height: 32px;
    flex-shrink: 0;
  }

  .rank-row .rank-name-block {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 1px;
  }

  .rank-row .rank-name {
    font-family: 'Share Tech Mono', monospace;
    font-size: 15px;
    letter-spacing: 2px;
  }

  .rank-row .rank-loadout {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    letter-spacing: 1px;
    color: rgba(255,255,255,0.3);
  }

  .rank-row .rank-time {
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    color: rgba(255,255,255,0.3);
  }

  .rank-row .rank-cause {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    color: rgba(255,255,255,0.3);
    text-align: right;
    flex-shrink: 0;
  }

  .rank-row .rank-kills {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    font-weight: 700;
    color: rgba(255,255,255,0.5);
    flex-shrink: 0;
    width: 28px;
    text-align: right;
  }

  .rank-row.top1 .rank-name { font-weight: bold; }

  @keyframes rankSlide {
    from { opacity: 0; transform: translateX(-15px); }
    to { opacity: 1; transform: translateX(0); }
  }

  #restart-btn {
    margin-top: 30px;
    flex-shrink: 0;
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    letter-spacing: 5px;
    padding: 14px 40px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.3);
    color: #fff;
    cursor: pointer;
    pointer-events: all;
    transition: all 0.3s;
    opacity: 0;
    animation: rankSlide 0.4s ease forwards;
  }

  #restart-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: #fff;
  }

  #arena-btn {
    margin-top: 10px;
    flex-shrink: 0;
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    letter-spacing: 3px;
    padding: 10px 28px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.12);
    color: rgba(255,255,255,0.4);
    cursor: pointer;
    pointer-events: all;
    transition: all 0.3s;
    opacity: 0;
    animation: rankSlide 0.4s ease forwards;
  }
  #arena-btn:hover {
    background: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.3);
    color: rgba(255,255,255,0.7);
  }

  #auto-restart-countdown {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    letter-spacing: 4px;
    color: rgba(255,255,255,0.4);
    margin-top: 20px;
    margin-bottom: -8px;
  }

  #auto-restart-countdown .countdown-num {
    font-size: 18px;
    font-weight: 900;
    color: rgba(255,255,255,0.7);
  }

  #settings-btn {
    position: fixed;
    top: 14px;
    right: 20px;
    z-index: 110;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.6);
    font-size: 18px;
    width: 34px;
    height: 34px;
    border-radius: 6px;
    cursor: pointer;
    pointer-events: all;
    transition: all 0.2s;
  }

  #settings-btn:hover {
    background: rgba(255,255,255,0.15);
    color: #fff;
  }

  #settings-panel {
    position: fixed;
    top: 54px;
    right: 20px;
    z-index: 110;
    background: rgba(0,0,0,0.85);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    padding: 14px 16px;
    min-width: 240px;
    display: none;
    pointer-events: all;
    backdrop-filter: blur(10px);
  }

  #settings-panel.open { display: block; }

  #settings-panel h3 {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    letter-spacing: 3px;
    color: rgba(255,255,255,0.5);
    margin: 0 0 10px 0;
  }

  .setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 0;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }

  .setting-row:last-child { border-bottom: none; }

  .setting-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    color: rgba(255,255,255,0.7);
  }

  .setting-toggle {
    position: relative;
    width: 36px;
    height: 20px;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.15);
    transition: all 0.2s;
    flex-shrink: 0;
  }

  .setting-toggle.on {
    background: rgba(68, 255, 136, 0.3);
    border-color: rgba(68, 255, 136, 0.5);
  }

  .setting-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    transition: all 0.2s;
  }

  .setting-toggle.on::after {
    left: 18px;
    background: #44ff88;
  }

  .hp-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    font-weight: 700;
    flex: 1;
    padding: 4px 0;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.4);
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .hp-btn.active {
    background: rgba(68,255,136,0.2);
    border-color: rgba(68,255,136,0.5);
    color: #44ff88;
  }

  .hp-btn:hover {
    border-color: rgba(255,255,255,0.4);
  }

  /* ─── TOURNAMENT MODE ───────────────────────────────────── */
  #tournament-overlay {
    position: fixed; inset: 0; z-index: 105;
    display: flex; flex-direction: row;
    background: radial-gradient(
      ellipse at center,
      rgba(0,0,0,0.7) 0%,
      rgba(0,0,0,0.4) 50%,
      rgba(0,0,0,0.15) 100%
    );
    transition: background 0.6s ease, opacity 0.5s ease;
    opacity: 0;
    pointer-events: none;
  }
  #tournament-overlay.active {
    opacity: 1;
    pointer-events: auto;
  }
  #tournament-overlay.bracket-transition {
    background: rgba(0,0,0,0.94);
  }
  #tournament-overlay.champion-screen {
    background: rgba(0,0,0,1);
  }

  #tourney-sidebar {
    position: absolute; left: 0; top: 0; bottom: 0;
    width: 200px; z-index: 2;
    padding: 20px 16px;
    border-right: 1px solid rgba(255,255,255,0.1);
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(6px);
    display: flex; flex-direction: column; gap: 16px;
  }
  #tourney-sidebar h3 {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px; font-weight: 700;
    letter-spacing: 3px; color: rgba(255,255,255,0.5);
  }
  .tourney-size-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px; font-weight: 700;
    letter-spacing: 3px; padding: 8px 12px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.12);
    color: rgba(255,255,255,0.4);
    cursor: pointer; transition: all 0.2s; text-align: center;
    border-radius: 3px;
  }
  .tourney-size-btn:hover { border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.6); }
  .tourney-size-btn.active {
    border-color: rgba(255,200,0,0.5); color: rgba(255,200,0,0.9);
    background: rgba(255,200,0,0.08);
  }
  #tourney-back-btn {
    font-family: 'Share Tech Mono', monospace; font-size: 11px;
    padding: 8px 12px; background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.12); border-radius: 3px;
    color: rgba(255,255,255,0.4); cursor: pointer; transition: all 0.2s;
  }
  #tourney-back-btn:hover { border-color: rgba(255,255,255,0.3); color: rgba(255,255,255,0.7); }
  #tourney-start-btn {
    font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700;
    letter-spacing: 4px; padding: 12px 16px;
    background: rgba(68,255,136,0.08); border: 2px solid rgba(68,255,136,0.3);
    color: rgba(68,255,136,0.7); cursor: pointer; transition: all 0.3s;
    border-radius: 3px; text-align: center;
  }
  #tourney-start-btn:hover { background: rgba(68,255,136,0.15); border-color: rgba(68,255,136,0.6); color: #44ff88; }
  #tourney-start-btn:disabled { opacity: 0.3; cursor: default; }
  #tourney-status {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; color: rgba(255,255,255,0.3);
    text-align: center; line-height: 1.5;
  }

  #tourney-bracket-area {
    flex: 1; overflow: hidden; padding: 12px 20px;
    display: flex; flex-direction: column; align-items: center;
    justify-content: center;
  }
  #tourney-bracket-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 22px; font-weight: 900;
    letter-spacing: 8px; color: #fff;
    text-shadow: 0 0 30px rgba(255,200,0,0.3);
    margin-bottom: 4px; text-align: center; flex-shrink: 0;
  }
  #tourney-bracket-subtitle {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px; letter-spacing: 6px;
    color: rgba(255,255,255,0.3); margin-bottom: 8px; text-align: center; flex-shrink: 0;
  }
  #bracket-container {
    display: flex; align-items: center; gap: 0;
    transform-origin: center center;
    transition: transform 1.2s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.4s ease;
    opacity: 1;
  }
  #bracket-container.fade-content {
    opacity: 0;
    transition: transform 1.2s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.3s ease;
  }
  .bracket-round {
    display: flex; flex-direction: column;
    gap: 0; flex-shrink: 0;
  }
  .bracket-match {
    display: flex; flex-direction: column;
    margin: 0;
  }
  .bracket-slot {
    display: flex; flex-direction: column; align-items: center; gap: 2px;
    padding: 4px 8px; min-width: 130px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    cursor: pointer; transition: all 0.2s, opacity 0.4s ease;
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; letter-spacing: 1px;
    color: rgba(255,255,255,0.4);
  }
  .bracket-slot.slot-top { border-radius: 3px 3px 0 0; border-bottom: none; }
  .bracket-slot.slot-bot { border-radius: 0 0 3px 3px; }
  .bracket-slot:hover { border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.06); }
  .bracket-slot.filled {
    color: rgba(255,255,255,0.8);
  }
  .bracket-slot.winner {
    opacity: 1;
  }
  .bracket-slot.loser {
    opacity: 0.3;
  }
  .bracket-slot.current-match {
    animation: currentMatchPulse 1.5s ease-in-out infinite;
  }
  @keyframes currentMatchPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(68,255,136,0); }
    50% { box-shadow: 0 0 12px 2px rgba(68,255,136,0.2); }
  }
  .slot-top-row {
    display: flex; align-items: center; justify-content: center; gap: 6px; width: 100%;
  }
  .bracket-slot .slot-name {
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    font-size: inherit; letter-spacing: 1.5px; text-align: center;
  }
  .slot-ships-row {
    display: flex; align-items: center; justify-content: center; gap: 2px;
    min-height: 14px;
  }
  .slot-ships-row .ship-icon { flex-shrink: 0; }
  .bracket-half { display: flex; align-items: center; }
  .bracket-final-area {
    display: flex; flex-direction: column; align-items: center;
    padding: 0 6px; flex-shrink: 0;
  }
  .bracket-final-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px; font-weight: 700; letter-spacing: 3px;
    color: rgba(255,255,255,0.5); margin-bottom: 4px; text-align: center;
  }

  /* Tournament animation states */
  #bracket-container.tourney-focus .bracket-slot {
    opacity: 0.2;
    transition: opacity 0.4s;
  }
  #bracket-container.tourney-focus .bracket-slot.winner,
  #bracket-container.tourney-focus .bracket-slot.filled {
    opacity: 0.25;
  }
  #bracket-container.tourney-focus .bracket-slot.current-match,
  #bracket-container.tourney-focus .bracket-slot.current-match.filled {
    opacity: 1;
  }
  .bracket-slot.flash-eliminate {
    animation: erraticFlash 0.03s steps(1) infinite !important;
  }
  @keyframes erraticFlash {
    0%  { opacity: 1; }
    15% { opacity: 0.05; }
    30% { opacity: 0.9; }
    45% { opacity: 0.08; }
    60% { opacity: 0.75; }
    75% { opacity: 0.03; }
    90% { opacity: 0.6; }
  }
  .bracket-slot.eliminated {
    opacity: 0.1 !important;
    transition: opacity 0.6s !important;
  }
  .bracket-slot.eliminated .slot-name { text-decoration: line-through; }
  .bracket-slot.highlight-winner {
    opacity: 1 !important;
  }
  @keyframes advanceGlow {
    0% { opacity: 0; transform: scale(0.85); }
    50% { opacity: 1; transform: scale(1.06); box-shadow: 0 0 20px rgba(255,255,255,0.3); }
    100% { opacity: 1; transform: scale(1); box-shadow: none; }
  }
  .champion-glow {
    animation: championPulse 2s ease-in-out infinite !important;
  }
  @keyframes championPulse {
    0%, 100% { box-shadow: 0 0 15px 3px var(--glow-color, #fff), 0 0 30px 8px var(--glow-color, #fff); }
    50% { box-shadow: 0 0 30px 8px var(--glow-color, #fff), 0 0 60px 20px var(--glow-color, #fff); }
  }
  /* Team builder modal for tournament */
  #tourney-team-modal {
    position: fixed; inset: 0; z-index: 110;
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(8px);
  }
  #tourney-team-modal.active { display: flex; }
  #tourney-team-modal-inner {
    background: rgba(10,10,20,0.95);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px; padding: 20px;
    max-width: 750px; width: 90%;
    max-height: 85vh; overflow-y: auto;
    display: flex; flex-direction: column; align-items: center; gap: 12px;
  }
  #tourney-team-modal-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px; font-weight: 700;
    letter-spacing: 5px; color: #fff;
  }
  #tourney-modal-picker {
    display: grid; grid-template-columns: repeat(4, 1fr);
    gap: 5px; width: 100%; max-width: 600px;
  }
  #tourney-modal-slots {
    display: flex; flex-wrap: wrap; gap: 4px;
    justify-content: center; width: 100%; max-width: 600px;
    min-height: 36px; padding: 8px;
    border: 1px dashed rgba(255,255,255,0.1);
    border-radius: 4px;
  }
  .tourney-modal-ship {
    display: flex; align-items: center; gap: 4px;
    padding: 3px 8px; border-radius: 3px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.12);
  }
  .tourney-modal-ship .ship-icon { width: 20px; height: 20px; }
  .tourney-modal-ship span { font-size: 10px; letter-spacing: 1px; }
  .tourney-modal-ship .tm-remove {
    cursor: pointer; color: rgba(255,255,255,0.3);
    padding: 0 3px; font-size: 11px;
  }
  .tourney-modal-ship .tm-remove:hover { color: #ff4444; }
  #tourney-modal-name-row {
    display: flex; align-items: center; gap: 8px; width: 100%; max-width: 600px;
  }
  #tourney-modal-name-row label {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px; letter-spacing: 3px; color: rgba(255,255,255,0.4);
  }
  #tourney-modal-name-input {
    flex: 1; padding: 6px 10px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.15); border-radius: 3px;
    color: #fff; font-family: 'Share Tech Mono', monospace;
    font-size: 12px; letter-spacing: 2px; outline: none;
  }
  #tourney-modal-name-input:focus { border-color: rgba(255,255,255,0.3); }
  #tourney-modal-btns {
    display: flex; gap: 8px; margin-top: 4px;
  }
  #tourney-modal-btns button {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px; font-weight: 700;
    letter-spacing: 3px; padding: 8px 20px;
    background: rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.6);
    cursor: pointer; transition: all 0.2s; border-radius: 3px;
  }
  #tourney-modal-btns button:hover { border-color: rgba(255,255,255,0.4); color: #fff; }
  #tourney-modal-btns .tm-save {
    border-color: rgba(68,255,136,0.3); color: rgba(68,255,136,0.7);
    background: rgba(68,255,136,0.06);
  }
  #tourney-modal-btns .tm-save:hover { border-color: rgba(68,255,136,0.6); color: #44ff88; }
  /* Loadout row in tournament modal */
  #tourney-modal-loadouts {
    display: flex; gap: 6px; width: 100%; max-width: 600px; justify-content: center;
  }
  #tourney-modal-loadouts .team-wpn-btn {
    padding: 5px 12px; font-size: 10px;
  }
  /* Tournament progress banner */
  #tourney-progress-banner {
    position: fixed; top: 0; left: 0; right: 0;
    z-index: 102; display: none;
    text-align: center; padding: 8px 16px;
    background: rgba(0,0,0,0.8);
    border-bottom: 1px solid rgba(255,255,255,0.15);
    font-family: 'Orbitron', sans-serif;
    font-size: 11px; font-weight: 700;
    letter-spacing: 4px; color: rgba(255,255,255,0.5);
    pointer-events: none;
  }
  #tourney-progress-banner.active { display: block; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<button id="settings-btn">⚙</button>
<div id="settings-panel">
  <h3>PERSONALITY</h3>
  <div class="setting-row">
    <span class="setting-label">Random Personalities</span>
    <div class="setting-toggle" data-setting="randomPersonalities" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Unique Ships</span>
    <div class="setting-toggle" data-setting="uniqueShips" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Unique Weapons</span>
    <div class="setting-toggle" data-setting="weapons" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Random Weapons</span>
    <div class="setting-toggle" data-setting="randomWeapons" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Unique Passives</span>
    <div class="setting-toggle" data-setting="passives" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Maneuvers</span>
    <div class="setting-toggle" data-setting="maneuvers" onclick="toggleSetting(this)"></div>
  </div>
  <h3 style="margin-top:12px">SHIP HP</h3>
  <div class="setting-row">
    <div id="hp-selector" style="display:flex;gap:4px;width:100%;">
      <button class="hp-btn" data-hp="1">1</button>
      <button class="hp-btn" data-hp="2">2</button>
      <button class="hp-btn active" data-hp="3">3</button>
      <button class="hp-btn" data-hp="5">5</button>
      <button class="hp-btn" data-hp="10">10</button>
    </div>
  </div>
  <h3 style="margin-top:12px">PLAYERS</h3>
  <div class="setting-row">
    <div id="ship-count-selector" style="display:flex;gap:4px;width:100%;">
      <button class="hp-btn" data-ships="4">4</button>
      <button class="hp-btn" data-ships="6">6</button>
      <button class="hp-btn" data-ships="8">8</button>
      <button class="hp-btn" data-ships="10">10</button>
      <button class="hp-btn" data-ships="12">12</button>
      <button class="hp-btn" data-ships="14">14</button>
      <button class="hp-btn" data-ships="15">15</button>
      <button class="hp-btn active" data-ships="16">16</button>
    </div>
  </div>
  <h3 style="margin-top:12px">MATCH</h3>
  <div class="setting-row">
    <span class="setting-label">Auto Restart</span>
    <div class="setting-toggle" data-setting="autoRestart" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Chaos Mode</span>
    <div class="setting-toggle" data-setting="chaosMode" onclick="toggleSetting(this)"></div>
  </div>
  <h3 style="margin-top:12px">MATCH LOGGER</h3>
  <div class="setting-row">
    <span class="setting-label">Log Results</span>
    <div class="setting-toggle" data-setting="matchLogger" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row" style="flex-direction:column;gap:6px;">
    <span id="log-count" style="font-size:11px;color:#888;">0 matches logged</span>
    <div style="display:flex;gap:4px;width:100%;">
      <button class="hp-btn" id="log-export" onclick="exportMatchLog()" style="flex:1;">Export CSV</button>
      <button class="hp-btn" id="log-clear" onclick="clearMatchLog()" style="flex:0.6;color:#ff6666;">Clear</button>
    </div>
  </div>
  <h3 style="margin-top:12px">SCORECARD</h3>
  <div class="setting-row">
    <span class="setting-label">Show Weapons</span>
    <div class="setting-toggle" data-setting="showWeaponTag" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Show Passives</span>
    <div class="setting-toggle" data-setting="showPassiveTag" onclick="toggleSetting(this)"></div>
  </div>
  <div class="setting-row">
    <span class="setting-label">Show Maneuvers</span>
    <div class="setting-toggle" data-setting="showManeuverTag" onclick="toggleSetting(this)"></div>
  </div>
  <h3 style="margin-top:12px">SIM SPEED</h3>
  <div class="setting-row">
    <div id="speed-selector" style="display:flex;gap:4px;width:100%;">
      <button class="spd-btn hp-btn" data-speed="0.5">0.5x</button>
      <button class="spd-btn hp-btn active" data-speed="1">1x</button>
      <button class="spd-btn hp-btn" data-speed="2">2x</button>
      <button class="spd-btn hp-btn" data-speed="4">4x</button>
    </div>
  </div>
</div>

<div id="hud">
  <div id="title-block">
    <h1>BLAST BELT</h1>
    <div class="subtitle">Royale</div>
  </div>
</div>

<div id="alive-counter">
  <span class="label">ALIVE</span>
  <span id="alive-num">12</span>
</div>

<div id="camera-mode">
  <span id="camera-mode-text">OVERVIEW</span>
  <span class="hint">[SPACE]</span>
</div>

<div id="killfeed"></div>


<div id="pregame-overlay">
  <div id="pregame-title">BLAST BELT ROYALE</div>
  <div id="pregame-sub">PREPARE FOR COMBAT</div>
  <div id="mode-selector">
    <button class="mode-btn active" data-mode="ffa" onclick="setMatchModeUI('ffa')">FREE FOR ALL</button>
    <button class="mode-btn" data-mode="teams" onclick="setMatchModeUI('teams')">TEAM BATTLE</button>
    <button class="mode-btn" data-mode="tournament" onclick="setMatchModeUI('tournament')">TOURNAMENT</button>
  </div>
  <div id="pregame-roster"></div>
  <div id="team-builder">
    <div class="picker-label">TAP TO ADD FIGHTERS</div>
    <div id="ship-picker"></div>
    <div id="team-columns"></div>
  </div>
  <button id="start-btn">START MATCH</button>
</div>

<!-- Tournament Bracket Overlay -->
<div id="tournament-overlay">
  <div id="tourney-sidebar">
    <h3>TOURNAMENT</h3>
    <div id="tourney-size-btns">
      <div class="tourney-size-btn" data-size="4" onclick="setTourneySize(4)">4 TEAMS</div>
      <div class="tourney-size-btn active" data-size="8" onclick="setTourneySize(8)">8 TEAMS</div>
      <div class="tourney-size-btn" data-size="16" onclick="setTourneySize(16)">16 TEAMS</div>
      <div class="tourney-size-btn" data-size="32" onclick="setTourneySize(32)">32 TEAMS</div>
      <div class="tourney-size-btn" data-size="64" onclick="setTourneySize(64)">64 TEAMS</div>
    </div>
    <div id="tourney-status"></div>
    <button id="tourney-start-btn" disabled onclick="startTournament()">BEGIN</button>
    <div style="flex:1;"></div>
    <button id="tourney-back-btn" onclick="exitTournament()">← BACK</button>
  </div>
  <div id="tourney-bracket-area">
    <div id="tourney-bracket-title">TOURNAMENT</div>
    <div id="tourney-bracket-subtitle">SINGLE ELIMINATION</div>
    <div id="bracket-container"></div>
  </div>
</div>

<!-- Tournament team builder modal -->
<div id="tourney-team-modal">
  <div id="tourney-team-modal-inner">
    <div id="tourney-team-modal-title">EDIT TEAM</div>
    <div id="tourney-modal-name-row">
      <label>NAME</label>
      <input id="tourney-modal-name-input" type="text" maxlength="16" placeholder="TEAM NAME" />
    </div>
    <div id="tourney-modal-loadouts"></div>
    <div class="picker-label" style="margin-top:4px;">TAP TO ADD FIGHTERS</div>
    <div id="tourney-modal-picker"></div>
    <div id="tourney-modal-slots"></div>
    <div id="tourney-modal-btns">
      <button onclick="closeTourneyTeamModal()">CANCEL</button>
      <button class="tm-save" onclick="saveTourneyTeam()">SAVE</button>
    </div>
  </div>
</div>

<!-- Tournament progress banner (shown during matches) -->
<div id="tourney-progress-banner"></div>

<div id="countdown-overlay" class="hidden">
  <div id="countdown-timer"></div>
  <div id="countdown-loadout"></div>
  <div id="countdown-roster"></div>
  <div id="countdown-bets">PLACE YOUR BETS!</div>
</div>

<div id="winner-overlay">
  <h2>MATCH RESULTS</h2>
  <div id="winner-name"></div>
  <div id="rankings"></div>
  <div id="auto-restart-countdown" style="display:none;"></div>
  <button id="restart-btn">NEW MATCH</button>
  <button id="arena-btn" style="display:none;">BACK TO ARENA</button>
</div>

<script>
// ─── CONFIG ────────────────────────────────────────────────────
const CFG = {
  WORLD_W: 9600,
  WORLD_H: 5400,
  NUM_SHIPS: 12,
  NUM_ASTEROIDS: 180,
  SHIP_RADIUS: 12,
  SHIP_THRUST: 192,
  SHIP_MAX_SPEED: 240,
  SHIP_TURN_SPEED: 5,
  BULLET_SPEED: 400,
  BULLET_LIFE: 1.8,
  FIRE_RATE: 0.28,
  ASTEROID_SPEED_MIN: 15,
  ASTEROID_SPEED_MAX: 70,
  ASTEROID_SIZES: [200, 50, 30, 16],
  RESPAWN_ASTEROIDS: true,
  INVULN_TIME: 0,
  SHIP_HP: 1,
  AI_REACTION: 0.05,
  CAMERA_LERP: 0.06,
};

// ─── NAMES & COLORS ───────────────────────────────────────────
const PILOT_NAMES = [
  'RED', 'GREEN', 'BLUE', 'ORANGE',
  'PINK', 'CYAN', 'LIME', 'CORAL',
  'PURPLE', 'WHITE', 'YELLOW', 'MAGENTA',
  'SKY', 'GOLD', 'SILVER', 'VIOLET'
];

// Ship design defs keyed by index string for dropdown compatibility
const SHIP_DESIGN_DEFS = {};
const SHIP_DESIGN_KEYS = [];
for (let i = 0; i < PILOT_NAMES.length; i++) {
  const key = String(i);
  SHIP_DESIGN_DEFS[key] = { name: PILOT_NAMES[i] };
  SHIP_DESIGN_KEYS.push(key);
}

const PILOT_COLORS = [
  '#ff4444', '#44ff88', '#4488ff', '#ffaa22',
  '#dd66bb', '#44ffff', '#88dd55', '#ff6b4a',
  '#aa44ff', '#ffffff', '#ffff44', '#ff00ff',
  '#55bbff', '#ffcc00', '#bbbbcc', '#8844dd'
];

// ─── PREDETERMINED PERSONALITY PROFILES ───────────────────────
const PRESET_PROFILES = [
  // RED:     Reckless berserker — charges in, sprays lead, blasts everything
  { behavior: 'aggressive', aggroSpeed: 0.18, aggroPhase: 0,     aimBaseline: 0.4, aimRange: 0.45, aimSpeed: 0.7, aimPhase: 0,    rockShooter: 0.85 },
  // GREEN:   Calculated sniper — patient lead shots, avoids rocks cleanly
  { behavior: 'hunter',     aggroSpeed: 0.25, aggroPhase: 1.2,   aimBaseline: 0.85, aimRange: 0.3, aimSpeed: 0.35, aimPhase: 1.0, rockShooter: 0.2 },
  // BLUE:    Steady soldier — balanced everything, reliable mid-range
  { behavior: 'hunter',     aggroSpeed: 0.3,  aggroPhase: 2.5,   aimBaseline: 0.65, aimRange: 0.35, aimSpeed: 0.5, aimPhase: 2.0, rockShooter: 0.5 },
  // ORANGE:  Hot-headed brawler — aggressive with wild aim, loves explosions
  { behavior: 'aggressive', aggroSpeed: 0.35, aggroPhase: 0.8,   aimBaseline: 0.35, aimRange: 0.5, aimSpeed: 0.75, aimPhase: 3.1, rockShooter: 0.9 },
  // PINK:    Elusive dancer — dodges everything, precise when they do shoot
  { behavior: 'evasive',    aggroSpeed: 0.2,  aggroPhase: 4.0,   aimBaseline: 0.9, aimRange: 0.3, aimSpeed: 0.4, aimPhase: 0.5,  rockShooter: 0.15 },
  // CYAN:    Cool tactician — cautious approach, strong lead prediction
  { behavior: 'cautious',   aggroSpeed: 0.22, aggroPhase: 3.2,   aimBaseline: 0.8, aimRange: 0.35, aimSpeed: 0.45, aimPhase: 4.2, rockShooter: 0.35 },
  // LIME:    Twitchy scrapper — fast aggression cycles, chaotic aim
  { behavior: 'hunter',     aggroSpeed: 0.4,  aggroPhase: 5.5,   aimBaseline: 0.5, aimRange: 0.5, aimSpeed: 0.8, aimPhase: 1.8,  rockShooter: 0.7 },
  // CORAL:   Bloodthirsty bruiser — ignores asteroids when locked onto a target
  { behavior: 'bloodthirsty', aggroSpeed: 0.25, aggroPhase: 1.0,   aimBaseline: 0.15, aimRange: 0.35, aimSpeed: 0.3, aimPhase: 5.0,  rockShooter: 0.6 },
  // PURPLE:  Ghost — evasive navigator, rarely shoots rocks, precise aim
  { behavior: 'evasive',    aggroSpeed: 0.28, aggroPhase: 2.0,   aimBaseline: 0.75, aimRange: 0.4, aimSpeed: 0.5, aimPhase: 3.5, rockShooter: 0.1 },
  // WHITE:   Wildcard — cautious but with dramatic aggro swings
  { behavior: 'cautious',   aggroSpeed: 0.38, aggroPhase: 4.8,   aimBaseline: 0.6, aimRange: 0.45, aimSpeed: 0.6, aimPhase: 0.3, rockShooter: 0.45 },
  // YELLOW:  Bombardier — hunts aggressively, blasts everything in sight
  { behavior: 'hunter',     aggroSpeed: 0.32, aggroPhase: 0.5,   aimBaseline: 0.7, aimRange: 0.4, aimSpeed: 0.55, aimPhase: 2.8, rockShooter: 0.8 },
  // MAGENTA: Razor — cautious with lethal precision, never wastes a shot
  { behavior: 'cautious',   aggroSpeed: 0.2,  aggroPhase: 3.8,   aimBaseline: 0.95, aimRange: 0.3, aimSpeed: 0.35, aimPhase: 4.5, rockShooter: 0.25 },
  // SKY:     Acrobat — evasive, avoids shooting rocks, icy precision
  { behavior: 'evasive',    aggroSpeed: 0.3,  aggroPhase: 5.0,   aimBaseline: 0.7, aimRange: 0.4, aimSpeed: 0.6, aimPhase: 1.5,  rockShooter: 0.05 },
  // GOLD:    Guardian — extremely protective, avoids ships and asteroids
  { behavior: 'evasive',    aggroSpeed: 0.15, aggroPhase: 2.2,   aimBaseline: 0.6, aimRange: 0.35, aimSpeed: 0.45, aimPhase: 3.0, rockShooter: 0.95 },
  // SILVER:  Everyman — middle of the road on everything
  { behavior: 'hunter',     aggroSpeed: 0.28, aggroPhase: 1.8,   aimBaseline: 0.6, aimRange: 0.35, aimSpeed: 0.5, aimPhase: 2.5, rockShooter: 0.5 },
  // VIOLET:  Aggressive toward ships, less interested in asteroids, area denial
  { behavior: 'aggressive', aggroSpeed: 0.32, aggroPhase: 4.2,   aimBaseline: 0.55, aimRange: 0.4, aimSpeed: 0.55, aimPhase: 1.2, rockShooter: 0.3 },
];

// ─── WEAPON DEFINITIONS ──────────────────────────────────────
const WEAPON_DEFS = {
  basic:        { name:'Standard Issue',    speed:400, life:2.0, fireRate:0.28, damage:3, type:'basic' },
  shotgun:      { name:'Shotgun',        speed:460, life:1.5, fireRate:1.0,  damage:1, type:'shotgun',    pellets:5, spread:14 },
  grenade:      { name:'Grenade',        speed:400, life:1.3, fireRate:2.0,  damage:2, type:'grenade',    fuseTime:0.65, shrapCount:16, shrapDmg:2, shrapLife:0.4, shrapSpeed:300 },
  triple:       { name:'Triple-guns',    speed:400, life:1.8, fireRate:0.6,  damage:2, type:'triple',     burstCount:3, burstDelay:0.05 },
  homing:       { name:'Homing Missiles',speed:300, life:2.4, fireRate:4.0,  damage:2, type:'homing',     launchSpeed:50, boostDelay:0.15 },
  alternating:  { name:'Twin Blasters',  speed:400, life:1.65, fireRate:0.28, damage:2, type:'alternating', offset:6 },
  flamethrower: { name:'Dragonfire',    speed:250, life:2.0, fireRate:2.5,  damage:1, type:'flamethrower',burstCount:30, amplitude:15 },
  sniper:       { name:'Sniper',         speed:780, life:2.0, fireRate:1.05, damage:5, type:'sniper' },
  chaotic:      { name:'Chaotic Shot',   speed:400, life:1.8, fireRate:0.28, damage:3, type:'chaotic' },
  scrap:        { name:'Scrap Shot',     speed:400, life:1.75, fireRate:1.0,  damage:2, type:'scrap',      fuseTime:0.4, shrapCount:5, shrapSpread:20, shrapSpeed:400 },
  snake:        { name:'Snake Shot',     speed:400, life:1.8, fireRate:0.4,  damage:3, type:'snake' },
  gatling:      { name:'Gatling Gun',    speed:720, life:1.8, fireRate:2.6,  damage:1, type:'gatling',    burstCount:15, burstDelay:0.08, spread:4 },
  boomerang:    { name:'Boomerang', speed:350, life:1.8, fireRate:0.35, damage:3, type:'boomerang' },
  doublehelix:  { name:'Double Helix',  speed:450, life:2.2, fireRate:0.64, damage:2.2, type:'doublehelix', offset:4 },
  cyclone:      { name:'Cyclone Shot',  speed:480, life:2.4, fireRate:2.0,  damage:0.8, type:'cyclone',    projectiles:5, innerProjectiles:2 },
  crossshot:    { name:'Cross-Shot',    speed:540, life:1.05, fireRate:0.4, damage:1.5, type:'crossshot',  offset:12, convergeDist:250 },
  lightning:    { name:'Lightning Bolt', speed:1600, life:0.34, fireRate:0.77, damage:3, type:'lightning' },
  concussive:   { name:'Scatterburst',    speed:400, life:1.5, fireRate:0.374, damage:3, type:'concussive', splitCount:4, splitDmg:2, splitLife:0.2, splitSpeed:300 },
  drone:        { name:'Drone Array',     speed:350, life:6.0, fireRate:2.5,   damage:1.5, type:'drone', droneCount:6, armTime:3.0, launchInterval:0.5, orbitSpeed:100, turnRate:0.75 },
};

// Ship index → weapon key mapping
// RED=alternating, GREEN=chaotic, BLUE=grenade, ORANGE=flamethrower,
// PINK=gatling, CYAN=homing, LIME=snake, CORAL=shotgun,
// PURPLE=scrap, WHITE=basic, YELLOW=lightning, MAGENTA=sniper
const SHIP_WEAPONS = ['alternating','chaotic','grenade','flamethrower','gatling','homing','snake','shotgun','scrap','basic','lightning','sniper','cyclone','drone','crossshot','concussive'];

const WEAPON_KEYS = Object.keys(WEAPON_DEFS);

function getWeapon(shipIdx, teamNum) {
  // Per-team weapon pool
  if (teamNum > 0 && teamWeapons[teamNum - 1] && teamWeapons[teamNum - 1].length > 0) {
    const pool = teamWeapons[teamNum - 1];
    const key = pool[randInt(0, pool.length - 1)];
    return {...WEAPON_DEFS[key]};
  }
  if (!settings.weapons && !settings.randomWeapons) return {...WEAPON_DEFS.basic};
  if (settings.randomWeapons) {
    const key = WEAPON_KEYS[randInt(0, WEAPON_KEYS.length - 1)];
    return {...WEAPON_DEFS[key]};
  }
  return {...WEAPON_DEFS[SHIP_WEAPONS[shipIdx]]};
}

// ─── PASSIVE ABILITIES ──────────────────────────────────────
const PASSIVE_DEFS = {
  none:        { name: 'None',         desc: '' },
  scrapRepair: { name: 'Scrap Armor', desc: '+1.5 HP on kill (can overheal)' },
  bioHull:     { name: 'Bio-Hull',     desc: '+1 HP, regen 0.1/2s, -10% accel' },
  nitro:       { name: 'Nitro',        desc: '+30% accel, +40% top speed' },
  gyro:        { name: 'Gyro',         desc: '+30% turn speed' },
  shield:      { name: 'Shield',       desc: 'Ignore first hit' },
  piercing:    { name: 'Piercing',     desc: 'Shots pierce targets' },
  fierce:      { name: 'Fierce',       desc: '+35% damage' },
  hitInvuln:   { name: 'Phase-Out',   desc: '2s invuln on hit, clears debuffs' },
  scope:       { name: 'Scope',        desc: '+20% weapon range' },
  titanium:    { name: 'Titanium',     desc: '-25% incoming damage' },
  stealth:     { name: 'Stealth',      desc: 'Perceived as 1.5x distance' },
  sparkDrive:  { name: 'Spark Drive',  desc: '+20% projectile speed' },
  drillbore:   { name: 'Drillbore',    desc: 'Survives collisions (10% chip dmg)' },
  iceRounds:   { name: 'Ice Rounds',   desc: 'Slows + 0.25 HP DoT' },
  jamRounds:   { name: 'Jam Rounds',   desc: 'Jams hit targets\' fire rate' },
  incendiary:  { name: 'Incendiary',   desc: '50% damage as burn DoT, trail dmg' },
  obliterator: { name: 'Obliterator',  desc: 'Asteroids explode on hit' },
  absorber:    { name: 'Absorber',     desc: 'Bullets delete nearby enemy projectiles' },
  detonator:   { name: 'Detonator',    desc: 'Kill triggers explosion' },
  stunShock:   { name: 'Stun Shock',   desc: 'Hits freeze target turning' },
  override:    { name: 'Override',     desc: 'Hits hijack target controls' },
  cryoCoolant: { name: 'Fast Cycling', desc: '-20% fire cooldown' },
  flagship:    { name: 'Flagship',     desc: '+7 HP, 2.5x size, survives collisions, no maneuvers' },
  blindRounds: { name: 'Blinding Rounds', desc: 'Hits blind enemy detection for 6s' },
  bouncyShot:  { name: 'Bouncy Shot',    desc: 'Bullets ricochet off ships, rocks, and projectiles' },
};
const PASSIVE_KEYS = Object.keys(PASSIVE_DEFS).filter(k => k !== 'none');

// Ship index → passive key mapping
// RED=nitro, GREEN=bouncyShot, BLUE=obliterator, ORANGE=incendiary,
// PINK=sparkDrive, CYAN=shield, LIME=absorber, CORAL=drillbore,
// PURPLE=stealth, WHITE=hitInvuln, YELLOW=stunShock, MAGENTA=scope
const SHIP_PASSIVES = ['nitro','bouncyShot','stealth','incendiary','sparkDrive','shield','absorber','drillbore','obliterator','hitInvuln','stunShock','scope','iceRounds','flagship','gyro','override'];

// Passives that are useless in one-hit-kill (no unique weapons) matches
const ONESHOT_USELESS_PASSIVES = ['hitInvuln'];

function getPassive(shipIdx, teamNum) {
  // Per-team passive pool
  if (teamNum > 0 && teamPassives[teamNum - 1] && teamPassives[teamNum - 1].length > 0) {
    const pool = teamPassives[teamNum - 1];
    return pool[randInt(0, pool.length - 1)];
  }
  const pool = (!settings.weapons)
    ? PASSIVE_KEYS.filter(k => !ONESHOT_USELESS_PASSIVES.includes(k))
    : PASSIVE_KEYS;
  // Chaos mode always randomizes
  if (settings.chaosMode) {
    return pool[randInt(0, pool.length - 1)];
  }
  // Passives disabled → none
  if (!settings.passives) return 'none';
  // Random weapons → random passives too
  if (settings.randomWeapons) {
    return pool[randInt(0, pool.length - 1)];
  }
  // Unique passives from preset map
  if (shipIdx != null) {
    return SHIP_PASSIVES[shipIdx] || 'none';
  }
  return 'none';
}

// ─── MANEUVER ABILITIES ──────────────────────────────────────
const MANEUVER_DEFS = {
  hyperSpeed: {
    name: 'Hyper-Speed', desc: '3x speed burst for 0.75s',
    cooldown: 5, duration: 0.375,
    triggers: { random: 0.01, underFire: 0.05, damaged: 0.06, attacking: 0.025, debuffed: 0.05 },
  },
  barrelRoll: {
    name: 'Barrel Roll', desc: 'Fast loop, +30% fire rate during',
    cooldown: 3, duration: 0.25,
    triggers: { random: 0.01, underFire: 0.06, damaged: 0.04, attacking: 0.025, debuffed: 0.05 },
  },
  quickTurn: {
    name: 'Quick-Turn', desc: 'Boomerang arc into new direction with momentum',
    cooldown: 4, duration: 0.5,
    triggers: { random: 0.005, underFire: 0.06, damaged: 0.075, debuffed: 0.06 },
  },
  turretMode: {
    name: 'Turret Mode', desc: 'Stop and fire at 2x rate, +accuracy',
    cooldown: 4, duration: 1.5,
    triggers: { random: 0.01, underFire: 0.05, damaged: 0.03, attacking: 0.04 },
  },
  serpentine: {
    name: 'Serpentine', desc: '3x speed strafing, 3 sweeps',
    cooldown: 4, duration: 0.45,
    triggers: { random: 0.015, underFire: 0.05, damaged: 0.04, attacking: 0.02, debuffed: 0.04 },
  },
  panic: {
    name: 'Panic', desc: 'Wild spin with 3x fire rate',
    cooldown: 5, duration: 0.4,
    triggers: { random: 0.0, underFire: 0.06, damaged: 0.09, debuffed: 0.07 },
  },
  rapidFire: {
    name: 'Rapid Fire', desc: '2x fire rate for 1s, reduced accuracy',
    cooldown: 6, duration: 0.5,
    triggers: { random: 0.01, underFire: 0.02, damaged: 0.01, attacking: 0.06 },
  },
  spinOut: {
    name: 'Spin Out', desc: 'Boomerang arc into accuracy+speed boost',
    cooldown: 5, duration: 0.8,
    triggers: { random: 0.01, underFire: 0.05, damaged: 0.06, attacking: 0.04, debuffed: 0.05 },
    afterDuration: 1.0, // bonus lasts after maneuver ends
  },
  reverse: {
    name: 'Reverse', desc: 'Fly backwards while firing',
    cooldown: 5, duration: 0.6,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.03, attacking: 0.04 },
  },
  smokescreen: {
    name: 'Smokescreen', desc: 'Particle cloud + near-invisibility',
    cooldown: 10, duration: 2.5,
    triggers: { random: 0.0, underFire: 0.04, damaged: 0.06, debuffed: 0.05 },
  },
  doubleTeam: {
    name: 'Double Team', desc: '4 orbiting decoy clones block projectiles',
    cooldown: 10, duration: 8.0,
    triggers: { random: 0.01, underFire: 0.04, damaged: 0.05, attacking: 0.02, debuffed: 0.04 },
  },
  dumpDebris: {
    name: 'Dump Debris', desc: 'Drop projectile-absorbing debris cloud',
    cooldown: 6, duration: 0.05,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.06, debuffed: 0.05 },
    minSpeedPct: 0.3,
  },
  reflectorShields: {
    name: 'Reflector Shields', desc: 'Orbiting shields reflect projectiles',
    cooldown: 10, duration: 4.5,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.06, debuffed: 0.05 },
  },
  repulsor: {
    name: 'Repulsor', desc: 'Shockwave erases projectiles, blasts particles',
    cooldown: 8, duration: 0.05,
    triggers: { random: 0.01, underFire: 0.04, damaged: 0.05, attacking: 0.02, debuffed: 0.04 },
  },
  shockPulse: {
    name: 'Shock Pulse', desc: 'Massive stun shockwave hits nearby ships',
    cooldown: 10, duration: 0.05,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.06, attacking: 0.03 },
  },
  mineField: {
    name: 'Mine Field', desc: 'Drop 3 proximity mines',
    cooldown: 15, duration: 1.25,
    triggers: { random: 0.02, underFire: 0.04, damaged: 0.05 },
    minGameTime: 4, // not usable in first 8 seconds
  },
};
const MANEUVER_KEYS = Object.keys(MANEUVER_DEFS);

// RED=rapidFire, GREEN=reverse, BLUE=mineField, ORANGE=smokescreen,
// PINK=doubleTeam, CYAN=barrelRoll, LIME=repulsor, CORAL=hyperSpeed,
// PURPLE=dumpDebris, WHITE=reflectorShields, YELLOW=shockPulse, MAGENTA=turretMode
const SHIP_MANEUVERS = ['rapidFire','reverse','mineField','smokescreen','doubleTeam','barrelRoll','repulsor','hyperSpeed','dumpDebris','reflectorShields','shockPulse','turretMode','spinOut','repulsor','panic','quickTurn'];

function getManeuver(shipIdx, teamNum) {
  // Per-team maneuver pool
  if (teamNum > 0 && teamManeuvers[teamNum - 1] && teamManeuvers[teamNum - 1].length > 0) {
    const pool = teamManeuvers[teamNum - 1];
    return pool[randInt(0, pool.length - 1)];
  }
  if (!settings.maneuvers) return 'none';
  // Chaos mode always randomizes
  if (settings.chaosMode) {
    return MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
  }
  // Random weapons → random maneuvers too
  if (settings.randomWeapons) {
    return MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
  }
  // Preset assignment
  if (shipIdx != null) {
    return SHIP_MANEUVERS[shipIdx] || MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
  }
  return MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
}

// Check if a maneuver should trigger this AI tick
function checkManeuverTrigger(ship) {
  if (ship.maneuver === 'none' || ship.maneuverCooldown > 0 || ship.maneuverActive) return false;
  const def = MANEUVER_DEFS[ship.maneuver];
  if (!def) return false;

  // Determine active contexts
  const recentlyDamaged = ship.lastAttacker >= 0 && (gameTime - ship.lastAttackerTime) < 1;
  const underFire = !!ship._bulletThreat;
  const attacking = !!ship._aiShoot;
  const debuffed = ship.iceSlow > 0 || ship.jamSlow > 0 || ship.stunTimer > 0 || ship.overrideTimer > 0 || ship.blindTimer > 0;

  // Incoming homing missile — always trigger if off cooldown (except turret mode)
  if (ship.maneuver !== 'turretMode') {
    for (const b of bullets) {
      if (b.type === 'homing' && !b.isShrapnel && b.owner !== ship.id) {
        const d = dist(ship, b);
        if (d < 300) return true;
      }
    }
  }

  // Accumulate trigger chance from all active contexts
  let chance = def.triggers.random || 0;
  if (underFire) chance = Math.max(chance, def.triggers.underFire || 0);
  if (recentlyDamaged) chance = Math.max(chance, def.triggers.damaged || 0);
  if (attacking) chance = Math.max(chance, def.triggers.attacking || 0);
  if (debuffed) chance = Math.max(chance, def.triggers.debuffed || 0);

  // Minimum speed requirement (e.g. Dump Debris)
  if (def.minSpeedPct) {
    const spd = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
    const maxSpd = CFG.SHIP_MAX_SPEED * (ship.passive === 'nitro' ? 1.4 : 1);
    if (spd < maxSpd * def.minSpeedPct) return false;
  }

  // Minimum game time requirement (e.g. Mine Field)
  if (def.minGameTime && gameTime < def.minGameTime) return false;

  return Math.random() < chance;
}

// Activate a maneuver
function startManeuver(ship) {
  const def = MANEUVER_DEFS[ship.maneuver];
  if (!def) return;
  ship.maneuverActive = true;
  ship.maneuverTimer = def.duration;
  ship.maneuverCooldown = def.cooldown;
  // Double Team: cooldown starts after duration ends, not at activation
  if (ship.maneuver === 'doubleTeam') ship.maneuverCooldown = 0;

  if (ship.maneuver === 'hyperSpeed') {
    // Moderate initial kick in current facing direction (ramps up each frame)
    const curSpeed = Math.hypot(ship.vx, ship.vy);
    const kickSpeed = Math.max(curSpeed, CFG.SHIP_MAX_SPEED * 1.5);
    ship.vx = Math.cos(ship.ang) * kickSpeed;
    ship.vy = Math.sin(ship.ang) * kickSpeed;
    // Visual: shockwave + bright trail burst
    spawnExplosion(ship.x, ship.y, ship.color, 10, 60);
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 40, life: 0.3, color: ship.color });
  }

  if (ship.maneuver === 'teleport') {
    // Phase 1: charging — ship visible, emitting shockwaves for 0.5s
    ship._teleportPhase = 'charging';
    // Pick a random dash direction
    ship._teleportAng = rand(0, Math.PI * 2);
    ship._teleportShockTimer = 0;
  }

  if (ship.maneuver === 'barrelRoll') {
    ship._rollDir = Math.random() < 0.5 ? 1 : -1;
    // Boost speed slightly
    const boostSpeed = CFG.SHIP_MAX_SPEED * 1.5;
    const curSpeed = Math.hypot(ship.vx, ship.vy);
    if (curSpeed < boostSpeed) {
      ship.vx = Math.cos(ship.ang) * boostSpeed;
      ship.vy = Math.sin(ship.ang) * boostSpeed;
    }
    spawnExplosion(ship.x, ship.y, ship.color, 6, 40);
  }

  if (ship.maneuver === 'quickTurn') {
    // Boomerang arc — pick target roughly 180° back with slight randomness
    const cAng = Math.atan2(ship.vy, ship.vx);
    ship._quickTurnTarget = cAng + Math.PI + rand(-0.4, 0.4);
    ship._quickTurnDone = false;
    spawnExplosion(ship.x, ship.y, ship.color, 6, 40);
  }

  if (ship.maneuver === 'turretMode') {
    // Halt movement
    spawnExplosion(ship.x, ship.y, ship.color, 6, 30);
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 25, life: 0.3, color: ship.color });
  }

  if (ship.maneuver === 'serpentine') {
    ship._serpDir = Math.random() < 0.5 ? 1 : -1;
    ship._serpSweep = 0; // counts completed direction changes
    ship._serpTimer = 0;
    spawnExplosion(ship.x, ship.y, ship.color, 5, 30);
  }

  if (ship.maneuver === 'panic') {
    // Random spin between 270-540 degrees
    const spinDeg = rand(270, 540);
    ship._panicSpinTotal = spinDeg * Math.PI / 180;
    ship._panicSpinDone = 0;
    ship._panicDir = Math.random() < 0.5 ? 1 : -1;
    spawnExplosion(ship.x, ship.y, ship.color, 8, 50);
  }

  if (ship.maneuver === 'rapidFire') {
    ship.fireCooldown = 0; // start shooting immediately
    spawnExplosion(ship.x, ship.y, ship.color, 5, 30);
  }

  if (ship.maneuver === 'spinOut') {
    // Boomerang arc — pick target roughly 180° back with slight randomness
    const cAng = Math.atan2(ship.vy, ship.vx);
    ship._spinOutArcTarget = cAng + Math.PI + rand(-0.4, 0.4);
    ship._spinOutPhase = 'arc';
    ship._spinOutBoostTimer = 0;
    spawnExplosion(ship.x, ship.y, ship.color, 6, 40);
  }

  if (ship.maneuver === 'reverse') {
    // Phase 1: decel (0.2s), Phase 2: reverse thrust (1.0s)
    ship._reversePhase = 'decel';
    spawnExplosion(ship.x, ship.y, ship.color, 5, 30);
  }

  if (ship.maneuver === 'smokescreen') {
    // Emit a big cloud of grey particles puffing in all directions
    for (let i = 0; i < 50; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(60, 200);
      particles.push({
        x: ship.x + rand(-15, 15), y: ship.y + rand(-15, 15),
        vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
        life: rand(1.5, 3.0), maxLife: 3.0,
        color: '#888888', size: rand(3, 7),
      });
    }
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 80, life: 0.4, color: '#888888' });
    ship._smokestealthTimer = 5.0;
    smokeDecoys.push({ x: ship.x, y: ship.y, ownerId: ship.id, ownerTeam: ship.team || 0, life: 2.0 });
  }

  if (ship.maneuver === 'doubleTeam') {
    // Spawn 4 clones: front, back, left, right — orbiting the ship
    const offsetDist = ship.r * 5;
    const dur = MANEUVER_DEFS.doubleTeam.duration;
    for (let ci = 0; ci < 4; ci++) {
      const orbitStart = (ci / 4) * Math.PI * 2; // 0, π/2, π, 3π/2
      shipClones.push({
        ownerId: ship.id,
        shipId: ship.shipType,
        _designForced: ship._designForced,
        x: ship.x, y: ship.y,
        ang: ship.ang,
        r: ship.r,
        color: ship.color,
        orbitAngle: orbitStart,
        orbitRadiusBase: offsetDist,
        orbitDuration: dur, // used to calc expansion
        orbitElapsed: 0,
        life: dur + 1, // lives slightly longer than maneuver
        hit: false,
        hitTimer: 0,
        alive: true,
      });
    }
    spawnExplosion(ship.x, ship.y, ship.color, 10, 50);
  }

  if (ship.maneuver === 'dumpDebris') {
    // Spawn 120 debris squares behind the ship
    const backAng = ship.ang + Math.PI;
    for (let i = 0; i < 120; i++) {
      // Cone behind the ship, ±60 degrees
      const a = backAng + rand(-1.05, 1.05);
      const sp = rand(30, 200);
      debrisField.push({
        x: ship.x + Math.cos(backAng) * ship.r + rand(-20, 20),
        y: ship.y + Math.sin(backAng) * ship.r + rand(-20, 20),
        vx: Math.cos(a) * sp + ship.vx * 0.3,
        vy: Math.sin(a) * sp + ship.vy * 0.3,
        size: rand(3, 7),
        life: rand(4.0, 8.0),
        color: ship.color,
        ownerId: ship.id,
      });
    }
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 80, life: 0.4, color: ship.color });
  }

  if (ship.maneuver === 'reflectorShields') {
    // Spawn 3 orbiting shield panels
    ship._reflectorAngle = 0;
    for (let i = 0; i < 3; i++) {
      reflectorShields.push({
        ownerId: ship.id,
        index: i,
        baseAngle: (Math.PI * 2 / 3) * i, // evenly spaced 120° apart
        orbitRadius: ship.r * 2.5,
        halfLength: ship.r * 0.9, // ~half ship length
        color: ship.color,
        life: 6.0,
      });
    }
    spawnExplosion(ship.x, ship.y, ship.color, 8, 40);
  }

  if (ship.maneuver === 'repulsor') {
    // Expanding shockwave that affects projectiles as it passes
    ship._repulsorX = ship.x;
    ship._repulsorY = ship.y;
    ship._repulsorLife = 0.5;    // matches shockwave maxLife
    ship._repulsorMaxLife = 0.5;
    ship._repulsorRadius = 350;  // matches shockwave maxR
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 350, life: 0.5, maxLife: 0.5, color: ship.color });
    spawnExplosion(ship.x, ship.y, ship.color, 15, 80);
    playShootRise();
  }

  if (ship.maneuver === 'shockPulse') {
    // Massive stun pulse — 2x repulsor radius
    const pulseRadius = 700;
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: pulseRadius, life: 0.6, maxLife: 0.6, color: '#ffff44' });
    spawnExplosion(ship.x, ship.y, '#ffff44', 20, 120);
    playShootRise();
    // Stun all enemy ships in range
    let stunHit = false;
    for (const target of ships) {
      if (!target.alive || target.id === ship.id || target.invuln > 0) continue;
      if (ship.team > 0 && target.team === ship.team) continue;
      if (dist(ship, target) < pulseRadius) {
        target.stunTimer = 1.75;
        stunHit = true;
        // Stun arc sparks on affected ship
        for (let sp = 0; sp < 4; sp++) {
          const a = rand(0, Math.PI * 2);
          const arcLen = rand(10, 25);
          const segs = randInt(2, 3);
          const ap = [{x: 0, y: 0}];
          for (let s = 1; s <= segs; s++) {
            const t = s / segs;
            ap.push({
              x: Math.cos(a) * arcLen * t + rand(-5, 5),
              y: Math.sin(a) * arcLen * t + rand(-5, 5)
            });
          }
          particles.push({
            x: target.x + rand(-target.r, target.r),
            y: target.y + rand(-target.r, target.r),
            vx: Math.cos(a) * rand(40, 80), vy: Math.sin(a) * rand(40, 80),
            life: rand(0.15, 0.3), maxLife: 0.3,
            color: '#ffff44', size: 1.5,
            isArc: true, arcPoints: ap,
          });
        }
      }
    }
    if (stunHit) playDebuff();
  }

  if (ship.maneuver === 'mineField') {
    ship._minesDropped = 0;
    ship._mineDropTimer = 0; // drop first mine immediately
  }
}

// Process active maneuver each frame
function updateManeuver(ship, dt) {
  if (!ship.maneuverActive) return;
  ship.maneuverTimer -= dt;

  if (ship.maneuver === 'hyperSpeed') {
    // Allow speed to exceed normal cap during maneuver (3x)
    ship._hyperSpeedActive = true;
    if (ship.maneuverTimer > 0.25) {
      // Accelerating phase: heavy thrust
      ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * 8 * dt;
      ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * 8 * dt;
    } else {
      // Decelerating phase: heavy drag to bleed speed
      const brakeFactor = 1 - 3.5 * dt;
      ship.vx *= Math.max(0, brakeFactor);
      ship.vy *= Math.max(0, brakeFactor);
    }
    ship.thrustOn = true;
    // Spawn speed trail particles — center + two rear corners
    const backAng = ship.ang + Math.PI;
    const perpAng = ship.ang + Math.PI * 0.5;
    if (Math.random() < 0.7) {
      particles.push({
        x: ship.x + Math.cos(backAng) * ship.r + rand(-8, 8),
        y: ship.y + Math.sin(backAng) * ship.r + rand(-8, 8),
        vx: Math.cos(backAng) * rand(100, 200), vy: Math.sin(backAng) * rand(100, 200),
        life: rand(0.3, 0.6), maxLife: 0.6, color: ship.color, size: rand(2, 5),
      });
    }
    // Left rear corner trail
    if (Math.random() < 0.6) {
      const cx = ship.x + Math.cos(backAng) * ship.r * 0.7 + Math.cos(perpAng) * ship.r * 0.6;
      const cy = ship.y + Math.sin(backAng) * ship.r * 0.7 + Math.sin(perpAng) * ship.r * 0.6;
      particles.push({
        x: cx + rand(-3, 3), y: cy + rand(-3, 3),
        vx: Math.cos(backAng) * rand(80, 160) + rand(-15, 15),
        vy: Math.sin(backAng) * rand(80, 160) + rand(-15, 15),
        life: rand(0.25, 0.5), maxLife: 0.5, color: ship.color, size: rand(1.5, 3.5),
      });
    }
    // Right rear corner trail
    if (Math.random() < 0.6) {
      const cx = ship.x + Math.cos(backAng) * ship.r * 0.7 - Math.cos(perpAng) * ship.r * 0.6;
      const cy = ship.y + Math.sin(backAng) * ship.r * 0.7 - Math.sin(perpAng) * ship.r * 0.6;
      particles.push({
        x: cx + rand(-3, 3), y: cy + rand(-3, 3),
        vx: Math.cos(backAng) * rand(80, 160) + rand(-15, 15),
        vy: Math.sin(backAng) * rand(80, 160) + rand(-15, 15),
        life: rand(0.25, 0.5), maxLife: 0.5, color: ship.color, size: rand(1.5, 3.5),
      });
    }
  }

  if (ship.maneuver === 'teleport') {
    const phaseDuration = 0.5; // phasing lasts 1s
    const chargeDuration = 0.25; // charging lasts 0.5s
    const phaseStart = phaseDuration; // timer value when phasing begins

    if (ship._teleportPhase === 'charging') {
      // Emit concentric shockwaves during charge-up
      ship._teleportShockTimer -= dt;
      if (ship._teleportShockTimer <= 0) {
        ship._teleportShockTimer = 0.05;
        shockwaves.push({
          x: ship.x, y: ship.y, r: 0,
          maxR: rand(25, 50), life: 0.3, maxLife: 0.3, color: ship.color,
        });
      }
      // Transition to phasing at 1.0s remaining
      if (ship.maneuverTimer <= phaseStart) {
        ship._teleportPhase = 'phasing';
        ship.invuln = phaseDuration + 0.15;
        spawnExplosion(ship.x, ship.y, ship.color, 15, 80);
        shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 50, life: 0.4, color: ship.color });
        // Set initial dash velocity
        ship.vx = Math.cos(ship._teleportAng) * CFG.SHIP_MAX_SPEED * 1.7;
        ship.vy = Math.sin(ship._teleportAng) * CFG.SHIP_MAX_SPEED * 1.7;
      }
    }

    if (ship._teleportPhase === 'phasing') {
      // First half: accelerate. Second half: decelerate.
      const phaseElapsed = phaseStart - ship.maneuverTimer;
      const phaseT = phaseElapsed / phaseDuration; // 0→1
      if (phaseT < 0.5) {
        // Accelerate in dash direction
        ship.vx += Math.cos(ship._teleportAng) * CFG.SHIP_THRUST * 4 * dt;
        ship.vy += Math.sin(ship._teleportAng) * CFG.SHIP_THRUST * 4 * dt;
      } else {
        // Heavy drag to decelerate
        const brakeFactor = 1 - 4.0 * dt;
        ship.vx *= Math.max(0, brakeFactor);
        ship.vy *= Math.max(0, brakeFactor);
      }

      // Asteroid evasion while invisible — steer away from imminent collisions
      if (ship.passive !== 'drillbore' || ship.hp <= 0.5) {
        let evadeX = 0, evadeY = 0, evadeN = 0;
        for (const ast of asteroids) {
          const d = dist(ship, ast);
          if (d > ast.r + 400) continue;
          const col = predictCollision(ship, ast, 1.0);
          if (col) {
            const toAst = angle(ship, ast);
            const urgency = 1 / (col.t + 0.05);
            evadeX -= Math.cos(toAst) * urgency;
            evadeY -= Math.sin(toAst) * urgency;
            evadeN++;
          }
        }
        if (evadeN > 0) {
          const evadeAng = Math.atan2(evadeY, evadeX);
          ship.vx += Math.cos(evadeAng) * CFG.SHIP_THRUST * 3 * dt;
          ship.vy += Math.sin(evadeAng) * CFG.SHIP_THRUST * 3 * dt;
        }
      }

      // Faint particle trail (visible but subtle)
      if (Math.random() < 0.4) {
        particles.push({
          x: ship.x + rand(-5, 5), y: ship.y + rand(-5, 5),
          vx: rand(-20, 20), vy: rand(-20, 20),
          life: rand(0.3, 0.5), maxLife: 0.5,
          color: ship.color, size: rand(1, 2.5),
        });
      }
    }
  }

  if (ship.maneuver === 'barrelRoll') {
    // Force rapid turn
    ship.ang += ship._rollDir * CFG.SHIP_TURN_SPEED * 4 * dt;
    // Thrust forward during roll
    ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * 1.5 * dt;
    ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * 1.5 * dt;
    ship.thrustOn = true;
    // Trail
    if (Math.random() < 0.5) {
      particles.push({
        x: ship.x + rand(-6, 6), y: ship.y + rand(-6, 6),
        vx: rand(-40, 40), vy: rand(-40, 40),
        life: 0.25, maxLife: 0.25, color: ship.color, size: rand(1, 3),
      });
    }
  }

  if (ship.maneuver === 'quickTurn') {
    // Boomerang arc — smooth curve carrying momentum into new direction
    const spd = Math.hypot(ship.vx, ship.vy);
    const cAng = Math.atan2(ship.vy, ship.vx);
    const turnNeeded = shortAngleDist(cAng, ship._quickTurnTarget);
    const turnRate = 8; // radians/sec — same as boomerang projectile
    const turn = Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), turnRate * dt);
    const nAng = cAng + turn;
    // Accelerate through the arc
    const newSpd = Math.min(spd + 200 * dt, CFG.SHIP_MAX_SPEED * 1.8);
    ship.vx = Math.cos(nAng) * newSpd;
    ship.vy = Math.sin(nAng) * newSpd;
    ship.ang = nAng; // face velocity direction
    ship.thrustOn = true;
    if (Math.abs(turnNeeded) < 0.2) ship._quickTurnDone = true;
    // Arc trail particles
    if (Math.random() < 0.6) {
      const backAng = nAng + Math.PI;
      particles.push({
        x: ship.x + Math.cos(backAng) * ship.r + rand(-4, 4),
        y: ship.y + Math.sin(backAng) * ship.r + rand(-4, 4),
        vx: Math.cos(backAng) * rand(20, 50) + rand(-15, 15),
        vy: Math.sin(backAng) * rand(20, 50) + rand(-15, 15),
        life: rand(0.2, 0.4), maxLife: 0.4, color: ship.color, size: rand(1.5, 3),
      });
    }
  }

  if (ship.maneuver === 'turretMode') {
    // Rapidly decelerate to 0 — but allow turning
    const brakeFactor = 1 - 8.0 * dt;
    ship.vx *= Math.max(0, brakeFactor);
    ship.vy *= Math.max(0, brakeFactor);
    ship._aiThrust = false; // suppress forward thrust
    ship.thrustOn = false;
    // Force firing
    ship._aiShoot = true;
    // Subtle anchor particles
    if (Math.random() < 0.3) {
      particles.push({
        x: ship.x + rand(-8, 8), y: ship.y + rand(-8, 8),
        vx: rand(-15, 15), vy: rand(-15, 15),
        life: 0.2, maxLife: 0.2, color: ship.color, size: rand(1, 2),
      });
    }
  }

  if (ship.maneuver === 'serpentine') {
    // 3 sweeps, alternating direction, each 0.3s
    const sweepDur = 0.3;
    ship._serpTimer += dt;
    if (ship._serpTimer >= sweepDur) {
      ship._serpTimer -= sweepDur;
      ship._serpDir *= -1;
      ship._serpSweep++;
    }
    // Strong lateral strafe at 3x normal speed
    const perpAng = ship.ang + Math.PI * 0.5 * ship._serpDir;
    const strafeForce = CFG.SHIP_THRUST * 3;
    ship.vx += Math.cos(perpAng) * strafeForce * dt;
    ship.vy += Math.sin(perpAng) * strafeForce * dt;
    // Slight forward thrust to maintain momentum
    ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * 0.5 * dt;
    ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * 0.5 * dt;
    ship.thrustOn = true;
    // Trail
    if (Math.random() < 0.4) {
      particles.push({
        x: ship.x + rand(-5, 5), y: ship.y + rand(-5, 5),
        vx: rand(-30, 30), vy: rand(-30, 30),
        life: 0.2, maxLife: 0.2, color: ship.color, size: rand(1, 2.5),
      });
    }
  }

  if (ship.maneuver === 'panic') {
    // Spin rapidly — no forward thrust
    const spinRate = ship._panicSpinTotal / MANEUVER_DEFS.panic.duration;
    const spinStep = spinRate * dt;
    ship.ang += ship._panicDir * spinStep;
    ship._panicSpinDone += spinStep;
    // Force rapid fire
    ship._aiShoot = true;
    // Frantic particles
    if (Math.random() < 0.5) {
      const a = rand(0, Math.PI * 2);
      particles.push({
        x: ship.x + Math.cos(a) * ship.r, y: ship.y + Math.sin(a) * ship.r,
        vx: Math.cos(a) * rand(40, 80), vy: Math.sin(a) * rand(40, 80),
        life: 0.25, maxLife: 0.25, color: ship.color, size: rand(1, 3),
      });
    }
  }

  if (ship.maneuver === 'rapidFire') {
    // Force firing, movement handled by normal AI
    ship._aiShoot = true;
    // Subtle muzzle flash particles
    if (Math.random() < 0.3) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r;
      const fy = ship.y + Math.sin(ship.ang) * ship.r;
      particles.push({
        x: fx, y: fy,
        vx: Math.cos(ship.ang) * rand(30, 60) + rand(-20, 20),
        vy: Math.sin(ship.ang) * rand(30, 60) + rand(-20, 20),
        life: 0.15, maxLife: 0.15, color: ship.color, size: rand(1, 2),
      });
    }
  }

  if (ship.maneuver === 'spinOut') {
    const totalDur = MANEUVER_DEFS.spinOut.duration;
    const elapsed = totalDur - ship.maneuverTimer;
    if (elapsed < 0.5) {
      // Phase 1: Boomerang arc — smooth curve like quick-turn
      ship._spinOutPhase = 'arc';
      ship._aiShoot = false;
      const spd = Math.hypot(ship.vx, ship.vy);
      const cAng = Math.atan2(ship.vy, ship.vx);
      const turnNeeded = shortAngleDist(cAng, ship._spinOutArcTarget);
      const turnRate = 8;
      const turn = Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), turnRate * dt);
      const nAng = cAng + turn;
      const newSpd = Math.min(spd + 150 * dt, CFG.SHIP_MAX_SPEED * 1.5);
      ship.vx = Math.cos(nAng) * newSpd;
      ship.vy = Math.sin(nAng) * newSpd;
      ship.ang = nAng;
      ship.thrustOn = true;
      // Arc trail particles
      if (Math.random() < 0.6) {
        const backAng = nAng + Math.PI;
        particles.push({
          x: ship.x + Math.cos(backAng) * ship.r + rand(-4, 4),
          y: ship.y + Math.sin(backAng) * ship.r + rand(-4, 4),
          vx: Math.cos(backAng) * rand(20, 50) + rand(-15, 15),
          vy: Math.sin(backAng) * rand(20, 50) + rand(-15, 15),
          life: rand(0.2, 0.4), maxLife: 0.4, color: ship.color, size: rand(1.5, 3),
        });
      }
    } else {
      // Phase 2: Brake and prepare for boost
      ship._spinOutPhase = 'brake';
      const brakeFactor = 1 - 5.0 * dt;
      ship.vx *= Math.max(0, brakeFactor);
      ship.vy *= Math.max(0, brakeFactor);
      ship.thrustOn = false;
      // Tire-smoke style particles
      if (Math.random() < 0.5) {
        const backAng = ship.ang + Math.PI;
        particles.push({
          x: ship.x + Math.cos(backAng) * ship.r + rand(-6, 6),
          y: ship.y + Math.sin(backAng) * ship.r + rand(-6, 6),
          vx: Math.cos(backAng) * rand(30, 60) + rand(-20, 20),
          vy: Math.sin(backAng) * rand(30, 60) + rand(-20, 20),
          life: rand(0.3, 0.6), maxLife: 0.6, color: '#aaaaaa', size: rand(2, 4),
        });
      }
    }
  }

  if (ship.maneuver === 'reverse') {
    const elapsed = MANEUVER_DEFS.reverse.duration - ship.maneuverTimer;
    if (elapsed < 0.2) {
      // Phase 1: rapid deceleration
      ship._reversePhase = 'decel';
      const brakeFactor = 1 - 10.0 * dt;
      ship.vx *= Math.max(0, brakeFactor);
      ship.vy *= Math.max(0, brakeFactor);
      ship._aiThrust = false;
      ship.thrustOn = false;
    } else {
      // Phase 2: reverse thrust — accelerate backwards while AI aims normally
      ship._reversePhase = 'reverse';
      const backAng = ship.ang + Math.PI;
      ship.vx += Math.cos(backAng) * CFG.SHIP_THRUST * dt;
      ship.vy += Math.sin(backAng) * CFG.SHIP_THRUST * dt;
      ship._aiThrust = false; // suppress normal forward thrust
      ship.thrustOn = true;
      ship._aiShoot = true;
      // Reverse thrust particles from front
      if (Math.random() < 0.4) {
        const fx = ship.x + Math.cos(ship.ang) * ship.r;
        const fy = ship.y + Math.sin(ship.ang) * ship.r;
        particles.push({
          x: fx + rand(-4, 4), y: fy + rand(-4, 4),
          vx: Math.cos(ship.ang) * rand(40, 80), vy: Math.sin(ship.ang) * rand(40, 80),
          life: 0.375, maxLife: 0.375, color: ship.color, size: rand(1, 3),
        });
      }
    }
  }

  if (ship.maneuver === 'smokescreen') {
    // Ongoing particle drizzle for first 0.5s
    const elapsed = MANEUVER_DEFS.smokescreen.duration - ship.maneuverTimer;
    if (elapsed < 0.5 && Math.random() < 0.6) {
      const a = rand(0, Math.PI * 2);
      particles.push({
        x: ship.x + rand(-10, 10), y: ship.y + rand(-10, 10),
        vx: Math.cos(a) * rand(15, 50), vy: Math.sin(a) * rand(15, 50),
        life: rand(1.0, 2.0), maxLife: 2.0, color: '#888888', size: rand(3, 6),
      });
    }
  }

  if (ship.maneuver === 'reflectorShields') {
    // Advance orbit angle (fast rotation)
    ship._reflectorAngle += Math.PI * 2.5 * dt; // ~2.5 rev/sec
    // Suppress firing
    ship._aiShoot = false;
  }

  if (ship.maneuver === 'mineField') {
    ship._mineDropTimer -= dt;
    if (ship._mineDropTimer <= 0 && ship._minesDropped < 3) {
      // Drop a mine from the back of the ship
      const backAng = ship.ang + Math.PI;
      mines.push({
        x: ship.x + Math.cos(backAng) * ship.r * 1.5,
        y: ship.y + Math.sin(backAng) * ship.r * 1.5,
        ownerId: ship.id,
        ownerTeam: ship.team || 0,
        color: ship.color,
        life: 22.5,
        r: 5,
        proximityRadius: 200,
        armTimer: 1.0, // cannot detonate until armed
      });
      ship._minesDropped++;
      ship._mineDropTimer = 0.5; // next mine in 1s
      spawnExplosion(ship.x + Math.cos(backAng) * ship.r * 1.5,
                     ship.y + Math.sin(backAng) * ship.r * 1.5, ship.color, 5, 20);
    }
  }

  // End maneuver
  if (ship.maneuverTimer <= 0) {
    ship.maneuverActive = false;
    ship._hyperSpeedActive = false;

    if (ship.maneuver === 'teleport') {
      // Reappear with burst
      ship._teleportPhase = null;
      ship.vx *= 0.2; ship.vy *= 0.2; // kill most remaining velocity
      spawnExplosion(ship.x, ship.y, ship.color, 15, 80);
      shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 50, life: 0.4, color: ship.color });
    }

    if (ship.maneuver === 'quickTurn') {
      // Increased likelihood to fire immediately after turn
      ship.fireCooldown = 0;
      ship._aiShoot = true;
    }

    if (ship.maneuver === 'spinOut') {
      // Activate post-maneuver accuracy+speed boost
      ship._spinOutBoostTimer = MANEUVER_DEFS.spinOut.afterDuration;
      ship.fireCooldown = 0;
      ship._aiShoot = true;
      spawnExplosion(ship.x, ship.y, ship.color, 8, 50);
    }

    if (ship.maneuver === 'doubleTeam') {
      // Cooldown starts now, after duration ends
      ship.maneuverCooldown = MANEUVER_DEFS.doubleTeam.cooldown;
    }

    if (ship.maneuver === 'reflectorShields') {
      // Remove all shields belonging to this ship
      for (let i = reflectorShields.length - 1; i >= 0; i--) {
        if (reflectorShields[i].ownerId === ship.id) {
          reflectorShields.splice(i, 1);
        }
      }
    }
  }
}

// ─── WEAPON FIRE SYSTEM ─────────────────────────────────────
function makeBullet(ship, x, y, vx, vy, opts) {
  const o = opts || {};
  const scopeMult = ship.passive === 'scope' ? 1.2 : 1;
  const sparkMult = ship.passive === 'sparkDrive' ? 1.2 : 1;
  return {
    x, y, vx: vx * sparkMult, vy: vy * sparkMult,
    life: (o.life ?? ship.weapon.life) * scopeMult,
    owner: ship.id, color: o.color ?? ship.color,
    damage: (o.damage ?? ship.weapon.damage) * (ship.passive === 'fierce' ? 1.35 : 1),
    type: o.type ?? ship.weapon.type,
    size: o.size ?? 3,
    detonateTime: o.detonateTime ?? null,
    contactDetonate: o.contactDetonate ?? false,
    isShrapnel: o.isShrapnel ?? false,
    armed: o.armed ?? true,
    armTime: o.armTime ?? 0,
    fireAng: o.fireAng ?? ship.ang,
    spawnTime: gameTime,
    curveRate: o.curveRate ?? 0,
    sineAmp: o.sineAmp ?? 0,
    sineFreq: o.sineFreq ?? 0,
    boomerang: o.boomerang ?? false,
    maxLife: o.maxLife ?? null,
    helixSide: o.helixSide ?? 0,
    helixId: o.helixId ?? null,
    helixGrow: o.helixGrow ?? false,
    cyclone: o.cyclone ?? false,
    cycloneAng: o.cycloneAng ?? 0,
    cycloneCx: o.cycloneCx ?? 0,
    cycloneCy: o.cycloneCy ?? 0,
    cycloneFireAng: o.cycloneFireAng ?? 0,
    cycloneSpeed: o.cycloneSpeed ?? 0,
    cycloneId: o.cycloneId ?? null,
    cycloneRadiusMult: o.cycloneRadiusMult ?? 1,
    lightning: o.lightning ?? false,
    lightningZigTimer: o.lightningZigTimer ?? 0,
    lightningOrigAng: o.lightningOrigAng ?? (o.fireAng ?? ship.ang),
    lightningSplitsLeft: o.lightningSplitsLeft ?? 0,
    concussive: o.concussive ?? false,
    concussiveTimer: o.concussiveTimer ?? 0,
    incId: ship.passive === 'incendiary' ? ++incBulletCounter : 0,
    ownerPassive: ship.passive,
    ownerTeam: ship.team || 0,
  };
}

function removeHelixPartner(b) {
  if (b.type !== 'doublehelix' || !b.helixId) return;
  const partner = bullets.find(o => o !== b && o.helixId === b.helixId);
  if (partner) partner.life = 0; // will be cleaned up on next tick
}

function fireWeapon(ship) {
  const w = ship.weapon;
  const accNoise = ship.maneuverActive && ship.maneuver === 'rapidFire' ? rand(-0.15, 0.15) : 0;
  const ang = ship.ang + accNoise;
  const bx = ship.x + Math.cos(ang) * ship.r * 1.2;
  const by = ship.y + Math.sin(ang) * ship.r * 1.2;
  // Spin Out boost: 50% faster projectiles
  const wSpd = w.speed * (ship._spinOutBoostTimer > 0 ? 1.5 : 1);
  // Scale weapon offsets with ship size (for Flagship etc)
  const sizeScale = ship.r / CFG.SHIP_RADIUS;

  switch (w.type) {
    case 'basic':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3));
      break;

    case 'shotgun': {
      const sr = (w.spread/2) * Math.PI/180;
      for (let i = 0; i < w.pellets; i++) {
        const off = (i/(w.pellets-1) - 0.5) * 2 * sr;
        const a = ang + off;
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(a)*wSpd + ship.vx*0.3,
          Math.sin(a)*wSpd + ship.vy*0.3, {size:2}));
      }
      break;
    }

    case 'grenade': {
      const grenSpd = wSpd * rand(0.35, 1.6);
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*grenSpd + ship.vx*0.7,
        Math.sin(ang)*grenSpd + ship.vy*0.7,
        {detonateTime: w.fuseTime, contactDetonate: true, size:5}));
      break;
    }

    case 'triple':
      for (let i = 0; i < w.burstCount; i++)
        ship.burstQueue.push({time: gameTime + i*w.burstDelay, type:'triple'});
      break;

    case 'homing': {
      const perp = ang + Math.PI/2;
      const sOff = ship.r * 1.5;
      for (const side of [-1, 1]) {
        const mx = ship.x + Math.cos(perp)*sOff*side;
        const my = ship.y + Math.sin(perp)*sOff*side;
        bullets.push(makeBullet(ship, mx, my,
          Math.cos(perp)*w.launchSpeed*side,
          Math.sin(perp)*w.launchSpeed*side,
          {armed:false, armTime:w.boostDelay, fireAng:ang, size:4}));
      }
      break;
    }

    case 'alternating': {
      const perp = ang + Math.PI/2;
      for (const side of [-1, 1]) {
        const ox = bx + Math.cos(perp)*w.offset*sizeScale*side;
        const oy = by + Math.sin(perp)*w.offset*sizeScale*side;
        bullets.push(makeBullet(ship, ox, oy,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3));
      }
      break;
    }

    case 'flamethrower':
      for (let i = 0; i < w.burstCount; i++)
        ship.burstQueue.push({time: gameTime + i*0.027, type:'flamethrower', idx:i, total:w.burstCount});
      break;

    case 'sniper':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3, {size:2}));
      break;

    case 'chaotic':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {curveRate: rand(-4, 4), life: w.life * 2}));
      break;

    case 'scrap':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {detonateTime: w.fuseTime, contactDetonate: false, size:4}));
      break;

    case 'snake':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {sineAmp: 8, sineFreq: 14}));
      break;

    case 'gatling':
      for (let i = 0; i < w.burstCount; i++)
        ship.burstQueue.push({time: gameTime + i*w.burstDelay, type:'gatling'});
      break;

    case 'boomerang':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {boomerang: true, maxLife: w.life}));
      break;

    case 'doublehelix': {
      const perp = ang + Math.PI/2;
      const helixId = Math.random();
      for (const side of [-1, 1]) {
        const ox = bx + Math.cos(perp)*w.offset*sizeScale*side;
        const oy = by + Math.sin(perp)*w.offset*sizeScale*side;
        bullets.push(makeBullet(ship, ox, oy,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3,
          {sineAmp: 3, sineFreq: 10, helixSide: side, helixId, helixGrow: true}));
      }
      break;
    }

    case 'cyclone': {
      const cId = Math.random();
      for (let i = 0; i < w.projectiles; i++) {
        const orbAng = (i / w.projectiles) * Math.PI * 2;
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3,
          {cyclone: true, cycloneAng: orbAng, cycloneCx: bx, cycloneCy: by,
           cycloneFireAng: ang, cycloneSpeed: wSpd, cycloneId: cId, size: 2,
           cycloneRadiusMult: rand(0.5, 1.5)}));
      }
      // Inner projectiles — stay close to the eye of the storm
      for (let i = 0; i < (w.innerProjectiles || 0); i++) {
        const orbAng = (i / (w.innerProjectiles)) * Math.PI * 2 + rand(0, 1);
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3,
          {cyclone: true, cycloneAng: orbAng, cycloneCx: bx, cycloneCy: by,
           cycloneFireAng: ang, cycloneSpeed: wSpd, cycloneId: cId, size: 2,
           cycloneRadiusMult: rand(0.1, 0.25)}));
      }
      break;
    }

    case 'crossshot': {
      const perp = ang + Math.PI/2;
      const scaledOffset = w.offset * sizeScale;
      const convergeAng = Math.atan2(scaledOffset, w.convergeDist);
      for (const side of [-1, 1]) {
        const ox = bx + Math.cos(perp)*scaledOffset*side;
        const oy = by + Math.sin(perp)*scaledOffset*side;
        const fireAng = ang - convergeAng*side;
        bullets.push(makeBullet(ship, ox, oy,
          Math.cos(fireAng)*wSpd + ship.vx*0.3,
          Math.sin(fireAng)*wSpd + ship.vy*0.3));
      }
      break;
    }

    case 'lightning':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {lightning: true, lightningZigTimer: rand(0.03, 0.06), lightningOrigAng: ang, lightningSplitsLeft: 2}));
      break;

    case 'concussive':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {concussive: true, concussiveTimer: rand(0.3, 1.0) * w.life}));
      break;
  }
  const lowSoundWeapons = ['shotgun', 'scrap'];
  const riseSoundWeapons = ['chaotic', 'snake'];
  if (lowSoundWeapons.includes(w.type)) playShootLow();
  else if (riseSoundWeapons.includes(w.type)) playShootRise();
  else if (w.type === 'sniper') playShootSniper();
  else if (w.type === 'alternating' || w.type === 'crossshot') playShootAlt();
  else if (w.type === 'lightning') playShootSniper();
  else if (w.type === 'concussive') playShootLow();
  else playShoot();
}

function processBurstQueue(ship) {
  while (ship.burstQueue.length > 0 && gameTime >= ship.burstQueue[0].time) {
    const burst = ship.burstQueue.shift();
    const w = ship.weapon;
    const accNoise2 = ship.maneuverActive && ship.maneuver === 'rapidFire' ? rand(-0.15, 0.15) : 0;
    const ang = ship.ang + accNoise2;
    const bx = ship.x + Math.cos(ang)*ship.r*1.2;
    const by = ship.y + Math.sin(ang)*ship.r*1.2;
    const wSpd = w.speed * (ship._spinOutBoostTimer > 0 ? 1.5 : 1);
    switch (burst.type) {
      case 'triple':
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3));
        break;
      case 'flamethrower': {
        const t = burst.idx / burst.total;
        const sOff = Math.sin(t * Math.PI * 4) * (w.amplitude * Math.PI/180);
        const a = ang + sOff;
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(a)*wSpd + ship.vx*0.8,
          Math.sin(a)*wSpd + ship.vy*0.8,
          {life: rand(1.5, 2.5), size: 0.5}));
        break;
      }
      case 'gatling': {
        const sr = (w.spread/2) * Math.PI/180;
        const a = ang + rand(-sr, sr);
        const perp = ang + Math.PI/2;
        const gOffset = rand(-6, 6);
        const gx = bx + Math.cos(perp) * gOffset;
        const gy = by + Math.sin(perp) * gOffset;
        bullets.push(makeBullet(ship, gx, gy,
          Math.cos(a)*wSpd + ship.vx*0.3,
          Math.sin(a)*wSpd + ship.vy*0.3, {size:2}));
        break;
      }
    }
    if (burst.type === 'flamethrower') playShootFlame();
    else playShoot();
  }
}

function detonateBullet(b) {
  if (b.isShrapnel) return;
  if (b.type === 'grenade') {
    // Particles only, no shockwave
    for (let i = 0; i < 12; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(20, 80);
      particles.push({ x:b.x, y:b.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.3,1.2), maxLife:1.2, color:b.color, size:rand(1,3) });
    }
    playAsteroidBreak();
    for (let i = 0; i < 16; i++) {
      const a = (i/16) * Math.PI * 2;
      bullets.push({
        x:b.x, y:b.y, vx:Math.cos(a)*500, vy:Math.sin(a)*500,
        life:0.4, owner:b.owner, color:b.color, damage:2, type:'grenade',
        size:2, isShrapnel:true, contactDetonate:false, detonateTime:null,
        armed:true, armTime:0, fireAng:a, spawnTime:gameTime,
        curveRate:0, sineAmp:0, sineFreq:0,
      });
    }
    // Repulsor effect — push asteroids and enemy bullets away
    const repulsorRadius = 240;
    const repulsorForce = 200;
    for (const ast of asteroids) {
      const d = dist(b, ast);
      if (d < repulsorRadius && d > 0) {
        const pushAng = Math.atan2(ast.y - b.y, ast.x - b.x);
        const strength = 1 - (d / repulsorRadius); // stronger closer
        ast.vx += Math.cos(pushAng) * repulsorForce * strength;
        ast.vy += Math.sin(pushAng) * repulsorForce * strength;
      }
    }
    for (const ob of bullets) {
      if (ob.owner === b.owner || ob.isShrapnel) continue;
      const d = dist(b, ob);
      if (d < repulsorRadius && d > 0) {
        const pushAng = Math.atan2(ob.y - b.y, ob.x - b.x);
        const strength = 1 - (d / repulsorRadius);
        ob.vx += Math.cos(pushAng) * repulsorForce * strength;
        ob.vy += Math.sin(pushAng) * repulsorForce * strength;
      }
    }
    // Repulsor shockwave ring
    shockwaves.push({ x: b.x, y: b.y, r: 0, maxR: 240, life: 0.35, color: b.color });
  } else if (b.type === 'scrap') {
    // Particles only, no shockwave
    for (let i = 0; i < 6; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(15, 50);
      particles.push({ x:b.x, y:b.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.2,0.8), maxLife:0.8, color:b.color, size:rand(1,2.5) });
    }
    playShootLow();
    const baseAng = Math.atan2(b.vy, b.vx);
    const sr = (20/2) * Math.PI/180;
    for (let i = 0; i < 5; i++) {
      const off = (i/4 - 0.5) * 2 * sr;
      const a = baseAng + off;
      bullets.push({
        x:b.x, y:b.y, vx:Math.cos(a)*400, vy:Math.sin(a)*400,
        life:b.life, owner:b.owner, color:b.color, damage:2, type:'scrap',
        size:2, isShrapnel:true, contactDetonate:false, detonateTime:null,
        armed:true, armTime:0, fireAng:a, spawnTime:gameTime,
        curveRate:0, sineAmp:0, sineFreq:0,
      });
    }
  }
}

function detonateMine(mine) {
  // Grenade-style explosion: particles + 16 shrapnel + repulsor push
  for (let i = 0; i < 12; i++) {
    const a = rand(0, Math.PI * 2);
    const sp = rand(20, 80);
    particles.push({ x: mine.x, y: mine.y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
      life: rand(0.3, 1.2), maxLife: 1.2, color: mine.color, size: rand(1, 3) });
  }
  playAsteroidBreak();
  for (let i = 0; i < 16; i++) {
    const a = (i / 16) * Math.PI * 2;
    bullets.push({
      x: mine.x, y: mine.y, vx: Math.cos(a) * 500, vy: Math.sin(a) * 500,
      life: 0.4, owner: mine.ownerId, ownerTeam: mine.ownerTeam || 0, color: mine.color, damage: 2, type: 'grenade',
      size: 2, isShrapnel: true, contactDetonate: false, detonateTime: null,
      armed: true, armTime: 0, fireAng: a, spawnTime: gameTime,
      curveRate: 0, sineAmp: 0, sineFreq: 0,
    });
  }
  // Repulsor push
  const repulsorRadius = 240, repulsorForce = 200;
  for (const ast of asteroids) {
    const d = dist(mine, ast);
    if (d < repulsorRadius && d > 0) {
      const pushAng = Math.atan2(ast.y - mine.y, ast.x - mine.x);
      const strength = 1 - (d / repulsorRadius);
      ast.vx += Math.cos(pushAng) * repulsorForce * strength;
      ast.vy += Math.sin(pushAng) * repulsorForce * strength;
    }
  }
  for (const ob of bullets) {
    if (ob.owner === mine.ownerId || ob.isShrapnel) continue;
    const d = dist(mine, ob);
    if (d < repulsorRadius && d > 0) {
      const pushAng = Math.atan2(ob.y - mine.y, ob.x - mine.x);
      const strength = 1 - (d / repulsorRadius);
      ob.vx += Math.cos(pushAng) * repulsorForce * strength;
      ob.vy += Math.sin(pushAng) * repulsorForce * strength;
    }
  }
  shockwaves.push({ x: mine.x, y: mine.y, r: 0, maxR: 240, life: 0.35, color: mine.color });
}

// Settings state — false = random, true = predetermined
const settings = {
  randomPersonalities: false,
  uniqueShips: false,
  weapons: false,
  randomWeapons: false,
  passives: false,
  maneuvers: false,
  shipHP: 3,
  numShips: 16,
  autoRestart: false,
  chaosMode: false,
  matchLogger: false,
  showWeaponTag: false,
  showPassiveTag: false,
  showManeuverTag: false,
};

function toggleSetting(el) {
  const key = el.dataset.setting;
  settings[key] = !settings[key];
  el.classList.toggle('on', settings[key]);

  const wpnToggle = document.querySelector('[data-setting="weapons"]');
  const rndToggle = document.querySelector('[data-setting="randomWeapons"]');

  // Enabling random weapons → also enable unique weapons
  if (key === 'randomWeapons' && settings.randomWeapons) {
    settings.weapons = true;
    wpnToggle.classList.add('on');
  }
  // Disabling unique weapons → also disable random weapons
  if (key === 'weapons' && !settings.weapons) {
    settings.randomWeapons = false;
    rndToggle.classList.remove('on');
  }
  // Auto-select 3HP when any weapon/passive mode enabled
  if ((key === 'weapons' || key === 'randomWeapons' || key === 'passives') && (settings.weapons || settings.randomWeapons || settings.passives)) {
    settings.shipHP = 3;
    document.querySelectorAll('#hp-selector .hp-btn').forEach(b => {
      b.classList.toggle('active', parseInt(b.dataset.hp) === 3);
    });
  }
  // Re-render team builder when ship appearance changes
  if (key === 'uniqueShips') {
    if (document.getElementById('team-builder').classList.contains('active')) {
      renderTeamBuilder();
    }
  }
}

document.querySelectorAll('#hp-selector .hp-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#hp-selector .hp-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    settings.shipHP = parseInt(btn.dataset.hp);
  });
});

document.querySelectorAll('#ship-count-selector .hp-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#ship-count-selector .hp-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    settings.numShips = parseInt(btn.dataset.ships);
  });
});

document.getElementById('settings-btn').addEventListener('click', () => {
  document.getElementById('settings-panel').classList.toggle('open');
});

// ─── MATCH LOGGER ─────────────────────────────────────────────
let matchLog = [];
try { matchLog = JSON.parse(localStorage.getItem('bbr_matchLog') || '[]'); } catch(e) { matchLog = []; }

function updateLogCount() {
  const el = document.getElementById('log-count');
  const numMatches = matchLog.length > 0 ? matchLog[matchLog.length - 1].match : 0;
  if (el) el.textContent = numMatches + ' match' + (numMatches !== 1 ? 'es' : '') + ' logged';
}
updateLogCount();

function logMatchData() {
  if (!settings.matchLogger) return;

  const ranked = [...ships].sort((a, b) => {
    if (a.alive && !b.alive) return -1;
    if (!a.alive && b.alive) return 1;
    return (b.deathTime || 0) - (a.deathTime || 0);
  });
  ranked.forEach((s, i) => s._logPlace = i + 1);

  const matchNum = matchLog.length + 1;
  const timestamp = new Date().toISOString();
  const winnerName = winner ? winner.name : 'DRAW';
  const matchDuration = gameTime;

  // Capture settings snapshot
  const modeTag = settings.chaosMode ? 'chaos' : settings.randomWeapons ? 'random' : 'default';

  for (const ship of ranked) {
    const survTime = ship.alive ? gameTime : (ship.deathTime || 0);
    const wpnName = ship.weapon?.name || 'Standard Issue';
    const pasKey = ship.passive || 'none';
    const pasName = PASSIVE_DEFS[pasKey]?.name || 'None';
    const manKey = ship.maneuver || 'none';
    const manName = MANEUVER_DEFS[manKey]?.name || 'None';

    matchLog.push({
      match: matchNum,
      timestamp,
      mode: modeTag,
      hp: ship.maxHp,
      numShips: ships.length,
      matchDuration: +matchDuration.toFixed(2),
      winner: winnerName,
      shipName: ship.name,
      shipColor: ship.color,
      placement: ship._logPlace,
      kills: ship.kills,
      weapon: wpnName,
      weaponType: ship.weapon?.type || 'basic',
      passive: pasName,
      passiveKey: pasKey,
      maneuver: manName,
      maneuverKey: manKey,
      maneuverCount: ship.maneuverCount || 0,
      killedBy: ship.alive ? '' : (ship.killedBy || 'UNKNOWN'),
      survivalTime: +survTime.toFixed(2),
      alive: ship.alive,
    });
  }

  try { localStorage.setItem('bbr_matchLog', JSON.stringify(matchLog)); } catch(e) {}
  updateLogCount();
}

function exportMatchLog() {
  if (matchLog.length === 0) { alert('No matches logged yet.'); return; }

  const headers = ['match','timestamp','mode','hp','numShips','matchDuration','winner',
    'shipName','shipColor','placement','kills','weapon','weaponType',
    'passive','passiveKey','maneuver','maneuverKey','maneuverCount',
    'killedBy','survivalTime','alive'];

  let csv = headers.join(',') + '\n';
  for (const row of matchLog) {
    csv += headers.map(h => {
      let v = row[h] ?? '';
      if (typeof v === 'string' && (v.includes(',') || v.includes('"'))) v = '"' + v.replace(/"/g, '""') + '"';
      return v;
    }).join(',') + '\n';
  }

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const dateStr = new Date().toISOString().slice(0, 10);
  const numMatches = matchLog.length > 0 ? matchLog[matchLog.length - 1].match : 0;
  a.download = `bbr-log-${numMatches}matches-${dateStr}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

let clearLogPending = false;
function clearMatchLog() {
  if (matchLog.length === 0) return;
  if (!clearLogPending) {
    clearLogPending = true;
    document.getElementById('log-clear').textContent = 'Confirm?';
    setTimeout(() => { clearLogPending = false; document.getElementById('log-clear').textContent = 'Clear'; }, 3000);
    return;
  }
  clearLogPending = false;
  document.getElementById('log-clear').textContent = 'Clear';
  matchLog = [];
  try { localStorage.setItem('bbr_matchLog', '[]'); } catch(e) {}
  updateLogCount();
}

// ─── GLOBALS ──────────────────────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H;
let ships = [];
let shipById = {};
let asteroids = [];
let bullets = [];
let particles = [];
let shockwaves = [];
let smokeDecoys = [];
let shipClones = [];
let debrisField = [];
let reflectorShields = [];
let mines = [];
let shipDrones = [];
let orphanTrails = [];
let deathGlows = []; // { x, y, color, life, maxLife }
let incBulletCounter = 0;
let incSpentBullets = new Set(); // incendiary bullet IDs that already dealt damage
let gameTime = 0;
let gameOver = false;
let pregame = true;
let countdown = false;
// ─── TEAM BATTLE STATE ──────────────────────────────────────
const MAX_TEAMS = 6;
const TEAM_COLORS = ['#ff5050','#5096ff','#50ff50','#ffcc00','#ff50ff','#50ffff'];
let matchMode = 'ffa'; // 'ffa' or 'teams'
let _starchipSavedLineup = null; // persists across rematches
let teamAssignments = []; // array of arrays of ship indices
let teamNames = [];
let teamWeapons = []; // per-team weapon key selections (empty = use global)
let teamPassives = []; // per-team passive key selections
let teamManeuvers = []; // per-team maneuver key selections
let teamShipDesigns = []; // per-team ship design index selections
let _origTeamSizes = [];
let _teamCoreColors = [];
let teamPalettes = {};
let countdownTimer = 0;
let _lastCountdownSec = -1;
const COUNTDOWN_DURATION = 5;
let winner = null;
let simSpeed = 1;
let finaleMode = false;
let finaleTimer = 0;
let finaleSlowMo = 1;
let finaleDeath = null; // {x, y, color, killerColor, killerName}
let finaleFlash = 0;
let screenShakeX = 0;
let screenShakeY = 0;
let asteroidKills = 0;
let cameraX = CFG.WORLD_W / 2;
let cameraY = CFG.WORLD_H / 2;
let targetCamX = cameraX;
let targetCamY = cameraY;
let camZoom = 0.15;
let targetZoom = 0.15;
let cameraMode = 'overview'; // 'overview' or 'manual'
let manualShips = []; // ship ids tracked in manual mode
let selectBoxStart = null; // {x, y} screen coords
let selectBoxEnd = null; // {x, y} screen coords
let isSelecting = false;
let cameraLinger = 0; // seconds to hold position after a fight ends
let cameraTransitioning = false; // true when pulling away from a fight

// ─── AUDIO ─────────────────────────────────────────────────────
let audioCtx = null;
let masterGain = null;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);
  masterGain.gain.value = 0.4;
}

function ensureAudio() {
  if (!audioCtx) initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

// Volume scales with zoom: zoomed in = loud, zoomed out = quiet
function getZoomVolume() {
  if (!audioCtx) return 0;
  return Math.max(0.03, Math.min(1.0, camZoom * 0.7));
}

// Throttle sounds to avoid overload
let lastShootTime = 0;
let lastAsteroidTime = 0;

function playShoot() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootTime < 0.04) return; // max ~25 shots/sec
  lastShootTime = t;
  const vol = getZoomVolume() * 0.06;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(800, t);
  osc.frequency.exponentialRampToValueAtTime(200, t + 0.08);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
  osc.start(t);
  osc.stop(t + 0.08);
}

let lastShootLowTime = 0;
function playShootLow() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootLowTime < 0.04) return;
  lastShootLowTime = t;
  const vol = getZoomVolume() * 0.08;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(400, t);
  osc.frequency.exponentialRampToValueAtTime(120, t + 0.1);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  osc.start(t);
  osc.stop(t + 0.1);
}

let lastShootRiseTime = 0;
function playShootRise() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootRiseTime < 0.04) return;
  lastShootRiseTime = t;
  const vol = getZoomVolume() * 0.06;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(150, t);
  osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
  osc.start(t);
  osc.stop(t + 0.12);
}

let lastShootAltTime = 0;
function playShootAlt() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootAltTime < 0.04) return;
  lastShootAltTime = t;
  const vol = getZoomVolume() * 0.045;
  // Two detuned oscillators sweeping down for TIE-fighter zap
  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc1.connect(gain);
  osc2.connect(gain);
  gain.connect(masterGain);
  osc1.type = 'sawtooth';
  osc2.type = 'square';
  // Fast sweep down with second osc slightly offset for beating
  osc1.frequency.setValueAtTime(900, t);
  osc1.frequency.exponentialRampToValueAtTime(120, t + 0.08);
  osc2.frequency.setValueAtTime(950, t);
  osc2.frequency.exponentialRampToValueAtTime(130, t + 0.08);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.setValueAtTime(vol * 0.3, t + 0.025);
  gain.gain.setValueAtTime(vol * 0.9, t + 0.04);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.09);
  osc1.start(t);
  osc2.start(t);
  osc1.stop(t + 0.09);
  osc2.stop(t + 0.09);
}

let lastShootFlameTime = 0;
function playShootFlame() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootFlameTime < 0.04) return;
  lastShootFlameTime = t;
  const vol = getZoomVolume() * 0.025;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(300, t);
  osc.frequency.exponentialRampToValueAtTime(100, t + 0.08);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
  osc.start(t);
  osc.stop(t + 0.08);
}

let lastShootSniperTime = 0;
function playShootSniper() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootSniperTime < 0.04) return;
  lastShootSniperTime = t;
  const vol = getZoomVolume() * 0.1;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(1200, t);
  osc.frequency.exponentialRampToValueAtTime(400, t + 0.1);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  osc.start(t);
  osc.stop(t + 0.1);
}

function playAsteroidBreak() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastAsteroidTime < 0.05) return;
  lastAsteroidTime = t;
  const vol = getZoomVolume() * 0.125;
  // Noise burst via oscillator detune trick
  const osc = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  osc2.connect(gain);
  gain.connect(masterGain);
  osc.type = 'sawtooth';
  osc2.type = 'square';
  osc.frequency.setValueAtTime(150, t);
  osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
  osc2.frequency.setValueAtTime(90, t);
  osc2.frequency.exponentialRampToValueAtTime(20, t + 0.15);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
  osc.start(t);
  osc2.start(t);
  osc.stop(t + 0.2);
  osc2.stop(t + 0.2);
}

// Quiet asteroid break for tournament bracket elimination
function playTourneyEliminate() {
  ensureAudio();
  const t = audioCtx.currentTime;
  const vol = 0.08;
  const osc = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  osc2.connect(gain);
  gain.connect(masterGain);
  osc.type = 'sawtooth';
  osc2.type = 'square';
  osc.frequency.setValueAtTime(150, t);
  osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
  osc2.frequency.setValueAtTime(90, t);
  osc2.frequency.exponentialRampToValueAtTime(20, t + 0.15);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
  osc.start(t);
  osc2.start(t);
  osc.stop(t + 0.2);
  osc2.stop(t + 0.2);
}

function playShipHit() {
  ensureAudio();
  const vol = getZoomVolume() * 0.3;
  const t = audioCtx.currentTime;
  // Crunchy impact
  const osc = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  osc2.connect(gain);
  gain.connect(masterGain);
  osc.type = 'sawtooth';
  osc2.type = 'triangle';
  osc.frequency.setValueAtTime(300, t);
  osc.frequency.exponentialRampToValueAtTime(60, t + 0.12);
  osc2.frequency.setValueAtTime(180, t);
  osc2.frequency.exponentialRampToValueAtTime(30, t + 0.15);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
  osc.start(t);
  osc2.start(t);
  osc.stop(t + 0.15);
  osc2.stop(t + 0.15);
}

function playExplosion() {
  ensureAudio();
  const vol = getZoomVolume() * 0.4;
  const t = audioCtx.currentTime;
  // Classic arcade descending "bwaaaa-pop" 
  // High pitched descending whistle
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  osc1.connect(gain1);
  gain1.connect(masterGain);
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(1200, t);
  osc1.frequency.exponentialRampToValueAtTime(80, t + 0.35);
  gain1.gain.setValueAtTime(vol * 0.6, t);
  gain1.gain.linearRampToValueAtTime(vol * 0.3, t + 0.1);
  gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
  osc1.start(t);
  osc1.stop(t + 0.4);
  // Crunchy "pop" burst
  const osc2 = audioCtx.createOscillator();
  const gain2 = audioCtx.createGain();
  osc2.connect(gain2);
  gain2.connect(masterGain);
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(600, t);
  osc2.frequency.exponentialRampToValueAtTime(40, t + 0.2);
  gain2.gain.setValueAtTime(vol * 0.5, t);
  gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
  osc2.start(t);
  osc2.stop(t + 0.25);
  // Wobbly ring-out
  const osc3 = audioCtx.createOscillator();
  const gain3 = audioCtx.createGain();
  osc3.connect(gain3);
  gain3.connect(masterGain);
  osc3.type = 'triangle';
  osc3.frequency.setValueAtTime(300, t + 0.05);
  osc3.frequency.setValueAtTime(350, t + 0.1);
  osc3.frequency.setValueAtTime(200, t + 0.15);
  osc3.frequency.setValueAtTime(250, t + 0.2);
  osc3.frequency.exponentialRampToValueAtTime(60, t + 0.5);
  gain3.gain.setValueAtTime(0.001, t);
  gain3.gain.linearRampToValueAtTime(vol * 0.35, t + 0.05);
  gain3.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
  osc3.start(t);
  osc3.stop(t + 0.5);
}

function playFinaleExplosion() {
  ensureAudio();
  const t = audioCtx.currentTime;
  const vol = 0.6;
  // Big dramatic descending sweep
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  osc1.connect(gain1);
  gain1.connect(masterGain);
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(1800, t);
  osc1.frequency.exponentialRampToValueAtTime(30, t + 0.8);
  gain1.gain.setValueAtTime(vol * 0.7, t);
  gain1.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
  osc1.start(t);
  osc1.stop(t + 1.0);
  // Chunky square crunch
  const osc2 = audioCtx.createOscillator();
  const gain2 = audioCtx.createGain();
  osc2.connect(gain2);
  gain2.connect(masterGain);
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(800, t);
  osc2.frequency.exponentialRampToValueAtTime(25, t + 0.5);
  gain2.gain.setValueAtTime(vol * 0.5, t);
  gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
  osc2.start(t);
  osc2.stop(t + 0.6);
  // Wobble ring-out — longer, more dramatic
  const osc3 = audioCtx.createOscillator();
  const gain3 = audioCtx.createGain();
  osc3.connect(gain3);
  gain3.connect(masterGain);
  osc3.type = 'triangle';
  osc3.frequency.setValueAtTime(500, t + 0.05);
  osc3.frequency.setValueAtTime(400, t + 0.12);
  osc3.frequency.setValueAtTime(300, t + 0.2);
  osc3.frequency.setValueAtTime(350, t + 0.3);
  osc3.frequency.setValueAtTime(200, t + 0.4);
  osc3.frequency.exponentialRampToValueAtTime(40, t + 1.2);
  gain3.gain.setValueAtTime(0.001, t);
  gain3.gain.linearRampToValueAtTime(vol * 0.4, t + 0.08);
  gain3.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
  osc3.start(t);
  osc3.stop(t + 1.2);
  // Sub bass thud
  const osc4 = audioCtx.createOscillator();
  const gain4 = audioCtx.createGain();
  osc4.connect(gain4);
  gain4.connect(masterGain);
  osc4.type = 'sine';
  osc4.frequency.setValueAtTime(60, t);
  osc4.frequency.exponentialRampToValueAtTime(15, t + 0.8);
  gain4.gain.setValueAtTime(vol * 0.8, t);
  gain4.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
  osc4.start(t);
  osc4.stop(t + 1.0);
}

function playDebuff() {
  ensureAudio();
  const vol = getZoomVolume() * 0.02;
  const t = audioCtx.currentTime;
  // Pixelated descending square wave "pwshh"
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(280, t);
  osc.frequency.setValueAtTime(220, t + 0.04);
  osc.frequency.setValueAtTime(160, t + 0.08);
  osc.frequency.setValueAtTime(110, t + 0.14);
  osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
  gain.gain.setValueAtTime(vol * 0.4, t);
  gain.gain.linearRampToValueAtTime(vol * 0.25, t + 0.1);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
  osc.start(t);
  osc.stop(t + 0.35);
  // Low noise burst for the "shh" texture
  const bufLen = Math.floor(audioCtx.sampleRate * 0.25);
  const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufLen; i++) data[i] = Math.random() * 2 - 1;
  const noise = audioCtx.createBufferSource();
  noise.buffer = buf;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.setValueAtTime(800, t);
  filter.frequency.exponentialRampToValueAtTime(150, t + 0.25);
  const nGain = audioCtx.createGain();
  nGain.gain.setValueAtTime(vol * 0.2, t + 0.03);
  nGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
  noise.connect(filter);
  filter.connect(nGain);
  nGain.connect(masterGain);
  noise.start(t + 0.03);
  noise.stop(t + 0.3);
}

// Countdown tick — Arcade Blip: short square wave bip, final tick pitches up
function playCountdownTick(secsLeft) {
  ensureAudio();
  const t = audioCtx.currentTime;
  const freq = 440;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain); gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(freq, t);
  gain.gain.setValueAtTime(0.25, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
  osc.start(t); osc.stop(t + 0.2);
}

// Match start — Warp Pipe: descending wobble into upward pop (half volume)
function playMatchStart() {
  ensureAudio();
  const t = audioCtx.currentTime;
  const vol = 0.5;
  // Descending wobble
  const o1 = audioCtx.createOscillator();
  const g1 = audioCtx.createGain();
  o1.connect(g1); g1.connect(masterGain);
  o1.type = 'square';
  o1.frequency.setValueAtTime(600, t);
  o1.frequency.setValueAtTime(500, t + 0.03);
  o1.frequency.setValueAtTime(400, t + 0.06);
  o1.frequency.setValueAtTime(300, t + 0.09);
  o1.frequency.setValueAtTime(200, t + 0.12);
  g1.gain.setValueAtTime(0.18 * vol, t);
  g1.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
  o1.start(t); o1.stop(t + 0.2);
  // Pop up
  const o2 = audioCtx.createOscillator();
  const g2 = audioCtx.createGain();
  o2.connect(g2); g2.connect(masterGain);
  o2.type = 'square';
  o2.frequency.setValueAtTime(300, t + 0.16);
  o2.frequency.linearRampToValueAtTime(1200, t + 0.22);
  g2.gain.setValueAtTime(0.2 * vol, t + 0.16);
  g2.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
  o2.start(t + 0.16); o2.stop(t + 0.23);
  // Ring
  const o3 = audioCtx.createOscillator();
  const g3 = audioCtx.createGain();
  o3.connect(g3); g3.connect(masterGain);
  o3.type = 'triangle';
  o3.frequency.setValueAtTime(1200, t + 0.22);
  g3.gain.setValueAtTime(0.12 * vol, t + 0.22);
  g3.gain.exponentialRampToValueAtTime(0.001, t + 0.37);
  o3.start(t + 0.22); o3.stop(t + 0.38);
}

// ─── RESIZE ───────────────────────────────────────────────────
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// ─── UTILS ────────────────────────────────────────────────────
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
function angle(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function wrap(v, max) { return ((v % max) + max) % max; }

// Friendly fire damage multiplier: 0 for first 5s, ramps 0→1 over 5-12s, full after 12s
function friendlyFireMult() {
  if (gameTime < 5) return 0;
  if (gameTime >= 12) return 1;
  return (gameTime - 5) / 7; // linear ramp over 7 seconds
}
function lerp(a, b, t) { return a + (b - a) * t; }
// Reflect bullet velocity off a surface normal (nx, ny must be unit vector)
function bounceBullet(b, nx, ny, noFx) {
  const dot = b.vx * nx + b.vy * ny;
  b.vx -= 2 * dot * nx;
  b.vy -= 2 * dot * ny;
  // Nudge bullet away from surface to prevent re-collision
  b.x += nx * 6;
  b.y += ny * 6;
  b._bounceTime = gameTime;
  if (!noFx) spawnExplosion(b.x, b.y, b.color, 4, 40);
}
function shortAngleDist(a, b) {
  const d = ((b - a) % (Math.PI*2) + Math.PI*3) % (Math.PI*2) - Math.PI;
  return d;
}
// Random behavior with bloodthirsty as rare (~8% chance)
function randomBehavior() {
  if (Math.random() < 0.08) return 'bloodthirsty';
  return ['aggressive', 'cautious', 'hunter', 'evasive'][randInt(0, 3)];
}

// ─── SHIP SHAPES ──────────────────────────────────────────────
// ─── CUSTOM SHIP SHAPES ──────────────────────────────────────
const SHIP_SHAPES = [
  // RED
  [[-.1,-.15],[-.45,-.4],[-.2,-.4],[0,-.5],[-.2,-.65],[-.7,-.65],[-.7,-.4],[-.4,0],[-.75,.4],[-.75,.6],[-.5,.6],[-.2,.6],[0,.5],[-.2,.4],[-.45,.4],[-.1,.15],[.45,.2],[.6,.15],[.65,.1],[.75,.1],[.925,0],[.75,-.1],[.65,-.1],[.6,-.15],[.45,-.2]],
  // GREEN
  [[-1,0],[-.7,-.1],[-.75,-.4],[-.4,-.85],[-.25,-.7],[-.3,-.15],[0,-.5],[.3,-.25],[.2,0],[.5,-.15],[1,0],[.2,.45],[-.15,.25],[-.25,.65],[-.4,.8],[-.7,.45],[-.7,.1]],
  // BLUE
  [[1,0],[.75,-.2],[-.15,-1],[-.05,-.4],[-.35,-.25],[-.55,0],[-.35,.25],[-.05,.45],[-.15,1],[.75,.2]],
  // ORANGE
  [[1,0],[-.8,-.7],[-.65,-.2],[.1,0],[-.65,.2],[-.8,.7]],
  // PINK
  [[-.7,-.65],[-.5,-.75],[.15,-.55],[1,0],[.15,.55],[-.5,.75],[-.7,.65],[-.75,.35],[-.5,.1],[-.35,0],[-.5,-.1],[-.75,-.4]],
  // CYAN
  [[-.15,-.65],[-.8,-.65],[-.4,0],[-.8,.65],[-.2,.6],[-.45,.4],[1,0],[-.45,-.45]],
  // LIME
  [[.7,-.55],[.3,-1],[-.75,-.7],[-.85,-.2],[-.5,0],[-.85,.25],[-.7,.75],[.4,.95],[.65,.55],[.25,.7],[-.35,.5],[.2,.3],[1.1,0],[.2,-.25],[-.35,-.55],[.2,-.7]],
  // CORAL
  [[.55,-.25],[.1,-.65],[.1,-.2],[-.65,-.9],[-.45,-.1],[-1,0],[-.45,.15],[-.65,.9],[.1,.15],[.1,.6],[.55,.2],[.6,.5],[1,0],[.6,-.6]],
  // PURPLE
  [[-.75,-.8],[.1,-.5],[-.85,-.2],[.2,0],[-.85,.25],[.1,.55],[-.75,.8],[.1,.75],[.6,.3],[1,0],[.6,-.3],[.1,-.7]],
  // WHITE
  [[1,0],[-.7,-.65],[-.4,0],[-.7,.65]],
  // YELLOW
  [[1.2,0],[-.4,-.55],[-.6,-.45],[-.7,-.65],[-.2,-.2],[-.2,-.1],[-.85,0],[-.25,.05],[-.25,.2],[-.55,.4],[-.45,.65],[-.7,.65],[0,.3],[.15,-.05],[.25,.2],[.55,-.05],[.75,.25],[.85,.05]],
  // MAGENTA
  [[.95,0],[-.9,-.7],[-.5,0],[-.9,.65],[.05,.3],[-.4,-.3],[.3,.15],[.15,-.2],[.6,.1]],
  // SKY
  [[.25,-.15],[.5,-.25],[1,0],[.5,.25],[.25,.15],[0,.25],[.2,.45],[.35,.75],[.1,.95],[-.5,.95],[0,.7],[-.25,.6],[-.1,.5],[-.4,.25],[-.6,.25],[-1.05,.35],[-1,0],[-1.05,-.4],[-.6,-.25],[-.4,-.25],[-.25,-.35],[-.05,-.5],[-.25,-.6],[0,-.7],[-.5,-.95],[.1,-.95],[.35,-.75],[.2,-.45],[0,-.25]],
  // GOLD
  [[.99,0],[-.5,.85],[-.69,.55],[-.5,.35],[-.79,.4],[-.99,0],[-.79,-.4],[-.45,-.3],[-.69,-.55],[-.5,-.84]],
  // SILVER
  [[.85,-.5],[.75,-.65],[.5,-.85],[.25,-.95],[0,-1],[-.25,-.95],[-.5,-.85],[-.75,-.65],[-.85,-.5],[-1,0],[-.85,.5],[-.65,.75],[-.25,.95],[0,1],[.25,.95],[.55,.85],[.85,.55],[-.25,.65],[-.2,.25],[-.3,.1],[.25,0],[-.3,-.1],[-.2,-.25],[-.25,-.6]],
  // VIOLET
  [[.35,-.3],[.3,-.5],[-.25,-.95],[-.5,-.85],[-.1,-.3],[-.3,-.2],[-1,-.35],[-.8,-.1],[-.1,0],[-.1,0],[-.8,.1],[-1,.35],[-.3,.2],[-.1,.3],[-.5,.85],[-.25,.95],[.3,.5],[.35,.3],[.95,.2],[1.05,0],[.95,-.2]],
];

const DEFAULT_SHIP_SHAPE = 9; // White's chevron
function getShipVerts(shipId, forceUnique) {
  if (forceUnique || settings.uniqueShips) return SHIP_SHAPES[shipId] || SHIP_SHAPES[DEFAULT_SHIP_SHAPE];
  return SHIP_SHAPES[DEFAULT_SHIP_SHAPE];
}

// Create an SVG ship icon that stays crisp at any zoom
function createShipIconSVG(shipId, color, size, forceUnique) {
  const ns = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(ns, 'svg');
  svg.setAttribute('width', size);
  svg.setAttribute('height', size);
  svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
  svg.style.flexShrink = '0';
  svg.style.display = 'block';
  const verts = getShipVerts(shipId, forceUnique !== false);
  const r = size * 0.38;
  const cx = size / 2, cy = size / 2;
  const points = verts.map(v => `${cx + v[0] * r},${cy + v[1] * r}`).join(' ');

  // Glow filter
  const defs = document.createElementNS(ns, 'defs');
  const filterId = 'glow-' + shipId + '-' + Math.random().toString(36).slice(2, 6);
  const filter = document.createElementNS(ns, 'filter');
  filter.setAttribute('id', filterId);
  filter.setAttribute('x', '-50%'); filter.setAttribute('y', '-50%');
  filter.setAttribute('width', '200%'); filter.setAttribute('height', '200%');
  const blur = document.createElementNS(ns, 'feGaussianBlur');
  blur.setAttribute('stdDeviation', (size * 0.08).toString());
  blur.setAttribute('result', 'glow');
  filter.appendChild(blur);
  const merge = document.createElementNS(ns, 'feMerge');
  const mn1 = document.createElementNS(ns, 'feMergeNode');
  mn1.setAttribute('in', 'glow');
  const mn2 = document.createElementNS(ns, 'feMergeNode');
  mn2.setAttribute('in', 'SourceGraphic');
  merge.appendChild(mn1); merge.appendChild(mn2);
  filter.appendChild(merge);
  defs.appendChild(filter);
  svg.appendChild(defs);

  // Fill polygon
  const fill = document.createElementNS(ns, 'polygon');
  fill.setAttribute('points', points);
  fill.setAttribute('fill', color + '33');
  fill.setAttribute('stroke', 'none');
  svg.appendChild(fill);

  // Stroke polygon with glow
  const stroke = document.createElementNS(ns, 'polygon');
  stroke.setAttribute('points', points);
  stroke.setAttribute('fill', 'none');
  stroke.setAttribute('stroke', color);
  stroke.setAttribute('stroke-width', Math.max(1, size * 0.08).toString());
  stroke.setAttribute('stroke-linejoin', 'round');
  stroke.setAttribute('filter', `url(#${filterId})`);
  svg.appendChild(stroke);

  return svg;
}

// Create a small canvas with a ship sprite for UI elements
function createShipIcon(shipId, color, size, forceUnique) {
  const c = document.createElement('canvas');
  c.width = size;
  c.height = size;
  c.className = 'ship-icon';
  const ctx = c.getContext('2d');
  const verts = getShipVerts(shipId, forceUnique !== false);
  const r = size * 0.38;
  ctx.save();
  ctx.translate(size / 2, size / 2);
  ctx.shadowColor = color;
  ctx.shadowBlur = size * 0.2;
  ctx.strokeStyle = color;
  ctx.lineWidth = Math.max(1, size * 0.08);
  ctx.fillStyle = color + '33';
  ctx.beginPath();
  ctx.moveTo(verts[0][0] * r, verts[0][1] * r);
  for (let i = 1; i < verts.length; i++) {
    ctx.lineTo(verts[i][0] * r, verts[i][1] * r);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
  return c;
}

function drawShipShape(ctx, x, y, ang, r, color, hp, maxHp, invuln, shipId, hpBarTimer, forceUnique) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(ang);

  if (invuln && isFinite(invuln)) {
    ctx.globalAlpha = 0.3 + 0.3 * Math.sin(gameTime * 15);
  }

  // Thruster glow
  ctx.shadowColor = color;
  ctx.shadowBlur = 20;

  const verts = getShipVerts(shipId, forceUnique);

  ctx.strokeStyle = color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(verts[0][0] * r, verts[0][1] * r);
  for (let i = 1; i < verts.length; i++) {
    ctx.lineTo(verts[i][0] * r, verts[i][1] * r);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = color + '22';
  ctx.fill();

  // HP bar — only show when hit (fades after 1.5s)
  if (maxHp > 1 && hpBarTimer > 0) {
    const barAlpha = Math.min(1, hpBarTimer / 0.4); // fade out over last 0.4s
    ctx.rotate(-ang); // un-rotate so bar is always horizontal
    const barW = r * 2.2;
    const barH = 3;
    const barY = -r - 8;
    // Background
    ctx.fillStyle = `rgba(255,255,255,${0.15 * barAlpha})`;
    ctx.fillRect(-barW/2, barY, barW, barH);
    // Fill
    const pct = hp / maxHp;
    const barColor = pct > 1 ? '#ffffff' : pct > 0.5 ? color : pct > 0.25 ? '#ffaa22' : '#ff4444';
    ctx.globalAlpha = (invuln && isFinite(invuln)) ? (0.3 + 0.3 * Math.sin(gameTime * 15)) * barAlpha : barAlpha;
    ctx.fillStyle = barColor;
    ctx.fillRect(-barW/2, barY, barW * Math.min(pct, 1), barH);
  }

  ctx.restore();
}

// ─── ASTEROID SHAPE ───────────────────────────────────────────
function makeAsteroidVerts(r) {
  const n = r > 100 ? randInt(14, 20) : randInt(7, 12);
  const verts = [];
  for (let i = 0; i < n; i++) {
    const a = (i / n) * Math.PI * 2;
    const d = r * rand(0.7, 1.0);
    verts.push({ x: Math.cos(a) * d, y: Math.sin(a) * d });
  }
  return verts;
}

// ─── SPAWN ASTEROID ───────────────────────────────────────────
function spawnAsteroid(sizeIdx, x, y) {
  const r = CFG.ASTEROID_SIZES[sizeIdx || 0];
  const a = rand(0, Math.PI * 2);
  // Mega asteroids drift slowly, others normal speed
  const speedMult = sizeIdx === 0 ? 0.3 : 1;
  const sp = rand(CFG.ASTEROID_SPEED_MIN, CFG.ASTEROID_SPEED_MAX) * speedMult;
  return {
    x: x ?? rand(0, CFG.WORLD_W),
    y: y ?? rand(0, CFG.WORLD_H),
    vx: Math.cos(a) * sp,
    vy: Math.sin(a) * sp,
    r: r,
    sizeIdx: sizeIdx || 0,
    rot: 0,
    rotSpeed: rand(-2, 2) * (sizeIdx === 0 ? 0.3 : 1),
    verts: makeAsteroidVerts(r),
  };
}

// ─── INIT ─────────────────────────────────────────────────────
function applyChaosMode() {
  if (!settings.chaosMode) return;

  const shipOptions = [4, 6, 8, 10, 12, 14, 16];

  // 20% chance of a fully default match
  if (Math.random() < 0.2) {
    settings.randomPersonalities = false;
    settings.weapons = true;
    settings.randomWeapons = false;
    settings.passives = true;
    settings.maneuvers = true;
    settings.numShips = 16;
    settings.uniqueShips = true;
  } else {
    settings.randomPersonalities = Math.random() < 0.5;
    settings.uniqueShips = Math.random() < 0.5;
    // Weapon modes: 40% unique, 30% random, 30% basic
    const wpnRoll = Math.random();
    if (wpnRoll < 0.4) {
      settings.weapons = true;
      settings.randomWeapons = false;
    } else if (wpnRoll < 0.7) {
      settings.weapons = true;
      settings.randomWeapons = true;
    } else {
      settings.weapons = false;
      settings.randomWeapons = false;
    }
    settings.numShips = shipOptions[randInt(0, shipOptions.length - 1)];
    settings.passives = Math.random() < 0.6;
    settings.maneuvers = Math.random() < 0.4;
  }

  // Sync UI toggles
  document.querySelector('[data-setting="randomPersonalities"]').classList.toggle('on', settings.randomPersonalities);
  document.querySelector('[data-setting="uniqueShips"]').classList.toggle('on', settings.uniqueShips);
  document.querySelector('[data-setting="weapons"]').classList.toggle('on', settings.weapons);
  document.querySelector('[data-setting="randomWeapons"]').classList.toggle('on', settings.randomWeapons);
  document.querySelector('[data-setting="passives"]').classList.toggle('on', settings.passives);
  document.querySelector('[data-setting="maneuvers"]').classList.toggle('on', settings.maneuvers);

  // Sync ship count buttons
  document.querySelectorAll('#ship-count-selector .hp-btn').forEach(b => {
    b.classList.toggle('active', parseInt(b.dataset.ships) === settings.numShips);
  });
}

function init() {
  ships = [];
  shipById = {};
  asteroids = [];
  bullets = [];
  particles = [];
  shockwaves = [];
  smokeDecoys = [];
  shipClones = [];
  debrisField = [];
  reflectorShields = [];
  mines = [];
  shipDrones = [];
  orphanTrails = [];
  deathGlows = [];
  incBulletCounter = 0;
  incSpentBullets.clear();
  gameTime = 0;
  gameOver = false;
  winner = null;
  finaleMode = false;
  finaleTimer = 0;
  finaleSlowMo = 1;
  finaleDeath = null;
  finaleFlash = 0;
  screenShakeX = 0;
  screenShakeY = 0;
  asteroidKills = 0;
  document.getElementById('settings-panel').classList.remove('open');

  // Spawn layout system — randomly selects a formation and adds jitter
  const cx = CFG.WORLD_W / 2;
  const cy = CFG.WORLD_H / 2;

  function generateSpawnPositions() {
    const numShips = settings.numShips;
    const positions = [];
    // Slight offset for the whole formation so it's not dead center every time
    const fmtOffX = rand(-800, 800);
    const fmtOffY = rand(-500, 500);
    const fcx = cx + fmtOffX;
    const fcy = cy + fmtOffY;
    const jitter = rand(120, 360);

    const type = randInt(0, 7);

    if (type === 0) {
      // STANDARD 4×3 grid
      const spacingX = rand(1000, 1800);
      const spacingY = rand(800, 1400);
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 4; col++) {
          positions.push({
            x: fcx + (col - 1.5) * spacingX + rand(-jitter, jitter),
            y: fcy + (row - 1) * spacingY + rand(-jitter, jitter)
          });
        }
      }
    } else if (type === 1) {
      // STAGGERED 4×3 — alternating rows offset by half a column
      const spacingX = rand(1000, 1800);
      const spacingY = rand(800, 1400);
      for (let row = 0; row < 3; row++) {
        const stagger = (row % 2 === 1) ? spacingX * 0.5 : 0;
        for (let col = 0; col < 4; col++) {
          positions.push({
            x: fcx + (col - 1.5) * spacingX + stagger + rand(-jitter, jitter),
            y: fcy + (row - 1) * spacingY + rand(-jitter, jitter)
          });
        }
      }
    } else if (type === 2) {
      // TALL 3×4 grid
      const spacingX = rand(2400, 4000);
      const spacingY = rand(1400, 2400);
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 3; col++) {
          positions.push({
            x: fcx + (col - 1) * spacingX + rand(-jitter, jitter),
            y: fcy + (row - 1.5) * spacingY + rand(-jitter, jitter)
          });
        }
      }
    } else if (type === 3) {
      // DIAMOND — 3-4-3-2 rows centered
      const spacingX = rand(2000, 3400);
      const spacingY = rand(1600, 2600);
      const rowCounts = [3, 4, 3, 2];
      for (let row = 0; row < rowCounts.length; row++) {
        const cols = rowCounts[row];
        for (let col = 0; col < cols; col++) {
          positions.push({
            x: fcx + (col - (cols - 1) / 2) * spacingX + rand(-jitter, jitter),
            y: fcy + (row - 1.5) * spacingY + rand(-jitter, jitter)
          });
        }
      }
    } else if (type === 4) {
      // ARROW — 1-2-3-4-2 pointing in a random direction
      const spacingX = rand(1800, 3000);
      const spacingY = rand(1600, 2600);
      const rowCounts = [1, 2, 3, 4, 2];
      const rotation = rand(0, Math.PI * 2);
      const cos = Math.cos(rotation), sin = Math.sin(rotation);
      for (let row = 0; row < rowCounts.length; row++) {
        const cols = rowCounts[row];
        for (let col = 0; col < cols; col++) {
          const lx = (col - (cols - 1) / 2) * spacingX;
          const ly = (row - 2) * spacingY;
          positions.push({
            x: fcx + lx * cos - ly * sin + rand(-jitter, jitter),
            y: fcy + lx * sin + ly * cos + rand(-jitter, jitter)
          });
        }
      }
    } else if (type === 5) {
      // COMPACT RING — small circle, everyone close
      const radius = rand(2000, 3600);
      const rotOff = rand(0, Math.PI * 2);
      for (let i = 0; i < numShips; i++) {
        const a = (i / numShips) * Math.PI * 2 + rotOff;
        positions.push({
          x: fcx + Math.cos(a) * radius + rand(-jitter, jitter),
          y: fcy + Math.sin(a) * radius + rand(-jitter, jitter)
        });
      }
    } else if (type === 6) {
      // TIGHT SCATTER — random but constrained to a small area
      const scatterW = rand(2400, 4000);
      const scatterH = rand(1800, 3000);
      for (let i = 0; i < numShips; i++) {
        positions.push({
          x: fcx + rand(-scatterW / 2, scatterW / 2),
          y: fcy + rand(-scatterH / 2, scatterH / 2)
        });
      }
    } else {
      // STAGGERED 4×3 with wide variance — loose grid feel
      const spacingX = rand(1200, 2000);
      const spacingY = rand(1000, 1600);
      const bigJitter = rand(300, 600);
      for (let row = 0; row < 3; row++) {
        const stagger = (row % 2 === 1) ? spacingX * rand(0.3, 0.6) : 0;
        for (let col = 0; col < 4; col++) {
          positions.push({
            x: fcx + (col - 1.5) * spacingX + stagger + rand(-bigJitter, bigJitter),
            y: fcy + (row - 1) * spacingY + rand(-bigJitter, bigJitter)
          });
        }
      }
    }

    // If formation produced fewer than needed, add extras scattered around center
    while (positions.length < numShips) {
      const a = rand(0, Math.PI * 2);
      const r = rand(1500, 3500);
      positions.push({
        x: fcx + Math.cos(a) * r + rand(-jitter, jitter),
        y: fcy + Math.sin(a) * r + rand(-jitter, jitter)
      });
    }

    // Soft push positions away from borders (15% margin) — avoids hard boxy edges
    const marginX = CFG.WORLD_W * 0.15;
    const marginY = CFG.WORLD_H * 0.15;
    for (const p of positions) {
      if (p.x < marginX) p.x = marginX + rand(0, 200);
      if (p.x > CFG.WORLD_W - marginX) p.x = CFG.WORLD_W - marginX - rand(0, 200);
      if (p.y < marginY) p.y = marginY + rand(0, 200);
      if (p.y > CFG.WORLD_H - marginY) p.y = CFG.WORLD_H - marginY - rand(0, 200);
    }

    // Truncate to requested ship count (grid formations may generate more)
    while (positions.length > numShips) positions.pop();

    return { positions, center: { x: fcx, y: fcy } };
  }

  const spawn = generateSpawnPositions();
  const spawnPositions = spawn.positions;
  const spawnCenter = spawn.center;

  // Shuffle positions so ship assignment is random
  for (let i = spawnPositions.length - 1; i > 0; i--) {
    const j = randInt(0, i);
    [spawnPositions[i], spawnPositions[j]] = [spawnPositions[j], spawnPositions[i]];
  }

  // Pick which ships participate
  let activeShips;
  if (matchMode === 'teams') {
    // Use exactly the ships assigned to teams
    activeShips = teamAssignments.flat();
  } else {
    // FFA: randomized selection
    const allIndices = Array.from({length: PILOT_NAMES.length}, (_, i) => i);
    for (let i = allIndices.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];
    }
    activeShips = allIndices.slice(0, settings.numShips).sort((a, b) => a - b);
  }
  let drillboreTaken = false;

  // Build position→team lookup for loadout selection (handles duplicate ship types)
  const _posTeamLookup = [];
  if (matchMode === 'teams') {
    for (let t = 0; t < teamAssignments.length; t++) {
      for (const idx of teamAssignments[t]) _posTeamLookup.push(t + 1);
    }
  }

  for (let si = 0; si < activeShips.length; si++) {
    const i = activeShips[si];
    const sp = spawnPositions[si];
    const _teamNum = _posTeamLookup[si] || 0;
    // Ship design override: if team has designs selected, use one from pool
    let _designType = i;
    if (_teamNum > 0 && teamShipDesigns[_teamNum - 1] && teamShipDesigns[_teamNum - 1].length > 0) {
      const pool = teamShipDesigns[_teamNum - 1];
      _designType = parseInt(pool[randInt(0, pool.length - 1)]);
    }
    // Face toward center of formation
    const faceAng = Math.atan2(spawnCenter.y - sp.y, spawnCenter.x - sp.x);
    ships.push({
      id: si,          // unique per instance
      shipType: _designType, // ship design (may be overridden by team design pool)
      _designForced: _designType !== i, // true if design was overridden by team pool
      name: PILOT_NAMES[i],
      color: PILOT_COLORS[i],
      x: sp.x,
      y: sp.y,
      vx: 0, vy: 0,
      ang: faceAng, // face center of formation
      r: CFG.SHIP_RADIUS,
      hp: settings.shipHP,
      maxHp: settings.shipHP,
      alive: true,
      fireCooldown: 0,
      invuln: CFG.INVULN_TIME,
      kills: 0,
      deathTime: null, // timestamp when eliminated
      placement: 0,
      killedBy: null, // name of killer or 'ASTEROID'
      // AI state
      aiTimer: rand(0, CFG.AI_REACTION),
      aiTarget: null,
      aiEvade: null,
      // Combat personality — preset or random
      aiBehavior: settings.randomPersonalities ? randomBehavior() : PRESET_PROFILES[i].behavior,
      // Aggression oscillation
      aggroPhase: settings.randomPersonalities ? rand(0, Math.PI * 2) : PRESET_PROFILES[i].aggroPhase,
      aggroSpeed: settings.randomPersonalities ? rand(0.15, 0.4) : PRESET_PROFILES[i].aggroSpeed,
      // Rock shooting preference
      rockShooter: settings.randomPersonalities ? rand(0.1, 0.9) : PRESET_PROFILES[i].rockShooter,
      // Aim style
      aimBaseline: settings.randomPersonalities ? rand(0.3, 0.9) : PRESET_PROFILES[i].aimBaseline,
      aimRange: settings.randomPersonalities ? rand(0.3, 0.5) : PRESET_PROFILES[i].aimRange,
      aimSpeed: settings.randomPersonalities ? rand(0.3, 0.8) : PRESET_PROFILES[i].aimSpeed,
      aimPhase: settings.randomPersonalities ? rand(0, Math.PI * 2) : PRESET_PROFILES[i].aimPhase,
      strafeFuel: 5,       // seconds of strafe available
      strafeDepleted: false, // lockout when fully drained
      thrustOn: false,
      weapon: getWeapon(i, _teamNum),
      passive: getPassive(i, _teamNum),
      shieldActive: false,
      hitInvulnCooldown: 0,
      iceSlow: 0,       // remaining ice slow duration
      jamSlow: 0,       // remaining jam duration
      stunTimer: 0,     // stun shock: total remaining (1s full + 2.5s decay)
      overrideTimer: 0, // override: remaining hijack duration
      overrideTurnDir: 0, // override: forced turn direction
      lastAttacker: -1,  // last pilot who dealt damage
      lastAttackerTime: 0,
      burstQueue: [],
      hpBarTimer: 0,
      beamTrail: [],
      // Maneuver state
      maneuver: getManeuver(i, _teamNum),
      maneuverCooldown: rand(3, 8), // stagger initial cooldowns
      maneuverActive: false,
      maneuverTimer: 0,
      maneuverCount: 0, // track activations for stats
      _hyperSpeedActive: false,
      _teleportPhase: null,
      _teleportAng: 0, _teleportShockTimer: 0,
      _rollDir: 0,
      _quickTurnTarget: 0, _quickTurnDone: false,
      _serpDir: 0, _serpSweep: 0, _serpTimer: 0,
      _panicSpinTotal: 0, _panicSpinDone: 0, _panicDir: 0,
      _spinOutPhase: null, _spinOutDir: 0, _spinOutBoostTimer: 0, _spinOutArcTarget: 0,
      _reversePhase: null,
      _smokestealthTimer: 0,
      _friendlyBounceTimer: 0,
      _reflectorAngle: 0,
      _repulsorX: 0, _repulsorY: 0, _repulsorLife: 0, _repulsorMaxLife: 0, _repulsorRadius: 0,
      _minesDropped: 0, _mineDropTimer: 0,
      _droneWasActive: false,
      _bioRegenTimer: 0,
      blindTimer: 0,
      burnTimer: 0,     // incendiary DoT remaining
      burnDps: 0,       // incendiary damage per second
      iceDotTimer: 0,   // ice rounds DoT remaining
      _bulletThreat: false,
      _emergencyEvade: false,
      team: _teamNum,
      origColor: PILOT_COLORS[i],
    });
    const newShip = ships[ships.length - 1];
    // Drillbore limited to one per match — reroll if already taken
    if (newShip.passive === 'drillbore') {
      if (drillboreTaken) {
        const pool = (!settings.weapons)
          ? PASSIVE_KEYS.filter(k => !ONESHOT_USELESS_PASSIVES.includes(k) && k !== 'drillbore')
          : PASSIVE_KEYS.filter(k => k !== 'drillbore');
        newShip.passive = pool[randInt(0, pool.length - 1)];
      } else {
        drillboreTaken = true;
      }
    }
    if (newShip.passive === 'bioHull') {
      newShip.hp += 1;
      newShip.maxHp += 1;
    }
    if (newShip.passive === 'flagship') {
      newShip.hp += 7;
      newShip.maxHp += 7;
      newShip.r *= 2.5;
      newShip.maneuver = 'none';
    }
    if (newShip.passive === 'shield') {
      newShip.shieldActive = true;
    }
    if (newShip.passive === 'obliterator') {
      newShip.rockShooter = Math.min(1, newShip.rockShooter + 0.3);
    }
  }

  // Build id→ship lookup (ship.id may not equal array index with <12 ships)
  // ── TEAM ASSIGNMENT ──
  // Build shipById early so team functions can reference ships
  shipById = {};
  for (const s of ships) shipById[s.id] = s;
  // matchMode is already set by the UI mode selector
  _origTeamSizes = [];
  _teamCoreColors = [];
  teamPalettes = {};
  if (matchMode === 'teams') {
    // Reposition: teams in cloud formations
    const nt = teamAssignments.length;
    const cx = CFG.WORLD_W / 2, cy = CFG.WORLD_H / 2;
    const totalFighters = ships.filter(s => s.team > 0).length;
    const smallMatchMult = totalFighters <= 4 ? 1.2 : 1.0;
    const teamSpread = 200;

    if (nt === 2) {
      // 2 teams: top vs bottom cloud formation
      const spawnGap = 700 * smallMatchMult;
      for (let ti = 0; ti < 2; ti++) {
        const teamShips = ships.filter(s => s.team === ti + 1);
        const n = teamShips.length;
        const baseY = ti === 0 ? cy - spawnGap : cy + spawnGap;
        const faceAng = ti === 0 ? Math.PI / 2 : -Math.PI / 2;
        for (let si = 0; si < n; si++) {
          const spread = n > 1 ? (si / (n - 1) - 0.5) * teamSpread * Math.min(n, 6) : 0;
          teamShips[si].x = cx + spread + rand(-40, 40);
          teamShips[si].y = baseY + rand(-50, 50);
          teamShips[si].ang = faceAng;
        }
      }
    } else {
      // 3+ teams: polygon spokes with cloud grid formation
      const spawnDist = Math.min(900, 500 + totalFighters * 20) * smallMatchMult * 1.2;
      const shipSpacing = 80;
      for (let ti = 0; ti < nt; ti++) {
        const teamShips = ships.filter(s => s.team === ti + 1);
        const n = teamShips.length;
        const spokeAng = (ti / nt) * Math.PI * 2 - Math.PI / 2;
        const baseX = cx + Math.cos(spokeAng) * spawnDist;
        const baseY = cy + Math.sin(spokeAng) * spawnDist;
        const faceAng = Math.atan2(cy - baseY, cx - baseX);
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n / cols);
        for (let si = 0; si < n; si++) {
          const col = si % cols;
          const row = Math.floor(si / cols);
          const rowCount = Math.min(cols, n - row * cols);
          const ox = (col - (rowCount - 1) / 2) * shipSpacing;
          const oy = (row - (rows - 1) / 2) * shipSpacing;
          const perpAng = faceAng + Math.PI / 2;
          teamShips[si].x = baseX + Math.cos(perpAng) * ox + Math.cos(faceAng) * oy + rand(-10, 10);
          teamShips[si].y = baseY + Math.sin(perpAng) * ox + Math.sin(faceAng) * oy + rand(-10, 10);
          teamShips[si].ang = faceAng;
        }
      }
    }
    // Store original team sizes & colors for convergence
    for (let t = 1; t <= nt; t++) {
      _origTeamSizes[t] = ships.filter(s => s.team === t).length;
    }
    _teamCoreColors = getTeamColors();
    // Build team color palettes for trail particles
    for (const s of ships) {
      if (s.team > 0) {
        if (!teamPalettes[s.team]) teamPalettes[s.team] = [];
        if (!teamPalettes[s.team].includes(s.color)) teamPalettes[s.team].push(s.color);
      }
    }
    // Stagger fire cooldowns: only frontmost ship fires immediately
    for (let t = 1; t <= nt; t++) {
      const teamShips = ships.filter(s => s.team === t);
      if (teamShips.length <= 1) continue;
      let minDist = Infinity, closestId = null;
      for (const s of teamShips) {
        const d = Math.hypot(s.x - cx, s.y - cy);
        if (d < minDist) { minDist = d; closestId = s.id; }
      }
      for (const s of teamShips) {
        if (s.id !== closestId) s.fireCooldown = 2.0;
      }
    }
  }

  shipById = {};
  for (const s of ships) shipById[s.id] = s;

  // Spawn asteroids — avoid ship spawn locations
  // 2-5 mega asteroids
  const numMegas = randInt(2, 5);
  for (let i = 0; i < numMegas; i++) {
    let ast;
    let tries = 0;
    do {
      ast = spawnAsteroid(0);
      tries++;
    } while (tries < 20 && ships.some(s => dist(s, ast) < 400));
    asteroids.push(ast);
  }
  // Standard and half-size asteroids
  for (let i = 0; i < CFG.NUM_ASTEROIDS; i++) {
    let ast;
    let tries = 0;
    const sizeIdx = Math.random() < 0.1 ? 2 : 1; // 10% half-size
    do {
      ast = spawnAsteroid(sizeIdx);
      tries++;
    } while (tries < 20 && ships.some(s => dist(s, ast) < 200));
    asteroids.push(ast);
  }
  // Border asteroids — outside play zone to disguise edges
  const border = 600;
  for (let i = 0; i < 60; i++) {
    const side = randInt(0, 3);
    let bx, by;
    if (side === 0) { bx = rand(-border, 0); by = rand(-border, CFG.WORLD_H + border); }
    else if (side === 1) { bx = rand(CFG.WORLD_W, CFG.WORLD_W + border); by = rand(-border, CFG.WORLD_H + border); }
    else if (side === 2) { bx = rand(-border, CFG.WORLD_W + border); by = rand(-border, 0); }
    else { bx = rand(-border, CFG.WORLD_W + border); by = rand(CFG.WORLD_H, CFG.WORLD_H + border); }
    const sizeIdx = Math.random() < 0.15 ? 0 : Math.random() < 0.3 ? 2 : 1;
    const bAst = spawnAsteroid(sizeIdx, bx, by);
    bAst.isBorder = true;
    bAst.vx *= 0.2; // slow drift
    bAst.vy *= 0.2;
    asteroids.push(bAst);
  }

  document.getElementById('winner-overlay').classList.remove('show');
  document.getElementById('arena-btn').style.display = 'none';
  showScoreboard = false;
  document.getElementById('alive-num').textContent = settings.numShips;
  buildScoreboard();
  buildPregameRoster();
  pregame = true;
  countdown = false;
  countdownTimer = 0;
  document.getElementById('countdown-overlay').classList.add('hidden');
  document.getElementById('pregame-overlay').classList.remove('hidden');
  cameraX = CFG.WORLD_W / 2;
  cameraY = CFG.WORLD_H / 2;
  camZoom = 0.15;
  targetZoom = 0.15;
  cameraMode = 'overview';
  manualShips = [];
  selectBoxStart = null;
  selectBoxEnd = null;
  isSelecting = false;
  cameraLinger = 0;
  cameraTransitioning = false;
}

// ─── PARTICLES ────────────────────────────────────────────────
function spawnExplosion(x, y, color, count, speed) {
  for (let i = 0; i < count; i++) {
    const a = rand(0, Math.PI * 2);
    const sp = rand(20, speed);
    particles.push({
      x, y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      life: rand(0.3, 1.2),
      maxLife: 1.2,
      color,
      size: rand(1, 3),
    });
  }
  shockwaves.push({ x, y, r: 0, maxR: speed * 0.8, life: 0.4, color });
}

function spawnThrustParticle(ship) {
  const bx = ship.x - Math.cos(ship.ang) * ship.r * 0.5;
  const by = ship.y - Math.sin(ship.ang) * ship.r * 0.5;
  const lifeMult = (ship.passive === 'nitro' ? 2.0 : 1.0) * (ship.team > 0 ? 1.5 : 1.0);

  if (ship.passive === 'stealth') {
    // Beam trail: store position for line drawing instead of particles
    if (!ship.beamTrail) ship.beamTrail = [];
    ship.beamTrail.push({ x: bx, y: by, life: 0.125 * lifeMult, maxLife: 0.125 * lifeMult });
    return;
  }

  // Determine exhaust angles: center for normal, center + ±30° for gyro
  const angles = [ship.ang + Math.PI]; // default: straight back
  if (ship.passive === 'gyro') {
    angles.push(ship.ang + Math.PI + 0.524); // +30°
    angles.push(ship.ang + Math.PI - 0.524); // -30°
  }

  // Pick exhaust color: team mode uses random color from team palette
  const teamColors = (ship.team > 0 && teamPalettes[ship.team]) ? teamPalettes[ship.team] : null;

  for (const exAng of angles) {
    const isBio = ship.passive === 'bioHull';
    const exColor = isBio ? '#44ff44' : teamColors ? teamColors[randInt(0, teamColors.length - 1)] : ship.color;
    particles.push({
      x: bx + rand(-3, 3),
      y: by + rand(-3, 3),
      vx: Math.cos(exAng) * rand(30, 80) + ship.vx * 0.3,
      vy: Math.sin(exAng) * rand(30, 80) + ship.vy * 0.3,
      life: rand(0.45, 1.35) * lifeMult,
      maxLife: 1.35 * lifeMult,
      color: exColor,
      size: rand(1, 2.5),
      isPlus: isBio,
    });
  }
}

// ─── AI ───────────────────────────────────────────────────────
// Predict if a ship will collide with an asteroid within `lookahead` seconds
function predictCollision(ship, ast, lookahead) {
  // Relative velocity
  const rvx = ship.vx - ast.vx;
  const rvy = ship.vy - ast.vy;
  // Relative position
  const rpx = ship.x - ast.x;
  const rpy = ship.y - ast.y;
  // Closest approach time: t = -dot(rp,rv) / dot(rv,rv)
  const rvDot = rvx * rvx + rvy * rvy;
  if (rvDot < 1) return null; // barely moving relative
  const t = -(rpx * rvx + rpy * rvy) / rvDot;
  if (t < 0 || t > lookahead) return null;
  // Distance at closest approach
  const cx = rpx + rvx * t;
  const cy = rpy + rvy * t;
  const closestDist = Math.hypot(cx, cy);
  const collisionR = ship.r + ast.r * 0.85 + 40; // generous safety margin
  if (closestDist < collisionR) {
    return { t, dist: closestDist, ast };
  }
  return null;
}

// Check if a direction is safe — no asteroid collisions along that path
function isDirectionSafe(ship, ang, speed, lookahead) {
  const testVx = Math.cos(ang) * speed;
  const testVy = Math.sin(ang) * speed;
  const testShip = { x: ship.x, y: ship.y, vx: testVx, vy: testVy, r: ship.r };
  const scanR = 400 + speed * lookahead; // scale scan with how far we'll travel
  for (const ast of asteroids) {
    const d = dist(ship, ast);
    if (d > scanR) continue;
    if (predictCollision(testShip, ast, lookahead)) return false;
  }
  return true;
}

// Find the best evasion angle — scan multiple directions and pick the safest
function findSafeDirection(ship, preferredAng, speed, look) {
  if (ship.passive === 'drillbore' && ship.hp > 0.5) return preferredAng;
  const la = look || 1.5;
  // Test preferred angle first
  if (isDirectionSafe(ship, preferredAng, speed, la)) return preferredAng;
  // Fan out from preferred angle
  for (let offset = 0.3; offset <= Math.PI; offset += 0.25) {
    if (isDirectionSafe(ship, preferredAng + offset, speed, la)) return preferredAng + offset;
    if (isDirectionSafe(ship, preferredAng - offset, speed, la)) return preferredAng - offset;
  }
  // Nothing safe — go opposite of densest threat cluster
  return preferredAng + Math.PI;
}

function updateAI(ship, dt) {
  ship.aiTimer -= dt;
  if (ship.aiTimer > 0) return;
  ship.aiTimer = CFG.AI_REACTION + rand(0, 0.08);
  ship._isStrafing = false;
  ship._avoidStrafe = false;
  ship._avoidStrafeStrength = 1;
  ship._bloodthirstyCombat = false;

  let closestEnemy = null;
  let closestEnemyDist = Infinity;
  const shipSpeed = Math.hypot(ship.vx, ship.vy);

  // ── PREDICTIVE ASTEROID COLLISION SCAN ──
  // Gather all imminent collisions within the next 2 seconds
  const collisions = [];
  if (ship.passive !== 'drillbore' || ship.hp <= 0.5) {
    for (const ast of asteroids) {
      const d = dist(ship, ast);
      if (d > 900) continue; // scan wider radius
      const col = predictCollision(ship, ast, 3.0);
      if (col) collisions.push(col);
    }
    // Sort by urgency (soonest first)
    collisions.sort((a, b) => a.t - b.t);
  }

  // ── SCAN INCOMING BULLETS ──
  let bulletThreat = null;
  for (const b of bullets) {
    if (b.owner === ship.id) continue;
    if (b.ownerTeam > 0 && ship.team === b.ownerTeam) continue;
    const d = dist(ship, b);
    if (d > 200) continue;
    // Is bullet heading toward us?
    const toShipX = ship.x - b.x;
    const toShipY = ship.y - b.y;
    const dot = toShipX * b.vx + toShipY * b.vy;
    if (dot > 0) { // bullet moving toward ship
      const bSpeed = Math.hypot(b.vx, b.vy);
      const timeToHit = d / bSpeed;
      if (timeToHit < 0.5 && (!bulletThreat || timeToHit < bulletThreat.time)) {
        bulletThreat = { obj: b, time: timeToHit, dist: d };
      }
    }
  }

  // ── SCAN ENEMIES ──
  for (const other of ships) {
    if (other.id === ship.id || !other.alive) continue;
    if (ship.team > 0 && other.team === ship.team) continue;
    let d = dist(ship, other);
    // Stealth passive: target appears twice as far away
    if (other.passive === 'stealth') d *= 1.5;
    // Smokescreen: extreme stealth — 96% shrink for 2s, decaying over next 3s
    if (other._smokestealthTimer > 0) {
      const st = other._smokestealthTimer;
      if (st > 3.0) {
        d *= 25; // full 96% detection shrink
      } else {
        d *= 1 + 24 * (st / 3.0); // decay from 25x back to 1x
      }
    }
    // Blinding rounds: this ship is blinded — can't see enemies
    if (ship.blindTimer > 0) {
      if (ship.blindTimer > 1.5) {
        d = Infinity; // fully blind
      } else {
        d *= 1 + 50 * (ship.blindTimer / 1.5); // decay from 51x to 1x
      }
    }
    if (d < closestEnemyDist) {
      closestEnemyDist = d;
      closestEnemy = other;
    }
  }

  // Check smoke decoys as potential targets (stationary fake enemy)
  for (const decoy of smokeDecoys) {
    if (decoy.ownerId === ship.id) continue; // don't target own smoke
    if (ship.team > 0 && decoy.ownerTeam === ship.team) continue; // don't target teammate smoke
    const d = dist(ship, decoy);
    if (d < closestEnemyDist) {
      closestEnemyDist = d;
      closestEnemy = { x: decoy.x, y: decoy.y, vx: 0, vy: 0, id: -99, alive: true };
    }
  }

  // Check ship clones as potential targets (Double Team)
  for (const clone of shipClones) {
    if (clone.ownerId === ship.id || !clone.alive || clone.hit) continue;
    if (ship.team > 0) { const cloneOwner = shipById[clone.ownerId]; if (cloneOwner && cloneOwner.team === ship.team) continue; }
    const d = dist(ship, clone);
    if (d < closestEnemyDist) {
      closestEnemyDist = d;
      const parent = shipById[clone.ownerId];
      closestEnemy = { x: clone.x, y: clone.y, vx: parent ? parent.vx : 0, vy: parent ? parent.vy : 0, id: -98, alive: true };
    }
  }

  // ── BORDER AVOIDANCE ──
  const margin = 250;
  let borderForceX = 0, borderForceY = 0;
  const borderStrength = 1.5;
  if (ship.x < margin) borderForceX = borderStrength * (1 - ship.x / margin);
  if (ship.x > CFG.WORLD_W - margin) borderForceX = -borderStrength * (1 - (CFG.WORLD_W - ship.x) / margin);
  if (ship.y < margin) borderForceY = borderStrength * (1 - ship.y / margin);
  if (ship.y > CFG.WORLD_H - margin) borderForceY = -borderStrength * (1 - (CFG.WORLD_H - ship.y) / margin);
  const hasBorderPressure = Math.abs(borderForceX) > 0.1 || Math.abs(borderForceY) > 0.1;

  // ── DECIDE BEHAVIOR (PRIORITY SYSTEM) ──
  let desiredAng = ship.ang;
  let wantThrust = false;
  let wantShoot = false;

  // Bloodthirsty check: if engaging an enemy, skip asteroid avoidance entirely
  // Bloodthirsty check: reckless only if target isn't firing back
  let bloodthirstyInCombat = false;
  if (ship.aiBehavior === 'bloodthirsty' && closestEnemy && closestEnemyDist < 1400) {
    // As the match progresses, bloodthirsty cares less about return fire
    // bloodthirstyRage: 0.35 at start → 1 by ~90s (reckless from the beginning, fully unhinged late)
    const bloodthirstyRage = Math.min(1, 0.35 + gameTime / 120);
    // Check if the target has any bullets heading our way
    let targetFiringBack = false;
    for (const b of bullets) {
      if (b.owner !== closestEnemy.id) continue;
      const d = dist(ship, b);
      if (d > 500) continue;
      const dot = (ship.x - b.x) * b.vx + (ship.y - b.y) * b.vy;
      if (dot > 0) { targetFiringBack = true; break; }
    }
    // Early game: only reckless vs passive targets. Late game: reckless regardless.
    bloodthirstyInCombat = !targetFiringBack || Math.random() < bloodthirstyRage;
  }

  // PRIORITY 1: Imminent asteroid collision (< 1s away) — bloodthirsty now dodges rocks but ignores bullets
  const urgentCollision = collisions.length > 0 && collisions[0].t < 1.0;

  // PRIORITY 2: Bullet dodge
  const urgentBullet = bulletThreat && bulletThreat.time < 0.4;

  if (urgentCollision || (urgentBullet && !bloodthirstyInCombat)) {
    // Build a combined avoidance vector from all imminent threats
    let avoidX = 0, avoidY = 0;
    const strafeDir = (ship.id % 2 === 0) ? 1 : -1;

    for (const col of collisions) {
      if (col.t > 1.5) break;
      const urgency = 1 / (col.t + 0.1);
      const toAst = angle(ship, col.ast);
      // Asteroids are weighted 3x — dodging into a rock is always worse than eating a bullet
      const slipAng = toAst + Math.PI * 0.8 + strafeDir * 0.4;
      avoidX += Math.cos(slipAng) * urgency * 3;
      avoidY += Math.sin(slipAng) * urgency * 3;
    }

    if (bulletThreat) {
      const toBullet = angle(ship, bulletThreat.obj);
      const urgency = 1 / (bulletThreat.time + 0.05);
      const slipAng = toBullet + Math.PI * 0.5 * strafeDir;
      // Only dodge bullet if there are no nearby asteroid collisions
      const bulletWeight = collisions.length > 0 ? 0.15 : 0.8;
      avoidX += Math.cos(slipAng) * urgency * bulletWeight;
      avoidY += Math.sin(slipAng) * urgency * bulletWeight;
    }

    if (hasBorderPressure) {
      avoidX += borderForceX * 2;
      avoidY += borderForceY * 2;
    }

    if (Math.abs(avoidX) > 0.01 || Math.abs(avoidY) > 0.01) {
      const rawAvoidAng = Math.atan2(avoidY, avoidX);
      desiredAng = findSafeDirection(ship, rawAvoidAng, Math.max(shipSpeed, 120));
    } else {
      // Perpendicular escape with strafe bias
      const threat = collisions[0] || { ast: bulletThreat.obj };
      const toThreat = angle(ship, threat.ast || bulletThreat.obj);
      desiredAng = toThreat + Math.PI * 0.5 * strafeDir;
    }
    wantThrust = true;
    // Flag lateral push for smooth per-frame strafe
    ship._avoidStrafe = true;

    // Opportunistic shooting at the asteroid blocking us
    if (urgentCollision) {
      const toAst = angle(ship, collisions[0].ast);
      const da = Math.abs(shortAngleDist(ship.ang, toAst));
      if (da < 0.4 && Math.random() < ship.rockShooter) wantShoot = true;
    }
  }
  // PRIORITY 3: Border avoidance
  else if (hasBorderPressure) {
    const borderAng = Math.atan2(borderForceY, borderForceX);
    desiredAng = findSafeDirection(ship, borderAng, Math.max(shipSpeed, 100));
    wantThrust = true;
  }
  // PRIORITY 4: Upcoming collision (1-2.5s) — gentle strafe correction (bloodthirsty ignores when in combat)
  else if (collisions.length > 0 && collisions[0].t < 2.5 && !bloodthirstyInCombat) {
    const col = collisions[0];
    const toAst = angle(ship, col.ast);
    const strafeDir = (ship.id % 2 === 0) ? 1 : -1;
    // Gentle lateral offset — weave past rather than hard turn
    // Blend current heading with a perpendicular nudge
    const perpAng = toAst + Math.PI * 0.5 * strafeDir;
    const urgencyBlend = Math.max(0.2, Math.min(0.7, 1 - col.t / 2.5));
    const weaveAng = ship.ang + shortAngleDist(ship.ang, perpAng) * urgencyBlend;
    desiredAng = findSafeDirection(ship, weaveAng, Math.max(shipSpeed, 100));
    wantThrust = true;
    ship._avoidStrafe = true;
    ship._avoidStrafeStrength = urgencyBlend; // stronger as collision gets closer

    // Try to shoot the asteroid if we can
    const da = Math.abs(shortAngleDist(ship.ang, toAst));
    if (da < 0.35 && Math.random() < ship.rockShooter) wantShoot = true;
  }
  // PRIORITY 5: Combat
  else if (closestEnemy) {
    // Aggression oscillation — each ship periodically surges toward more aggressive behavior
    const aliveCount = ships.filter(s => s.alive).length;
    // Evasive ships shift to hunter-level aggression in top 3 — survival instinct kicks in
    const evasiveEndgame = ship.aiBehavior === 'evasive' && aliveCount <= 3;
    const aggroBase = ship.aiBehavior === 'aggressive' || ship.aiBehavior === 'bloodthirsty' ? 0.85 :
                      ship.aiBehavior === 'hunter' || evasiveEndgame ? 0.6 :
                      ship.aiBehavior === 'cautious' ? 0.35 : 0.2;
    const aggroSwing = ship.aiBehavior === 'aggressive' || ship.aiBehavior === 'bloodthirsty' ? 0.15 :
                       ship.aiBehavior === 'hunter' || evasiveEndgame ? 0.25 :
                       ship.aiBehavior === 'cautious' ? 0.3 : 0.35;
    const aggro = Math.max(0, Math.min(1, aggroBase + Math.sin(gameTime * ship.aggroSpeed + ship.aggroPhase) * aggroSwing));

    // Interpolate personality values toward aggressive levels based on aggro
    const teamDetectMult = (ship.team > 0) ? 3 : 1;
    const baseRange = lerp(550, 1400, aggro) * teamDetectMult;
    const maxRange = Math.hypot(CFG.WORLD_W, CFG.WORLD_H);
    const timeScale = Math.min(1, gameTime / 60);
    const aggressionRange = lerp(baseRange, maxRange, timeScale);

    if (closestEnemyDist < aggressionRange) {
      if (ship.aiBehavior === 'bloodthirsty') ship._bloodthirstyCombat = bloodthirstyInCombat;
      const toEnemy = angle(ship, closestEnemy);
      const wSpeed = ship.weapon.speed;
      const travelTime = closestEnemyDist / wSpeed;
      // Oscillating lead factor — smoothly drifts between direct and leading shots
      const rawLead = ship.aimBaseline + Math.sin(gameTime * ship.aimSpeed + ship.aimPhase) * ship.aimRange;
      // Turret Mode or Spin Out boost: clamp aim toward optimal leading
      const hasAimBoost = (ship.maneuverActive && ship.maneuver === 'turretMode') || ship._spinOutBoostTimer > 0;
      const leadFactor = hasAimBoost
        ? Math.max(0.7, Math.min(1.1, rawLead))
        : Math.max(0.05, Math.min(1.3, rawLead));
      const leadX = closestEnemy.x + closestEnemy.vx * travelTime * leadFactor;
      const leadY = closestEnemy.y + closestEnemy.vy * travelTime * leadFactor;
      const leadAng = Math.atan2(leadY - ship.y, leadX - ship.x);

      // Evasive flee — only when aggro is low enough (bloodthirsty never flees when reckless)
      // In top 3, evasive ships stop running and fight
      // Drone users keep their distance when drones are orbiting
      const hasDronesOut = ship.weapon.type === 'drone' && shipDrones.some(d => d.ownerId === ship.id);
      const droneFleeBonus = hasDronesOut ? 350 : 0;
      const fleeThreshold = ((ship.aiBehavior === 'evasive' && !evasiveEndgame) ? 300 : 150) + droneFleeBonus;
      const fleeAggroThreshold = hasDronesOut ? 0.7 : 0.4;
      if (!(ship.aiBehavior === 'bloodthirsty' && bloodthirstyInCombat) && aggro < fleeAggroThreshold && closestEnemyDist < fleeThreshold) {
        const fleeAng = toEnemy + Math.PI;
        desiredAng = findSafeDirection(ship, fleeAng, Math.max(shipSpeed, 120));
        wantThrust = true;
      } else {
        // Separate flight path from aim — approach at a slight offset to create lateral movement
        const strafeDir = (ship.id % 2 === 0) ? 1 : -1;
        const baseStrafeAng = lerp(0.4, 0.12, aggro);
        // Strafe starts gentle from far away, increases as they close in
        const strafeFactor = Math.max(0.15, Math.min(1, 1 - (closestEnemyDist - 300) / 1500));
        
        // Only strafe if we have fuel
        const canStrafe = !ship.strafeDepleted && ship.strafeFuel > 0;
        const strafeOffset = canStrafe ? baseStrafeAng * strafeFactor * strafeDir : 0;
        ship._isStrafing = canStrafe && closestEnemyDist < 1000;

        const flightAng = toEnemy + strafeOffset;
        const approachAng = closestEnemyDist > 350 ?
          findSafeDirection(ship, flightAng, Math.max(shipSpeed, 100)) : flightAng;
        
        // Safety check: if our combat path leads into an asteroid, override with evasion
        // Bloodthirsty ignores this when target isn't firing back
        let combatAng = approachAng;
        if (!(ship.aiBehavior === 'bloodthirsty' && bloodthirstyInCombat)) {
          for (const col of collisions) {
            if (col.t < 1.5) {
              const toAst = angle(ship, col.ast);
              const awayAng = toAst + Math.PI;
              const blend = Math.max(0.3, Math.min(0.8, 1 - col.t / 1.5));
              combatAng = combatAng + shortAngleDist(combatAng, awayAng) * blend;
              break;
            }
          }
        }
        desiredAng = combatAng;
        wantThrust = closestEnemyDist > 150;
        const da = Math.abs(shortAngleDist(ship.ang, leadAng));
        const bulletRange = ship.weapon.speed * ship.weapon.life;
        const fireRangeMult = lerp(0.75, 1.2, aggro);
        const aimCone = ship.weapon.type === 'homing' ? 0.6 :
                        ship.weapon.type === 'shotgun' || ship.weapon.type === 'flamethrower' ? 0.45 : 0.35;
        wantShoot = da < aimCone && closestEnemyDist < bulletRange * fireRangeMult;
      }
    } else {
      // Roam — head toward center-ish via safe path
      const toCenterAng = Math.atan2(CFG.WORLD_H/2 - ship.y, CFG.WORLD_W/2 - ship.x);
      const toCenterDist = Math.hypot(CFG.WORLD_W/2 - ship.x, CFG.WORLD_H/2 - ship.y);
      const roamThreshold = lerp(2500, 800, Math.min(1, gameTime / 60));
      const roamAng = toCenterDist > roamThreshold ? toCenterAng + rand(-0.4, 0.4) : ship.ang + rand(-0.6, 0.6);
      desiredAng = findSafeDirection(ship, roamAng, Math.max(shipSpeed, 80), 2.5);
      wantThrust = true;
    }
  } else {
    // No enemies — just roam safely
    desiredAng = findSafeDirection(ship, ship.ang + rand(-0.4, 0.4), Math.max(shipSpeed, 80), 2.5);
    wantThrust = true;
  }

  // ── APPLY AI INTENT ──
  const turnDir = shortAngleDist(ship.ang, desiredAng);
  ship._aiTurnDir = Math.sign(turnDir) * Math.min(1, Math.abs(turnDir) * 3);
  ship._aiThrust = wantThrust;
  ship._aiShoot = wantShoot;

  // ── MANEUVER CONTEXT FLAGS ──
  ship._bulletThreat = !!bulletThreat;
  ship._emergencyEvade = collisions.length > 0;

  // ── MANEUVER TRIGGER CHECK ──
  if (ship.maneuver !== 'none' && !ship.maneuverActive && ship.maneuverCooldown <= 0) {
    if (checkManeuverTrigger(ship)) {
      startManeuver(ship);
      ship.maneuverCount++;
    }
  }
}

// ─── UPDATE ───────────────────────────────────────────────────
function update(rawDt) {
  const dt = rawDt * simSpeed * finaleSlowMo * 0.5;

  // During pregame, still render but don't simulate
  if (pregame) {
    // Keep camera showing the full map
    targetCamX = CFG.WORLD_W / 2;
    targetCamY = CFG.WORLD_H / 2;
    const fullZoomX = W / (CFG.WORLD_W + 200);
    const fullZoomY = H / (CFG.WORLD_H + 200);
    targetZoom = Math.min(fullZoomX, fullZoomY);
    const camLerpPre = 1 - Math.pow(1 - 0.05, rawDt * 60);
    cameraX = lerp(cameraX, targetCamX, camLerpPre);
    cameraY = lerp(cameraY, targetCamY, camLerpPre);
    camZoom = lerp(camZoom, targetZoom, camLerpPre);
    updateScoreboard();
    return;
  }

  // During countdown, render ships but don't simulate gameplay
  if (countdown) {
    countdownTimer -= rawDt;
    // Update countdown display
    const secs = Math.ceil(Math.max(0, countdownTimer));
    document.getElementById('countdown-timer').textContent = 'MATCH BEGINNING IN ' + secs + '!';
    // Play tick sound on each new second
    if (secs !== _lastCountdownSec && secs > 0) {
      _lastCountdownSec = secs;
      playCountdownTick(secs);
    }
    // Frame camera around ship positions
    const cdAlive = ships.filter(s => s.alive);
    if (cdAlive.length > 0) {
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const s of cdAlive) {
        minX = Math.min(minX, s.x); maxX = Math.max(maxX, s.x);
        minY = Math.min(minY, s.y); maxY = Math.max(maxY, s.y);
      }
      targetCamX = (minX + maxX) / 2;
      targetCamY = (minY + maxY) / 2;
      const camPad = 200 + cdAlive.length * 15;
      const spreadX = maxX - minX + camPad;
      const spreadY = maxY - minY + camPad;
      targetZoom = Math.min(W / spreadX, H / spreadY);
      targetZoom = Math.max(0.15, Math.min(1.5, targetZoom));
    }
    const camLerpCd = 1 - Math.pow(1 - 0.05, rawDt * 60);
    cameraX = lerp(cameraX, targetCamX, camLerpCd);
    cameraY = lerp(cameraY, targetCamY, camLerpCd);
    camZoom = lerp(camZoom, targetZoom, camLerpCd);
    if (countdownTimer <= 0) {
      endCountdown();
    }
    return;
  }

  // During finale, keep updating visuals even after gameOver
  if (gameOver && !finaleMode) return;

  // If game is over but finale still running, only update visuals
  const skipGameplay = gameOver;
  gameTime += dt;

  if (!skipGameplay) {

  // Update ships
  for (const ship of ships) {
    if (!ship.alive) continue;

    ship.invuln = Math.max(0, ship.invuln - dt);
    ship.hitInvulnCooldown = Math.max(0, ship.hitInvulnCooldown - dt);
    ship.iceSlow = Math.max(0, ship.iceSlow - dt);
    ship.jamSlow = Math.max(0, ship.jamSlow - dt);
    ship.stunTimer = Math.max(0, ship.stunTimer - dt);
    ship.blindTimer = Math.max(0, ship.blindTimer - dt);

    // Incendiary burn DoT
    if (ship.burnTimer > 0) {
      ship.hp -= ship.burnDps * dt;
      ship.burnTimer -= dt;
      ship.hpBarTimer = 0.3;
      if (ship.burnTimer <= 0) { ship.burnTimer = 0; ship.burnDps = 0; }
      if (ship.hp <= 0 && ship.alive) killShip(ship, ship.lastAttacker);
    }
    // Ice rounds DoT: 0.25 HP over 2s
    if (ship.iceDotTimer > 0) {
      ship.hp -= (0.25 / 2.0) * dt;
      ship.iceDotTimer -= dt;
      ship.hpBarTimer = 0.3;
      if (ship.iceDotTimer <= 0) ship.iceDotTimer = 0;
      if (ship.hp <= 0 && ship.alive) killShip(ship, ship.lastAttacker);
    }

    // Bio-Hull regeneration: +0.1 HP every 2 seconds
    if (ship.passive === 'bioHull' && ship.hp < ship.maxHp) {
      ship._bioRegenTimer += dt;
      if (ship._bioRegenTimer >= 2.0) {
        ship._bioRegenTimer -= 2.0;
        ship.hp = Math.min(ship.maxHp, ship.hp + 0.1);
        // Plus sign particle
        particles.push({
          x: ship.x + rand(-8, 8), y: ship.y + rand(-8, 8),
          vx: rand(-10, 10), vy: rand(-30, -15),
          life: 0.8, maxLife: 0.8, color: '#44ff44', size: 4,
          isPlus: true,
        });
      }
    }
    ship.overrideTimer = Math.max(0, ship.overrideTimer - dt);

    // Age stealth beam trail
    if (ship.beamTrail) {
      for (let t = ship.beamTrail.length - 1; t >= 0; t--) {
        ship.beamTrail[t].life -= dt;
        if (ship.beamTrail[t].life <= 0) ship.beamTrail.splice(t, 1);
      }
    }

    // ── DEBUFF VISUAL EFFECTS ──
    // Incendiary burn: fire particles rising from ship
    if (ship.burnTimer > 0 && Math.random() < 0.5) {
      particles.push({
        x: ship.x + rand(-ship.r, ship.r), y: ship.y + rand(-ship.r, ship.r),
        vx: rand(-20, 20), vy: rand(-60, -30),
        life: rand(0.2, 0.4), maxLife: 0.4,
        color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00', size: rand(2, 4),
      });
    }
    // Ice Rounds: diamond and snowflake particles emitted from affected ship
    if (ship.iceSlow > 0 && Math.random() < 0.4) {
      const perp = ship.ang + Math.PI / 2;
      const side = Math.random() < 0.5 ? 1 : -1;
      const offset = rand(0, ship.r * 1.2);
      const iceType = Math.random() < 0.5 ? 'diamond' : 'snowflake';
      particles.push({
        x: ship.x + Math.cos(perp) * side * offset, y: ship.y + Math.sin(perp) * side * offset,
        vx: Math.cos(perp) * side * rand(30, 60) + rand(-10, 10),
        vy: Math.sin(perp) * side * rand(30, 60) + rand(-10, 10) - 15,
        life: 0.4, maxLife: 0.4,
        color: '#55bbff', size: rand(3, 6),
        isDiamond: iceType === 'diamond', isSnowflake: iceType === 'snowflake',
        spinAng: rand(0, Math.PI * 2),
      });
    }

    // Jam Rounds: perpendicular lines from front of affected ship
    if (ship.jamSlow > 0 && Math.random() < 0.35) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r;
      const fy = ship.y + Math.sin(ship.ang) * ship.r;
      const perp = ship.ang + Math.PI / 2;
      const side = Math.random() < 0.5 ? 1 : -1;
      particles.push({
        x: fx, y: fy,
        vx: Math.cos(perp) * side * rand(30, 70),
        vy: Math.sin(perp) * side * rand(30, 70),
        life: 0.25, maxLife: 0.25,
        color: '#ffaa00', size: rand(1.5, 3), isLine: true, lineAng: perp, lineLen: rand(6, 12),
      });
    }

    // Stun Shock: mini lightning arcs crackle on affected ship
    if (ship.stunTimer > 0 && Math.random() < 0.4) {
      const a = rand(0, Math.PI * 2);
      const d = rand(0, ship.r * 1.2);
      const arcLen = rand(8, 18);
      const segs = randInt(2, 3);
      const ap = [{x: 0, y: 0}];
      for (let s = 1; s <= segs; s++) {
        const t = s / segs;
        ap.push({
          x: Math.cos(a) * arcLen * t + rand(-4, 4),
          y: Math.sin(a) * arcLen * t + rand(-4, 4)
        });
      }
      particles.push({
        x: ship.x + Math.cos(a) * d, y: ship.y + Math.sin(a) * d,
        vx: rand(-20, 20), vy: rand(-20, 20),
        life: 0.18, maxLife: 0.18,
        color: '#ffff44', size: 1.5,
        isArc: true, arcPoints: ap,
      });
    }

    // Override: ball particles from front of affected ship
    if (ship.overrideTimer > 0 && Math.random() < 0.5) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r;
      const fy = ship.y + Math.sin(ship.ang) * ship.r;
      const a = rand(0, Math.PI * 2);
      particles.push({
        x: fx + rand(-5, 5), y: fy + rand(-5, 5),
        vx: Math.cos(a) * rand(20, 60), vy: Math.sin(a) * rand(20, 60),
        life: 0.25, maxLife: 0.25,
        color: '#8844dd', size: rand(2, 4.5),
      });
    }

    // Blinding rounds: orange ellipse flashes in front of affected ship
    if (ship.blindTimer > 0 && Math.random() < 0.4) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r * 1.2;
      const fy = ship.y + Math.sin(ship.ang) * ship.r * 1.2;
      shockwaves.push({
        x: fx + rand(-6, 6), y: fy + rand(-6, 6),
        r: 0, maxR: rand(12, 25), life: 0.2, maxLife: 0.2,
        color: '#ff8800', ellipse: true, ellipseAng: ship.ang + rand(-0.3, 0.3),
      });
    }
    ship.fireCooldown = Math.max(0, ship.fireCooldown - dt);
    ship.hpBarTimer = Math.max(0, ship.hpBarTimer - dt);

    // AI
    updateAI(ship, dt);

    // Maneuver cooldown & update
    ship.maneuverCooldown = Math.max(0, ship.maneuverCooldown - dt);
    if (ship._spinOutBoostTimer > 0) ship._spinOutBoostTimer = Math.max(0, ship._spinOutBoostTimer - dt);
    if (ship._smokestealthTimer > 0) ship._smokestealthTimer = Math.max(0, ship._smokestealthTimer - dt);
    updateManeuver(ship, dt);

    // Strafe fuel management
    if (ship._isStrafing) {
      ship.strafeFuel = Math.max(0, ship.strafeFuel - dt);
      if (ship.strafeFuel <= 0) {
        ship.strafeDepleted = true;
      }
    } else {
      if (ship.strafeDepleted) {
        ship.strafeFuel = Math.min(5, ship.strafeFuel + dt);
        if (ship.strafeFuel >= 5) ship.strafeDepleted = false;
      } else {
        ship.strafeFuel = Math.min(5, ship.strafeFuel + dt * 1.0);
      }
    }

    // Active maneuver overrides normal movement (barrel roll, quick-turn, teleport)
    const maneuverControlsMovement = ship.maneuverActive &&
      (ship.maneuver === 'barrelRoll' || ship.maneuver === 'quickTurn' || ship._teleportPhase === 'phasing'
       || ship.maneuver === 'serpentine' || ship.maneuver === 'panic'
       || ship.maneuver === 'spinOut');

    // Override rounds: hijack controls — forced thrust + random turn
    if (ship.overrideTimer > 0 && !maneuverControlsMovement) {
      ship.ang += ship.overrideTurnDir * CFG.SHIP_TURN_SPEED * dt;
      ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * dt;
      ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * dt;
      ship.thrustOn = true;
    }

    // Turn (gatling reduces turn speed by 60% while firing)
    const gatlingFiring = ship.weapon.type === 'gatling' && ship.burstQueue.length > 0;
    const gyroMult = ship.passive === 'gyro' ? 1.3 : 1.0;
    const turnSpeedMult = (gatlingFiring ? 0.2 : 1.0) * gyroMult * (ship.stunTimer > 1.25 ? 0 : ship.stunTimer > 0 ? 1 - ship.stunTimer / 1.25 : 1);
    if (ship.overrideTimer <= 0 && !maneuverControlsMovement) {
      ship.ang += (ship._aiTurnDir || 0) * CFG.SHIP_TURN_SPEED * turnSpeedMult * dt;
    }

    // FRAME-LEVEL EMERGENCY: check for imminent asteroid collision every frame
    // Uses lateral thrust to slip past rather than hard turning
    let emergency = false;
    if (ship.overrideTimer <= 0 && !maneuverControlsMovement) {
    let emergAvoidX = 0, emergAvoidY = 0;
    let emergCount = 0;
    if (ship.passive !== 'drillbore' || ship.hp <= 0.5) {
      for (const ast of asteroids) {
        const d = dist(ship, ast);
        if (d > ast.r + 350) continue;
        const col = predictCollision(ship, ast, 1.0);
        if (col) {
          const toAst = angle(ship, ast);
          const urgency = 1 / (col.t + 0.05);
          emergAvoidX -= Math.cos(toAst) * urgency;
          emergAvoidY -= Math.sin(toAst) * urgency;
          emergCount++;
        }
      }
    }
    if (emergCount > 0) {
      emergency = true;
      const escapeAng = Math.atan2(emergAvoidY, emergAvoidX);
      const btRage = ship._bloodthirstyCombat ? Math.min(1, 0.35 + gameTime / 120) : 0;
      const turnMult = ship._bloodthirstyCombat ? lerp(0.45, 0.25, btRage) : 1.5;
      const turnNeeded = shortAngleDist(ship.ang, escapeAng);
      ship.ang += Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), CFG.SHIP_TURN_SPEED * turnMult * turnSpeedMult * dt);
      const strafeDir = (ship.id % 2 === 0) ? 1 : -1;
      const perpAng = ship.ang + Math.PI * 0.5 * strafeDir;
      const strafeForce = CFG.SHIP_THRUST * 0.35;
      ship.vx += Math.cos(perpAng) * strafeForce * dt;
      ship.vy += Math.sin(perpAng) * strafeForce * dt;
      ship._aiThrust = true;
    }

    // AI-level avoidance strafe
    if (!emergency && ship._avoidStrafe) {
      const strafeDir = (ship.id % 2 === 0) ? 1 : -1;
      const perpAng = ship.ang + Math.PI * 0.5 * strafeDir;
      const strength = ship._avoidStrafeStrength || 1;
      const strafeForce = CFG.SHIP_THRUST * 0.25 * strength;
      ship.vx += Math.cos(perpAng) * strafeForce * dt;
      ship.vy += Math.sin(perpAng) * strafeForce * dt;
    }

    // Thrust
    ship.thrustOn = ship._aiThrust;
    if (ship._aiThrust) {
      const thrustMult = (ship.passive === 'nitro' ? 1.3 : 1.0) * (ship.passive === 'bioHull' ? 0.9 : 1.0);
      ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * thrustMult * dt;
      ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * thrustMult * dt;
      if (Math.random() < 0.6) spawnThrustParticle(ship);
    }
    } // end override skip

    // Friction
    const speed = Math.hypot(ship.vx, ship.vy);
    const maneuverSpeedMult = ship.maneuverActive ? (ship.maneuver === 'barrelRoll' ? 1.5 : ship.maneuver === 'quickTurn' ? 1.8 : ship.maneuver === 'serpentine' ? 2.5 : ship.maneuver === 'spinOut' ? 2.5 : ship._teleportPhase === 'phasing' ? 2 : 1) : 1;
    const reflectorSlow = (ship.maneuverActive && ship.maneuver === 'reflectorShields') ? 0.7 : 1;
    const maxSpeed = CFG.SHIP_MAX_SPEED * (ship.passive === 'nitro' ? 1.4 : 1) * (ship._hyperSpeedActive ? 3 : 1) * maneuverSpeedMult * reflectorSlow;
    if (speed > maxSpeed) {
      const ratio = maxSpeed / speed;
      ship.vx *= ratio;
      ship.vy *= ratio;
    }
    ship.vx *= (1 - 0.3 * dt);
    ship.vy *= (1 - 0.3 * dt);

    // Ice slow: reduce speed by up to 50%, decaying over 4s
    if (ship.iceSlow > 0) {
      const iceFactor = 1 - 0.5 * (ship.iceSlow / 2);
      ship.vx *= iceFactor;
      ship.vy *= iceFactor;
    }

    // Move
    ship.x += ship.vx * dt;
    ship.y += ship.vy * dt;

    // World bounds (soft bounce)
    {
    if (ship.x < 0) { ship.x = 0; ship.vx = Math.abs(ship.vx) * 0.5; }
    if (ship.x > CFG.WORLD_W) { ship.x = CFG.WORLD_W; ship.vx = -Math.abs(ship.vx) * 0.5; }
    if (ship.y < 0) { ship.y = 0; ship.vy = Math.abs(ship.vy) * 0.5; }
    if (ship.y > CFG.WORLD_H) { ship.y = CFG.WORLD_H; ship.vy = -Math.abs(ship.vy) * 0.5; }
    }

    // Process burst queue (triple-guns, gatling, flamethrower)
    processBurstQueue(ship);
    // Shoot
    if (ship._aiShoot && ship.fireCooldown <= 0 && ship._teleportPhase !== 'phasing'
        && !(ship.maneuverActive && ship.maneuver === 'reflectorShields')
        && !(ship.weapon.type === 'drone' && shipDrones.some(d => d.ownerId === ship.id))) {
      let fireRate = ship.weapon.fireRate;
      // Cryo-Coolant passive: 20% faster fire rate
      if (ship.passive === 'cryoCoolant') fireRate *= 0.8;
      // Barrel Roll maneuver: 30% faster fire rate
      if (ship.maneuverActive && ship.maneuver === 'barrelRoll') fireRate *= 0.7;
      // Turret Mode: 2x fire rate
      if (ship.maneuverActive && ship.maneuver === 'turretMode') fireRate *= 0.5;
      // Panic: 3x fire rate
      if (ship.maneuverActive && ship.maneuver === 'panic') fireRate *= 0.33;
      // Rapid Fire: 2x fire rate
      if (ship.maneuverActive && ship.maneuver === 'rapidFire') fireRate *= 0.5;
      // Jam rounds debuff: up to 10x slower fire rate, decaying over 4s
      if (ship.jamSlow > 0) {
        const jamMult = 1 + 9 * (ship.jamSlow / 4);
        fireRate *= jamMult;
      }
      ship.fireCooldown = fireRate;
      // Drone weapon: spawn array instead of firing
      if (ship.weapon.type === 'drone') {
        // Only spawn if no active drones for this ship
        const hasDrones = shipDrones.some(d => d.ownerId === ship.id);
        if (!hasDrones) {
          const w = ship.weapon;
          for (let di = 0; di < w.droneCount; di++) {
            shipDrones.push({
              ownerId: ship.id,
              color: ship.color,
              x: ship.x, y: ship.y,
              vx: 0, vy: 0,
              ang: 0,
              orbitAngle: (Math.PI * 2 / w.droneCount) * di,
              orbitRadius: ship.r * 3,
              r: 5,
              spawnProgress: 0, // 0→1 over 0.3s, controls size and orbit radius
              damage: w.damage,
              life: w.life,
              armTimer: w.armTime,
              state: 'orbiting', // orbiting → armed → pursuing
              launchDelay: di * w.launchInterval, // stagger launches
              speed: w.speed,
              turnRate: w.turnRate,
              orbitSpeed: w.orbitSpeed,
            });
          }
          ship.fireCooldown = 0.5; // small delay, real cooldown set when all drones gone
        }
      } else {
        fireWeapon(ship);
      }

      // Fierce passive: thin ellipse shockwave from front when firing
      if (ship.passive === 'fierce') {
        const fx = ship.x + Math.cos(ship.ang) * ship.r;
        const fy = ship.y + Math.sin(ship.ang) * ship.r;
        shockwaves.push({ x: fx, y: fy, r: 0, maxR: 30, life: 0.2, maxLife: 0.2, color: ship.color, ellipse: true, ellipseAng: ship.ang });
      }

      // Cryo-Coolant passive: small particles from ship nose, perpendicular to fire direction
      if (ship.passive === 'cryoCoolant') {
        const fx = ship.x + Math.cos(ship.ang) * ship.r;
        const fy = ship.y + Math.sin(ship.ang) * ship.r;
        const perp = ship.ang + Math.PI / 2;
        for (let ci = 0; ci < 3; ci++) {
          const side = ci === 0 ? -1 : ci === 1 ? 1 : (Math.random() < 0.5 ? -1 : 1);
          particles.push({
            x: fx, y: fy,
            vx: Math.cos(perp) * side * rand(25, 55),
            vy: Math.sin(perp) * side * rand(25, 55),
            life: 0.2, maxLife: 0.2,
            color: ship.color, size: rand(1, 2),
          });
        }
      }
    }
  }

  // Update bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    // ── Special bullet behaviors ──
    // Homing missiles
    if (b.type === 'homing') {
      if (!b.armed) {
        b.armTime -= dt;
        if (b.armTime <= 0) {
          b.armed = true;
          b.vx = Math.cos(b.fireAng) * 300;
          b.vy = Math.sin(b.fireAng) * 300;
        }
      } else {
        let closest = null, cDist = Infinity;
        for (const s of ships) {
          if (!s.alive || s.id === b.owner) continue;
          if (b.ownerTeam > 0 && s.team === b.ownerTeam) continue;
          const d = dist(b, s);
          if (d < cDist) { cDist = d; closest = s; }
        }
        if (closest) {
          const tAng = angle(b, closest);
          const cAng = Math.atan2(b.vy, b.vx);
          const daTurn = shortAngleDist(cAng, tAng);
          const turnRate = 1.5;
          const turn = Math.sign(daTurn) * Math.min(Math.abs(daTurn), turnRate * dt);
          const nAng = cAng + turn;
          const spd = Math.hypot(b.vx, b.vy);
          b.vx = Math.cos(nAng) * spd;
          b.vy = Math.sin(nAng) * spd;
        }
      }
    }
    // Chaotic shot — random walk angular velocity
    if (b.curveRate) {
      const spd = Math.hypot(b.vx, b.vy);
      const cAng = Math.atan2(b.vy, b.vx);
      b.curveRate += rand(-10, 10) * dt;
      b.curveRate *= 0.97;
      const nAng = cAng + b.curveRate * dt;
      b.vx = Math.cos(nAng) * spd;
      b.vy = Math.sin(nAng) * spd;
    }
    // Snake shot — sine wave oscillation
    if (b.sineAmp) {
      const age = gameTime - b.spawnTime;
      // Growing amplitude for double helix
      const ampMult = b.helixGrow ? (1 + age * 1.5) : 1;
      const amp = b.sineAmp * ampMult * b.helixSide || b.sineAmp * ampMult;
      const angVel = amp * Math.cos(age * b.sineFreq);
      const spd = Math.hypot(b.vx, b.vy);
      const cAng = Math.atan2(b.vy, b.vx);
      const nAng = cAng + angVel * dt;
      b.vx = Math.cos(nAng) * spd;
      b.vy = Math.sin(nAng) * spd;
    }

    // Boomerang — arc back after 75% lifetime
    if (b.boomerang && b.maxLife) {
      const elapsed = b.maxLife - b.life;
      if (elapsed >= b.maxLife * 0.75) {
        if (!b.boomeranged) {
          b.boomeranged = true;
          const cAng = Math.atan2(b.vy, b.vx);
          b.boomerangTarget = cAng + Math.PI + rand(-Math.PI/2, Math.PI/2);
        }
        const spd = Math.hypot(b.vx, b.vy);
        const cAng = Math.atan2(b.vy, b.vx);
        const turnNeeded = shortAngleDist(cAng, b.boomerangTarget);
        const turnRate = 8; // radians/sec — fast arc
        const turn = Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), turnRate * dt);
        const nAng = cAng + turn;
        const newSpd = Math.min(spd + 200 * dt, 450); // accelerate during arc
        b.vx = Math.cos(nAng) * newSpd;
        b.vy = Math.sin(nAng) * newSpd;
      }
    }

    // Cyclone — orbit around moving center
    if (b.cyclone) {
      const age = gameTime - b.spawnTime;
      // Center point moves forward
      b.cycloneCx += Math.cos(b.cycloneFireAng) * b.cycloneSpeed * dt * 0.85;
      b.cycloneCy += Math.sin(b.cycloneFireAng) * b.cycloneSpeed * dt * 0.85;
      // Orbit expands over time, varied per bullet
      b.cycloneAng += 6 * dt;
      const radius = (15 + age * 60) * (b.cycloneRadiusMult || 1);
      const targetX = b.cycloneCx + Math.cos(b.cycloneAng) * radius;
      const targetY = b.cycloneCy + Math.sin(b.cycloneAng) * radius;
      // Smoothly blend position toward orbit target
      const blend = Math.min(1, 12 * dt);
      const newX = lerp(b.x, targetX, blend);
      const newY = lerp(b.y, targetY, blend);
      // Set velocity from actual movement (for trails/collision)
      b.vx = (newX - b.x) / Math.max(dt, 0.001);
      b.vy = (newY - b.y) / Math.max(dt, 0.001);
      b.x = newX;
      b.y = newY;
    }

    // Lightning — zigzag and split
    if (b.lightning) {
      b.lightningZigTimer -= dt;
      if (b.lightningZigTimer <= 0) {
        b.lightningZigTimer = rand(0.03, 0.07);
        // Zigzag: deflect within ±80° of original fire direction
        const spd = Math.hypot(b.vx, b.vy);
        const maxDev = 80 * Math.PI / 180; // 80° each side = 160° cone
        const newAng = b.lightningOrigAng + rand(-maxDev, maxDev);
        b.vx = Math.cos(newAng) * spd;
        b.vy = Math.sin(newAng) * spd;
      }
      // Split if splits remaining
      if (b.lightningSplitsLeft > 0) {
        const elapsed = (b.maxLife || 0.4) - b.life;
        const splitFrac = b.lightningSplitsLeft === 2 ? rand(0.25, 0.45) : rand(0.4, 0.7);
        const splitTime = (b.maxLife || 0.4) * splitFrac;
        if (elapsed >= splitTime) {
          b.lightningSplitsLeft--;
          const spd = Math.hypot(b.vx, b.vy);
          const maxDev = 80 * Math.PI / 180;
          const splitAng = b.lightningOrigAng + rand(-maxDev, maxDev);
          bullets.push({
            x: b.x, y: b.y,
            vx: Math.cos(splitAng) * spd,
            vy: Math.sin(splitAng) * spd,
            life: b.life,
            owner: b.owner, color: b.color,
            damage: b.damage, type: 'lightning',
            size: b.size,
            detonateTime: null, contactDetonate: false,
            isShrapnel: false, armed: true, armTime: 0,
            fireAng: b.fireAng, spawnTime: b.spawnTime,
            curveRate: 0, sineAmp: 0, sineFreq: 0,
            boomerang: false, maxLife: null,
            helixSide: 0, helixId: null, helixGrow: false,
            cyclone: false, cycloneAng: 0, cycloneCx: 0, cycloneCy: 0,
            cycloneFireAng: 0, cycloneSpeed: 0, cycloneId: null, cycloneRadiusMult: 1,
            lightning: true,
            lightningZigTimer: rand(0.03, 0.07),
            lightningOrigAng: b.lightningOrigAng,
            lightningSplitsLeft: b.lightningSplitsLeft, // child inherits remaining splits
            ownerPassive: b.ownerPassive,
          });
        }
      }
    }

    if (!b.cyclone) {
      b.x += b.vx * dt;
      b.y += b.vy * dt;
    }
    b.life -= dt;

    // Detonation timer (grenade fuse, scrap split)
    if (b.detonateTime !== null && !b.isShrapnel) {
      b.detonateTime -= dt;
      if (b.detonateTime <= 0) {
        detonateBullet(b);
        bullets.splice(i, 1);
        continue;
      }
    }

    // Concussive shell split
    if (b.concussive) {
      b.concussiveTimer -= dt;
      if (b.concussiveTimer <= 0) {
        const w = WEAPON_DEFS.concussive;
        // Spawn 4 split projectiles in random directions
        for (let s = 0; s < w.splitCount; s++) {
          const splitAng = Math.random() * Math.PI * 2;
          const splitSpd = w.splitSpeed * rand(0.7, 1.3);
          bullets.push(makeBullet({id: b.owner, ang: splitAng, r: 6, x: b.x, y: b.y, vx: 0, vy: 0,
            weapon: {life: w.splitLife, damage: w.splitDmg, type: 'concussive'}},
            b.x, b.y,
            Math.cos(splitAng) * splitSpd + b.vx * 0.3,
            Math.sin(splitAng) * splitSpd + b.vy * 0.3,
            {life: w.splitLife, damage: w.splitDmg, concussive: false, size: 2, color: b.color}));
        }
        // Square particles at split site
        for (let p = 0; p < 10; p++) {
          particles.push({
            x: b.x + rand(-8, 8), y: b.y + rand(-8, 8),
            vx: rand(-60, 60), vy: rand(-60, 60),
            life: rand(0.2, 0.5), maxLife: 0.5,
            color: b.color, size: rand(2, 4), square: true,
          });
        }
        spawnExplosion(b.x, b.y, b.color, 6, 40);
        bullets.splice(i, 1);
        continue;
      }
    }

    // Bullet trail particle — scale spawn rate with finale slowdown
    if (finaleSlowMo < 1 && Math.random() > finaleSlowMo) { /* skip trail this frame */ }
    else {
    const _preTrailCount = particles.length;
    if (b.type === 'flamethrower') {
      // Flamethrower: dense flickering flame particles
      const age = gameTime - b.spawnTime;
      const nearShip = age < 0.2;
      const spawnCount = nearShip ? 1 : 3;
      const spawnChance = nearShip ? 0.3 : 1;
      if (Math.random() < spawnChance) {
        for (let tp = 0; tp < spawnCount; tp++) {
          const tLife = rand(0.15, 0.35);
          const fade = Math.max(0.3, 1 - age / (b.life + age));
          particles.push({
            x: b.x + rand(-4, 4),
            y: b.y + rand(-4, 4),
            vx: b.vx * rand(-0.05, 0.1) + rand(-20, 20),
            vy: b.vy * rand(-0.05, 0.1) + rand(-20, 20),
            life: tLife,
            maxLife: tLife,
            color: b.color,
            size: rand(1.5, 4) * fade,
          });
        }
      }
    } else if (b.sineAmp && b.type !== 'doublehelix') {
      // Snake bullets: dense, long-lasting glowing trail
      for (let tp = 0; tp < 2; tp++) {
        const tLife = rand(0.4, 0.8);
        particles.push({
          x: b.x + rand(-3, 3),
          y: b.y + rand(-3, 3),
          vx: -b.vx * 0.02 + rand(-6, 6),
          vy: -b.vy * 0.02 + rand(-6, 6),
          life: tLife,
          maxLife: tLife,
          color: b.color,
          size: rand(1.5, 3),
        });
      }
    } else if (b.type === 'alternating') {
      // Alternating lasers: small, lingering trail
      if (Math.random() < 0.7) {
        const tLife = rand(0.2, 0.4);
        particles.push({
          x: b.x + rand(-1, 1),
          y: b.y + rand(-1, 1),
          vx: -b.vx * 0.03 + rand(-3, 3),
          vy: -b.vy * 0.03 + rand(-3, 3),
          life: tLife,
          maxLife: tLife,
          color: b.color,
          size: rand(0.8, 1.5),
        });
      }
    } else if (b.type === 'sniper') {
      // Sniper: store trail positions for beam effect
      if (!b.trail) b.trail = [];
      b.trail.push({x: b.x, y: b.y, life: 0.35});
      // Age and prune trail
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'homing' && !b.isShrapnel) {
      // Homing missiles: smoky particle trail
      const tLife = rand(0.25, 0.5);
      particles.push({
        x: b.x + rand(-2, 2),
        y: b.y + rand(-2, 2),
        vx: -b.vx * 0.04 + rand(-10, 10),
        vy: -b.vy * 0.04 + rand(-10, 10),
        life: tLife,
        maxLife: tLife,
        color: b.color,
        size: rand(1, 2.5),
      });
      // Intermittent mini shockwaves
      if (Math.random() < 0.1) {
        shockwaves.push({
          x: b.x, y: b.y,
          r: 0, maxR: rand(10, 18),
          life: 0.4,
          color: b.color
        });
      }
    } else if (b.type === 'chaotic') {
      // Chaotic: store trail for perpendicular line effect
      if (!b.trail) b.trail = [];
      if (Math.random() < 0.4) {
        b.trail.push({x: b.x, y: b.y, life: 0.25, ang: Math.atan2(b.vy, b.vx)});
      }
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'doublehelix') {
      // Double helix: snake-like particle trail
      for (let tp = 0; tp < 2; tp++) {
        const tLife = rand(0.4, 0.8);
        particles.push({
          x: b.x + rand(-3, 3),
          y: b.y + rand(-3, 3),
          vx: -b.vx * 0.02 + rand(-6, 6),
          vy: -b.vy * 0.02 + rand(-6, 6),
          life: tLife,
          maxLife: tLife,
          color: b.color,
          size: rand(1.5, 3),
        });
      }
      // Cross-link lines between helix pair
      if (!b.trail) b.trail = [];
      const partner = bullets.find(o => o !== b && o.helixId === b.helixId);
      if (partner && Math.random() < 0.3) {
        const mx = (b.x + partner.x) / 2;
        const my = (b.y + partner.y) / 2;
        const linkAng = Math.atan2(partner.y - b.y, partner.x - b.x);
        const linkLen = Math.hypot(partner.x - b.x, partner.y - b.y) / 2;
        b.trail.push({x: mx, y: my, life: 0.3, ang: linkAng, len: linkLen});
      }
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'cyclone') {
      // Cyclone: long particle trails
      const tLife = rand(0.5, 1.0);
      particles.push({
        x: b.x + rand(-2, 2),
        y: b.y + rand(-2, 2),
        vx: rand(-8, 8),
        vy: rand(-8, 8),
        life: tLife,
        maxLife: tLife,
        color: b.color,
        size: rand(1, 2),
      });
    } else if (b.type === 'crossshot') {
      // Cross-shot: beam trail like sniper
      if (!b.trail) b.trail = [];
      b.trail.push({x: b.x, y: b.y, life: 0.25});
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'lightning') {
      // Lightning: beam trail that follows the zigzag path
      if (!b.trail) b.trail = [];
      b.trail.push({x: b.x, y: b.y, life: 0.4});
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'concussive' && b.concussive) {
      // Concussive: small square particles clustered around the shell
      if (Math.random() < 0.6) {
        const tLife = rand(0.15, 0.3);
        particles.push({
          x: b.x + rand(-4, 4), y: b.y + rand(-4, 4),
          vx: rand(-15, 15), vy: rand(-15, 15),
          life: tLife, maxLife: tLife,
          color: b.color, size: rand(1.5, 3), square: true,
        });
      }
    } else if (Math.random() < 0.5) {
      const tLife = rand(0.08, 0.15);
      particles.push({
        x: b.x + rand(-2, 2),
        y: b.y + rand(-2, 2),
        vx: -b.vx * 0.05 + rand(-8, 8),
        vy: -b.vy * 0.05 + rand(-8, 8),
        life: tLife,
        maxLife: tLife,
        color: b.color,
        size: rand(1, 2),
      });
    }
    // Tag trail particles from incendiary bullets
    if (b.incId && particles.length > _preTrailCount) {
      for (let pi = _preTrailCount; pi < particles.length; pi++) {
        particles[pi].incId = b.incId;
        particles[pi].incOwner = b.owner;
        particles[pi].incOwnerTeam = b.ownerTeam || 0;
      }
    }

    // Scope passive: bullet particle trails last twice as long
    if (b.ownerPassive === 'scope') {
      // Extend newly spawned trail particles
      for (let pi = _preTrailCount; pi < particles.length; pi++) {
        particles[pi].life *= 2;
        particles[pi].maxLife *= 2;
      }
      // Extend trail points (beam-style trails)
      if (b.trail) {
        for (const tp of b.trail) {
          if (tp._scoped) continue;
          tp.life *= 2;
          tp._scoped = true;
        }
      }
    }

    // Spark Drive passive: weapon particles double brightness (larger + brighter)
    if (b.ownerPassive === 'sparkDrive') {
      for (let pi = _preTrailCount; pi < particles.length; pi++) {
        particles[pi].size *= 1.5;
      }
    }

    // Debuff passive aura trails — particles perpendicular to bullet path
    const debuffColors = {
      iceRounds: '#55bbff', jamRounds: '#ff4444', stunShock: '#ffff44',
      override: '#8844dd', blindRounds: '#ff8800',
    };
    if (debuffColors[b.ownerPassive]) {
      const bSpd = Math.hypot(b.vx, b.vy);
      // Faster bullets spawn trails more reliably (lightning at 1600 u/s needs help)
      let spawnChance = Math.min(0.95, 0.5 + bSpd / 3000);
      if (b.ownerPassive === 'stunShock') spawnChance *= 0.5; // half density for stun
      if (bSpd > 10 && Math.random() < spawnChance) {
        const perpAng = Math.atan2(b.vy, b.vx) + Math.PI * 0.5;
        const side = Math.random() < 0.5 ? 1 : -1;
        if (b.ownerPassive === 'stunShock') {
          // Mini lightning arc: 3-4 jagged segments forking out perpendicular
          const arcLen = rand(15, 35);
          const segments = randInt(3, 4);
          const arcPoints = [{x: 0, y: 0}];
          for (let s = 1; s <= segments; s++) {
            const t = s / segments;
            // Main direction is perpendicular outward with jitter
            arcPoints.push({
              x: Math.cos(perpAng) * arcLen * t * side + rand(-6, 6),
              y: Math.sin(perpAng) * arcLen * t * side + rand(-6, 6)
            });
          }
          particles.push({
            x: b.x, y: b.y, vx: b.vx * 0.1, vy: b.vy * 0.1,
            life: rand(0.12, 0.22), maxLife: 0.22,
            color: '#ffff44', size: 1.5,
            isArc: true, arcPoints,
          });
        } else if (b.ownerPassive === 'iceRounds') {
          // Ice crystals: diamonds and snowflakes
          const spread = rand(6, 16);
          const px = b.x + Math.cos(perpAng) * spread * side;
          const py = b.y + Math.sin(perpAng) * spread * side;
          const driftSpd = rand(15, 45);
          const iceType = Math.random() < 0.6 ? 'diamond' : 'snowflake';
          particles.push({
            x: px, y: py,
            vx: Math.cos(perpAng) * driftSpd * side + b.vx * 0.05,
            vy: Math.sin(perpAng) * driftSpd * side + b.vy * 0.05,
            life: rand(0.2, 0.4), maxLife: 0.4,
            color: '#55bbff', size: rand(2, 4.5),
            isDiamond: iceType === 'diamond', isSnowflake: iceType === 'snowflake',
            spinAng: rand(0, Math.PI * 2),
          });
        } else {
          const spread = rand(4, (b.size || 2) + 10);
          const px = b.x + Math.cos(perpAng) * spread * side;
          const py = b.y + Math.sin(perpAng) * spread * side;
          const driftSpd = rand(8, 30);
          particles.push({
            x: px, y: py,
            vx: Math.cos(perpAng) * driftSpd * side + b.vx * 0.1,
            vy: Math.sin(perpAng) * driftSpd * side + b.vy * 0.1,
            life: rand(0.12, 0.25), maxLife: 0.25,
            color: debuffColors[b.ownerPassive],
            size: rand(1, 2.5),
          });
        }
      }
    }
    } // end finale trail slowdown

    if (b.life <= 0 || b.x < -50 || b.x > CFG.WORLD_W + 50 || b.y < -50 || b.y > CFG.WORLD_H + 50) {
      if (b.type === 'lightning' && b.trail && b.trail.length > 0) {
        orphanTrails.push({trail: b.trail, color: b.color});
      }
      bullets.splice(i, 1);
      continue;
    }

    // Absorber rounds: this bullet deletes enemy bullets it touches
    const absOwner = shipById[b.owner];
    if (absOwner && absOwner.passive === 'absorber') {
      for (let j = bullets.length - 1; j >= 0; j--) {
        if (j === i) continue;
        const ob = bullets[j];
        if (ob.owner === b.owner) continue;
        if (dist(b, ob) < 20) {
          spawnExplosion(ob.x, ob.y, '#fff', 4, 30);
          bullets.splice(j, 1);
          if (j < i) i--; // adjust index
        }
      }
    }

    // Bouncy Shot: ricochet both bullets on collision
    const bncOwner = shipById[b.owner];
    if (bncOwner && bncOwner.passive === 'bouncyShot' && (gameTime - (b._bounceTime || 0)) > 0.1) {
      for (let j = 0; j < bullets.length; j++) {
        if (j === i) continue;
        const ob = bullets[j];
        if (ob.owner === b.owner) continue;
        if ((gameTime - (ob._bounceTime || 0)) < 0.1) continue; // skip if just bounced
        if (dist(b, ob) < 12) {
          // Collision axis — handle degenerate overlap
          let cx = b.x - ob.x, cy = b.y - ob.y;
          let cd = Math.sqrt(cx * cx + cy * cy);
          if (cd < 0.5) {
            // Nearly overlapping — use bullet velocity as fallback
            const ba = Math.atan2(b.vy, b.vx);
            cx = Math.cos(ba); cy = Math.sin(ba); cd = 1;
          }
          const nx = cx / cd, ny = cy / cd;
          bounceBullet(b, nx, ny);
          bounceBullet(ob, -nx, -ny, true); // no double explosion
          break;
        }
      }
    }

    // Bullet vs asteroid
    let bulletHit = false;
    let _hitAst = null;
    for (let j = asteroids.length - 1; j >= 0; j--) {
      const ast = asteroids[j];
      if (dist(b, ast) < ast.r) {
        _hitAst = {x: ast.x, y: ast.y, r: ast.r};
        const explodeScale = ast.r / 50;
        spawnExplosion(ast.x, ast.y, 'rgba(255,255,255,0.6)', Math.floor(8 * explodeScale), 100 * explodeScale);
        playAsteroidBreak();
        const ownerObl = shipById[b.owner];
        if (ownerObl && ownerObl.passive === 'obliterator') {
          // Obliterator: no fragments, emit 5 projectiles
          for (let k = 0; k < 5; k++) {
            const a = rand(0, Math.PI * 2);
            const sp = 400;
            bullets.push(makeBullet(ownerObl, ast.x, ast.y, Math.cos(a) * sp, Math.sin(a) * sp,
              { life: 0.8, damage: 2, type: 'basic', size: 2, isShrapnel: true, fireAng: a }));
          }
          spawnExplosion(ast.x, ast.y, ownerObl.color, 15, 120);
        } else if (ast.sizeIdx < 3) {
          const spread = ast.r * 0.4;
          for (let k = 0; k < 2; k++) {
            asteroids.push(spawnAsteroid(ast.sizeIdx + 1, ast.x + rand(-spread, spread), ast.y + rand(-spread, spread)));
          }
        } else if (CFG.RESPAWN_ASTEROIDS && asteroids.length < CFG.NUM_ASTEROIDS * 1.3) {
          const spawnChance = 0.25 + Math.min(0.35, gameTime / 90);
          if (Math.random() < spawnChance) {
            const edge = randInt(0, 3);
            const ex = edge === 0 ? 0 : edge === 2 ? CFG.WORLD_W : rand(0, CFG.WORLD_W);
            const ey = edge === 1 ? 0 : edge === 3 ? CFG.WORLD_H : rand(0, CFG.WORLD_H);
            asteroids.push(spawnAsteroid(1, ex, ey));
          }
        }
        asteroids.splice(j, 1);
        // Grenade contact detonation on asteroid
        if (b.contactDetonate && !b.isShrapnel) detonateBullet(b);
        bulletHit = true;
        break;
      }
    }

    if (bulletHit) {
      if (b.type === 'lightning' && b.trail && b.trail.length > 0) {
        orphanTrails.push({trail: b.trail, color: b.color});
      }
      removeHelixPartner(b);
      // Piercing passive: bullet survives hitting an asteroid
      const ownerShip = shipById[b.owner];
      if (ownerShip && ownerShip.passive === 'bouncyShot') {
        // Bounce off asteroid surface
        const ha = _hitAst;
        const nx = (b.x - ha.x), ny = (b.y - ha.y);
        const nd = Math.sqrt(nx * nx + ny * ny) || 1;
        bounceBullet(b, nx / nd, ny / nd);
      } else if (!(ownerShip && ownerShip.passive === 'piercing')) {
        bullets.splice(i, 1);
        continue;
      }
    }

    // Bullet vs ship
    for (const ship of ships) {
      if (!ship.alive || ship.id === b.owner || ship.invuln > 0) continue;
      const isFriendly = b.ownerTeam > 0 && ship.team === b.ownerTeam;
      const bDist = dist(b, ship);

      // Near-miss debuff detection: 2x hit radius applies effect only (no damage) — skip for friendlies
      const attacker = shipById[b.owner];
      if (attacker && !isFriendly && bDist < (ship.r + 4) * 2 && bDist >= ship.r + 4) {
        if (attacker.passive === 'blindRounds') ship.blindTimer = 3;
        if (attacker.passive === 'iceRounds') { ship.iceSlow = 2; ship.iceDotTimer = 2.0; }
        if (attacker.passive === 'jamRounds') ship.jamSlow = 4;
        if (attacker.passive === 'stunShock') ship.stunTimer = 1.75;
        if (attacker.passive === 'override') { ship.overrideTimer = 2; ship.overrideTurnDir = Math.random() < 0.5 ? -1 : 1; }
        if (['blindRounds','iceRounds','jamRounds','stunShock','override'].includes(attacker.passive)) playDebuff();
      }

      if (bDist < ship.r + 4) {
        // Friendly fire: scale damage by ramp multiplier
        const ffMult = isFriendly ? friendlyFireMult() : 1;

        // Shield passive: absorb first hit (skip for 0-damage friendly hits)
        if (ship.shieldActive && ffMult > 0) {
          ship.shieldActive = false;
          ship.hpBarTimer = 0.75;
          const shieldColor = b.color || '#fff';
          spawnExplosion(b.x, b.y, shieldColor, 8, 50);
          // Hex flash — 6 line particles radiating outward in hex pattern
          for (let h = 0; h < 6; h++) {
            const ha = (h / 6) * Math.PI * 2;
            const hSpd = rand(80, 150);
            particles.push({
              x: ship.x + Math.cos(ha) * ship.r * 0.5,
              y: ship.y + Math.sin(ha) * ship.r * 0.5,
              vx: Math.cos(ha) * hSpd, vy: Math.sin(ha) * hSpd,
              life: 0.3, maxLife: 0.3,
              color: ship.color, size: 1,
              isLine: true, lineAng: ha + Math.PI / 2, lineLen: rand(8, 14),
            });
          }
          shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 60, life: 0.4, color: ship.color });
          // Still remove bullet (unless piercing)
        } else {
          // Shotgun damage decay: full damage for first 50% of life, then decays to 0.5 at max range
          let bulletDmg = b.damage || 1;
          if (b.type === 'shotgun') {
            const age = gameTime - b.spawnTime;
            const maxLife = age + b.life; // original total life
            const halfLife = maxLife * 0.5;
            if (age > halfLife) {
              const decayT = (age - halfLife) / (maxLife - halfLife); // 0→1 over second half
              bulletDmg = bulletDmg * (1 - decayT * 0.5); // full → 50% of base
              bulletDmg = Math.max(0.5, bulletDmg); // floor at 0.5
            }
          }
          const dmg = bulletDmg * (ship.passive === 'titanium' ? 0.75 : 1) * ffMult;
          if (dmg <= 0) {
            // Zero damage friendly hit — still consume the bullet but no damage/effects
            const _owner = shipById[b.owner];
            if (!(_owner && (_owner.passive === 'piercing' || _owner.passive === 'bouncyShot'))) {
              bullets.splice(i, 1); i--;
            }
            break;
          }
          // Incendiary: 50% instant, 50% as burn DoT over 2s
          if (b.ownerPassive === 'incendiary') {
            ship.hp -= dmg * 0.5;
            ship.burnTimer = 2.0;
            ship.burnDps = (dmg * 0.5) / 2.0; // remaining 50% over 2s
          } else {
            ship.hp -= dmg;
          }
          ship.lastAttacker = b.owner;
          ship.lastAttackerTime = gameTime;
          ship.hpBarTimer = 0.75;
          const explodeSize = Math.min(12, 4 + dmg * 2);
          spawnExplosion(b.x, b.y, ship.color, explodeSize, 60 + dmg * 10);
          // Impact sparks — ricochet off at angles from bullet direction
          const bAng = Math.atan2(b.vy, b.vx);
          const impactAng = Math.atan2(b.y - ship.y, b.x - ship.x); // surface normal
          for (let sp = 0; sp < 4; sp++) {
            const sparkAng = impactAng + rand(-0.8, 0.8);
            const sparkSpd = rand(120, 280);
            particles.push({
              x: b.x, y: b.y,
              vx: Math.cos(sparkAng) * sparkSpd,
              vy: Math.sin(sparkAng) * sparkSpd,
              life: rand(0.1, 0.25), maxLife: 0.25,
              color: '#fff', size: rand(0.8, 1.5),
            });
          }
          playShipHit();
          // Hit Invincibility passive: 2s invuln after taking damage (16s cooldown)
          if (ship.passive === 'hitInvuln' && ship.hp > 0 && ship.hitInvulnCooldown <= 0) {
            ship.invuln = 1;
            ship.hitInvulnCooldown = 8;
            ship.iceSlow = 0; ship.jamSlow = 0; ship.stunTimer = 0;
            ship.overrideTimer = 0; ship.blindTimer = 0;
            ship.burnTimer = 0; ship.burnDps = 0; ship.iceDotTimer = 0;
          }
          // Ice/Jam rounds: apply debuff based on attacker's passive
          const attacker = shipById[b.owner];
          if (attacker) {
            if (attacker.passive === 'iceRounds') { ship.iceSlow = 2; ship.iceDotTimer = 2.0; }
            if (attacker.passive === 'jamRounds') ship.jamSlow = 4;
            if (attacker.passive === 'stunShock') ship.stunTimer = 1.75;
            if (attacker.passive === 'override') { ship.overrideTimer = 2; ship.overrideTurnDir = Math.random() < 0.5 ? -1 : 1; }
            if (attacker.passive === 'blindRounds') ship.blindTimer = 3;
            if (['blindRounds','iceRounds','jamRounds','stunShock','override','incendiary'].includes(attacker.passive)) playDebuff();
          }
          if (ship.hp <= 0) {
            killShip(ship, b.owner);
          }
        }
        // Grenade contact detonation on ship
        if (b.contactDetonate && !b.isShrapnel) detonateBullet(b);
        if (b.type === 'lightning' && b.trail && b.trail.length > 0) {
          orphanTrails.push({trail: b.trail, color: b.color});
        }
        removeHelixPartner(b);
        // Piercing passive: bullet survives hitting a ship
        const ownerShip = shipById[b.owner];
        if (ownerShip && ownerShip.passive === 'bouncyShot') {
          // Bounce off ship surface
          const nx = (b.x - ship.x), ny = (b.y - ship.y);
          const nd = Math.sqrt(nx * nx + ny * ny) || 1;
          bounceBullet(b, nx / nd, ny / nd);
        } else if (!(ownerShip && ownerShip.passive === 'piercing')) {
          bullets.splice(i, 1);
        }
        break;
      }
    }
  }

  // Age orphan trails (lightning beams that persist after bullet death)
  for (let i = orphanTrails.length - 1; i >= 0; i--) {
    const ot = orphanTrails[i];
    for (let t = ot.trail.length - 1; t >= 0; t--) {
      ot.trail[t].life -= dt;
      if (ot.trail[t].life <= 0) ot.trail.splice(t, 1);
    }
    if (ot.trail.length === 0) orphanTrails.splice(i, 1);
  }

  // Ship vs asteroid collision
  for (const ship of ships) {
    if (!ship.alive || ship.invuln > 0) continue;
    for (let j = asteroids.length - 1; j >= 0; j--) {
      const ast = asteroids[j];
      if (dist(ship, ast) < ship.r + ast.r * 0.85) {
        // Drillbore passive: smash through asteroids unharmed
        if (ship.passive === 'drillbore') {
          // Drillbore: smash through but take 10% chip damage
          const chipDmg = 0.4;
          ship.hp -= chipDmg;
          ship.hpBarTimer = 0.75;
          spawnExplosion(ast.x, ast.y, ship.color, 12, 80);
          playAsteroidBreak();
          if (ship.hp <= 0) killShip(ship, -1);
        // Shield passive: absorb asteroid hit
        } else if (ship.shieldActive) {
          ship.shieldActive = false;
          ship.hpBarTimer = 0.75;
          spawnExplosion(ship.x, ship.y, '#fff', 12, 80);
          shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 60, life: 0.4, color: '#fff' });
        } else {
          const astDmg = ship.passive === 'flagship' ? 3 : 10;
          ship.hp -= astDmg * (ship.passive === 'titanium' ? 0.75 : 1);
          ship.hpBarTimer = 0.75;
          spawnExplosion(ship.x, ship.y, 'rgba(255,255,255,0.6)', 10, 80);
          playShipHit();
          if (ship.passive === 'hitInvuln' && ship.hp > 0 && ship.hitInvulnCooldown <= 0) {
            ship.invuln = 1;
            ship.hitInvulnCooldown = 8;
            ship.iceSlow = 0; ship.jamSlow = 0; ship.stunTimer = 0;
            ship.overrideTimer = 0; ship.blindTimer = 0;
            ship.burnTimer = 0; ship.burnDps = 0; ship.iceDotTimer = 0;
          }
          if (ship.hp <= 0) {
            killShip(ship, -1);
          }
        }
        // Destroy asteroid too
        if (ast.sizeIdx < 3) {
          const spread = ast.r * 0.4;
          for (let k = 0; k < 2; k++) {
            asteroids.push(spawnAsteroid(ast.sizeIdx + 1, ast.x + rand(-spread, spread), ast.y + rand(-spread, spread)));
          }
        }
        asteroids.splice(j, 1);
        break;
      }
    }
  }

  // Ship vs ship collision — enemies die, friendlies bounce
  for (let i = 0; i < ships.length; i++) {
    const a = ships[i];
    if (!a.alive || a._teleportPhase === 'phasing') continue;
    a._friendlyBounceTimer = Math.max(0, (a._friendlyBounceTimer || 0) - dt);
    for (let j = i + 1; j < ships.length; j++) {
      const b = ships[j];
      if (!b.alive || b._teleportPhase === 'phasing') continue;
      if (dist(a, b) >= a.r + b.r) continue;

      const isFriendly = a.team > 0 && a.team === b.team;

      if (isFriendly) {
        // Friendly collision: bounce off each other (skip if recently bounced)
        if (a._friendlyBounceTimer > 0 && b._friendlyBounceTimer > 0) continue;

        // Separate ships
        const cx = (a.x + b.x) / 2, cy = (a.y + b.y) / 2;
        const sepAng = Math.atan2(a.y - b.y, a.x - b.x);
        const overlap = (a.r + b.r) - dist(a, b);
        a.x += Math.cos(sepAng) * overlap * 0.5;
        a.y += Math.sin(sepAng) * overlap * 0.5;
        b.x -= Math.cos(sepAng) * overlap * 0.5;
        b.y -= Math.sin(sepAng) * overlap * 0.5;

        // Bounce velocities
        const bounceSpeed = 120;
        a.vx = Math.cos(sepAng) * bounceSpeed;
        a.vy = Math.sin(sepAng) * bounceSpeed;
        b.vx = -Math.cos(sepAng) * bounceSpeed;
        b.vy = -Math.sin(sepAng) * bounceSpeed;

        // Apply ramping friendly fire damage (3 base damage)
        const ffDmg = 3 * friendlyFireMult();
        if (ffDmg > 0) {
          a.hp -= ffDmg * (a.passive === 'titanium' ? 0.75 : 1);
          b.hp -= ffDmg * (b.passive === 'titanium' ? 0.75 : 1);
          a.hpBarTimer = 0.5;
          b.hpBarTimer = 0.5;
          if (a.hp <= 0 && a.alive) killShip(a, b.id);
          if (b.hp <= 0 && b.alive) killShip(b, a.id);
        }

        // Small spark particles at contact point
        for (let k = 0; k < 6; k++) {
          const pa = rand(0, Math.PI * 2);
          const sp = rand(30, 80);
          particles.push({ x:cx, y:cy, vx:Math.cos(pa)*sp, vy:Math.sin(pa)*sp, life:rand(0.15,0.4), maxLife:0.4, color:'#fff', size:rand(0.5,1.5) });
        }

        // Cooldown to prevent repeat bouncing
        a._friendlyBounceTimer = 0.2;
        b._friendlyBounceTimer = 0.2;
      } else {
        // Enemy collision — original lethal behavior
        const mx = (a.x + b.x) / 2;
        const my = (a.y + b.y) / 2;
        for (let k = 0; k < 20; k++) {
          const pa = rand(0, Math.PI * 2);
          const sp = rand(20, 150);
          particles.push({ x:mx, y:my, vx:Math.cos(pa)*sp, vy:Math.sin(pa)*sp, life:rand(0.3,1.2), maxLife:1.2, color:'#fff', size:rand(1,3) });
        }
        spawnExplosion(a.x, a.y, a.color, 15, 100);
        spawnExplosion(b.x, b.y, b.color, 15, 100);
        playExplosion();
        const aDrill = a.passive === 'drillbore';
        const bDrill = b.passive === 'drillbore';
        if (aDrill) { /* drillbore survives */ }
        else if (a.shieldActive) { a.shieldActive = false; spawnExplosion(a.x, a.y, b.color, 12, 80); shockwaves.push({ x: a.x, y: a.y, r: 0, maxR: 60, life: 0.4, color: b.color }); }
        else if (a.passive === 'flagship') { a.hp -= 3; a.hpBarTimer = 1; if (a.hp <= 0) killShip(a, b.id); }
        else { a.hp = 0; killShip(a, bDrill ? b.id : b.id); }
        if (bDrill) { /* drillbore survives */ }
        else if (b.shieldActive) { b.shieldActive = false; spawnExplosion(b.x, b.y, a.color, 12, 80); shockwaves.push({ x: b.x, y: b.y, r: 0, maxR: 60, life: 0.4, color: a.color }); }
        else if (b.passive === 'flagship') { b.hp -= 3; b.hpBarTimer = 1; if (b.hp <= 0) killShip(b, a.id); }
        else { b.hp = 0; killShip(b, aDrill ? a.id : a.id); }
      }
    }
  }

  // Update asteroids
  for (const ast of asteroids) {
    ast.x += ast.vx * dt;
    ast.y += ast.vy * dt;
    ast.rot += ast.rotSpeed * dt;
    // Wrap (skip border decoration asteroids)
    if (!ast.isBorder) {
      ast.x = wrap(ast.x, CFG.WORLD_W);
      ast.y = wrap(ast.y, CFG.WORLD_H);
    }
  }

  } // end !skipGameplay

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= (1 - 3 * dt);
    p.vy *= (1 - 3 * dt);
    p.life -= dt;
    // Incendiary trail damage check
    if (p.incId && !incSpentBullets.has(p.incId)) {
      for (const ship of ships) {
        if (!ship.alive || ship.id === p.incOwner || ship.invuln > 0) continue;
        if (p.incOwnerTeam > 0 && ship.team === p.incOwnerTeam) continue;
        if (Math.hypot(p.x - ship.x, p.y - ship.y) < ship.r + 3) {
          const dmg = 0.5 * (ship.passive === 'titanium' ? 0.75 : 1);
          if (ship.shieldActive) {
            ship.shieldActive = false;
            const shieldColor = p.color || '#f80';
            spawnExplosion(p.x, p.y, shieldColor, 6, 40);
            shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 60, life: 0.4, color: shieldColor });
          } else {
            ship.hp -= dmg;
            ship.lastAttacker = p.incOwner;
            ship.lastAttackerTime = gameTime;
            ship.hpBarTimer = 0.75;
            spawnExplosion(p.x, p.y, '#f80', 4, 30);
            const attacker = shipById[p.incOwner];
            if (attacker) {
              if (attacker.passive === 'iceRounds') { ship.iceSlow = 2; ship.iceDotTimer = 2.0; }
              if (attacker.passive === 'jamRounds') ship.jamSlow = 4;
              if (attacker.passive === 'stunShock') ship.stunTimer = 1.75;
              if (attacker.passive === 'override') { ship.overrideTimer = 2; ship.overrideTurnDir = Math.random() < 0.5 ? -1 : 1; }
            }
            if (ship.passive === 'hitInvuln' && ship.hp > 0 && ship.hitInvulnCooldown <= 0) {
              ship.invuln = 1; ship.hitInvulnCooldown = 8;
              ship.iceSlow = 0; ship.jamSlow = 0; ship.stunTimer = 0;
              ship.overrideTimer = 0; ship.blindTimer = 0;
              ship.burnTimer = 0; ship.burnDps = 0; ship.iceDotTimer = 0;
            }
            if (ship.hp <= 0) killShip(ship, p.incOwner);
          }
          incSpentBullets.add(p.incId);
          break;
        }
      }
    }
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Update shockwaves
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const s = shockwaves[i];
    s.life -= dt;
    const sMaxLife = s.maxLife || 0.4;
    s.r = Math.max(0, s.maxR * (1 - s.life / sMaxLife));
    if (s.life <= 0) shockwaves.splice(i, 1);
  }

  // Update death glows
  for (let i = deathGlows.length - 1; i >= 0; i--) {
    deathGlows[i].life -= dt;
    if (deathGlows[i].life <= 0) deathGlows.splice(i, 1);
  }

  // Update smoke decoys
  for (let i = smokeDecoys.length - 1; i >= 0; i--) {
    smokeDecoys[i].life -= dt;
    if (smokeDecoys[i].life <= 0) smokeDecoys.splice(i, 1);
  }

  // Update ship clones (Double Team)
  for (let i = shipClones.length - 1; i >= 0; i--) {
    const clone = shipClones[i];
    if (!clone.alive) { shipClones.splice(i, 1); continue; }

    // If hit, count down flash timer (2x faster than before)
    if (clone.hit) {
      clone.hitTimer -= dt;
      if (clone.hitTimer <= 0) {
        spawnExplosion(clone.x, clone.y, clone.color, 10, 60);
        clone.alive = false;
        shipClones.splice(i, 1);
        continue;
      }
    }

    clone.life -= dt;
    if (clone.life <= 0) {
      spawnExplosion(clone.x, clone.y, clone.color, 8, 40);
      shipClones.splice(i, 1);
      continue;
    }

    const parent = shipById[clone.ownerId];
    if (!parent || !parent.alive) {
      spawnExplosion(clone.x, clone.y, clone.color, 8, 40);
      shipClones.splice(i, 1);
      continue;
    }

    // Orbit around parent — radius doubles over duration
    clone.orbitElapsed += dt;
    const expansionT = Math.min(1, clone.orbitElapsed / (clone.orbitDuration || 4));
    const curRadius = clone.orbitRadiusBase * (1 + expansionT); // 1x → 2x
    clone.orbitAngle += 1.2 * dt; // slow orbit speed
    clone.x = parent.x + Math.cos(clone.orbitAngle) * curRadius;
    clone.y = parent.y + Math.sin(clone.orbitAngle) * curRadius;
    clone.ang = parent.ang; // face same direction as parent

    // Block bullet collisions (bullets destroy clone)
    if (!clone.hit) {
      for (const b of bullets) {
        if (b.owner === clone.ownerId) continue;
        if (dist(b, clone) < clone.r + 4) {
          clone.hit = true;
          clone.hitTimer = 0.25; // 2x faster fade
          b.life = 0;
          break;
        }
      }
    }

    // Asteroid collisions destroy clone
    if (!clone.hit) {
      for (const ast of asteroids) {
        if (dist(clone, ast) < clone.r + ast.r * 0.85) {
          clone.hit = true;
          clone.hitTimer = 0.25;
          break;
        }
      }
    }
  }

  // Update debris field (Dump Debris) — absorb incoming projectiles
  for (let i = debrisField.length - 1; i >= 0; i--) {
    const d = debrisField[i];
    d.life -= dt;
    if (d.life <= 0) { debrisField.splice(i, 1); continue; }
    // Move with drag
    d.x += d.vx * dt;
    d.y += d.vy * dt;
    d.vx *= 1 - 1.5 * dt;
    d.vy *= 1 - 1.5 * dt;
    // Absorb bullets (not from the owner)
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      if (b.owner === d.ownerId) continue;
      const dx = b.x - d.x, dy = b.y - d.y;
      if (dx * dx + dy * dy < (d.size + 4) * (d.size + 4)) {
        // Absorb: destroy both debris piece and bullet
        b.life = 0;
        debrisField.splice(i, 1);
        break;
      }
    }
  }

  // Update reflector shields — orbit and reflect bullets
  for (let i = reflectorShields.length - 1; i >= 0; i--) {
    const rs = reflectorShields[i];
    rs.life -= dt;
    if (rs.life <= 0) { reflectorShields.splice(i, 1); continue; }
    const parent = shipById[rs.ownerId];
    if (!parent || !parent.alive) { reflectorShields.splice(i, 1); continue; }

    // Calculate current position on orbit
    const ang = parent._reflectorAngle + rs.baseAngle;
    rs.cx = parent.x + Math.cos(ang) * rs.orbitRadius;
    rs.cy = parent.y + Math.sin(ang) * rs.orbitRadius;
    rs.ang = ang + Math.PI * 0.5; // shield faces tangent to orbit

    // Check bullet collisions — line segment vs point
    const cosA = Math.cos(rs.ang), sinA = Math.sin(rs.ang);
    const x1 = rs.cx - cosA * rs.halfLength, y1 = rs.cy - sinA * rs.halfLength;
    const x2 = rs.cx + cosA * rs.halfLength, y2 = rs.cy + sinA * rs.halfLength;

    for (const b of bullets) {
      if (b.owner === rs.ownerId) continue; // own bullets pass through
      // Distance from bullet to line segment
      const dx = x2 - x1, dy = y2 - y1;
      const len2 = dx * dx + dy * dy;
      const t = Math.max(0, Math.min(1, ((b.x - x1) * dx + (b.y - y1) * dy) / len2));
      const px = x1 + t * dx, py = y1 + t * dy;
      const d2 = (b.x - px) * (b.x - px) + (b.y - py) * (b.y - py);
      if (d2 < 8 * 8) { // 8px hit radius
        // Reflect: reverse velocity
        b.vx = -b.vx;
        b.vy = -b.vy;
        // Push bullet away from shield to prevent re-collision
        b.x += b.vx * 0.05;
        b.y += b.vy * 0.05;
        // Change ownership so it can damage the original shooter
        b.owner = rs.ownerId;
        b.color = parent.color;
        // Spark effect
        spawnExplosion(px, py, parent.color, 4, 20);
      }
    }
  }

  // Update repulsor pushes — tick down timer and push bullets
  for (const ship of ships) {
    if (ship._repulsorLife > 0) {
      const prevR = ship._repulsorRadius * (1 - ship._repulsorLife / ship._repulsorMaxLife);
      ship._repulsorLife -= dt;
      const curR = ship._repulsorRadius * (1 - Math.max(0, ship._repulsorLife) / ship._repulsorMaxLife);
      const bandInner = prevR;
      const bandOuter = curR + 30; // slight thickness to catch fast bullets
      // Erase enemy projectiles the wavefront passes over
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        if (b.owner === ship.id) continue;
        const dx = b.x - ship._repulsorX, dy = b.y - ship._repulsorY;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d >= bandInner && d < bandOuter) {
          spawnExplosion(b.x, b.y, '#fff', 3, 20);
          bullets.splice(bi, 1);
        }
      }
      // Push particles the wavefront passes over
      for (const p of particles) {
        const dx = p.x - ship._repulsorX, dy = p.y - ship._repulsorY;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d >= bandInner && d < bandOuter && d > 1) {
          const nx = dx / d, ny = dy / d;
          p.vx += nx * 600;
          p.vy += ny * 600;
        }
      }
      if (ship._repulsorLife <= 0) ship._repulsorLife = 0;
    }
  }

  // Update mines (Mine Field) — proximity, bullet, and asteroid detonation
  for (let i = mines.length - 1; i >= 0; i--) {
    const mine = mines[i];
    mine.life -= dt;
    if (mine.life <= 0) { mines.splice(i, 1); continue; }

    // Arm timer — mine cannot detonate until placed for 1s
    if (mine.armTimer > 0) { mine.armTimer -= dt; continue; }

    let detonate = false;

    // Proximity: enemy ship within 200 units
    for (const ship of ships) {
      if (ship.id === mine.ownerId || !ship.alive) continue;
      if (mine.ownerTeam > 0 && ship.team === mine.ownerTeam) continue;
      if (dist(mine, ship) < mine.proximityRadius) { detonate = true; break; }
    }

    // Bullet strike: any projectile from any owner
    if (!detonate) {
      for (const b of bullets) {
        if (b.isShrapnel) continue;
        if (dist(mine, b) < mine.r + 4) {
          b.life = 0; // consume the bullet
          detonate = true;
          break;
        }
      }
    }

    // Asteroid strike
    if (!detonate) {
      for (const ast of asteroids) {
        if (dist(mine, ast) < mine.r + ast.r * 0.85) { detonate = true; break; }
      }
    }

    if (detonate) {
      detonateMine(mine);
      mines.splice(i, 1);
    }
  }

  // Update ship drones (Drone Array weapon)
  for (let i = shipDrones.length - 1; i >= 0; i--) {
    const d = shipDrones[i];
    d.life -= dt;
    if (d.life <= 0) {
      shipDrones.splice(i, 1);
      continue;
    }

    const parent = shipById[d.ownerId];

    if (d.state === 'orbiting' || d.state === 'armed') {
      // If parent dead, release all orbiting drones as pursuing
      if (!parent || !parent.alive) {
        d.state = 'pursuing';
        d._drawScale = 1;
        d.life = 2.0; // reset lifetime
        const a = d.orbitAngle;
        d.vx = Math.cos(a) * d.speed;
        d.vy = Math.sin(a) * d.speed;
        continue;
      }

      // Orbit around parent
      // Spawn animation: expand from half-radius to full over 0.3s
      if (d.spawnProgress < 1) {
        d.spawnProgress = Math.min(1, d.spawnProgress + dt / 0.3);
      }
      const t = d.spawnProgress * d.spawnProgress; // ease-in curve
      const curRadius = d.orbitRadius * (0.3 + 0.7 * t);
      const angularSpeed = d.orbitSpeed / curRadius;
      d.orbitAngle += angularSpeed * dt;
      d.x = parent.x + Math.cos(d.orbitAngle) * curRadius;
      d.y = parent.y + Math.sin(d.orbitAngle) * curRadius;
      d.ang = d.orbitAngle + Math.PI * 0.5; // face tangent
      d._drawScale = 0.1 + 0.9 * t; // visual size scale for rendering

      // Count down arm timer
      if (d.state === 'orbiting') {
        d.armTimer -= dt;
        if (d.armTimer <= 0) d.state = 'armed';
      }

      // Armed: count down individual launch delay, then find target
      if (d.state === 'armed') {
        d.launchDelay -= dt;
        if (d.launchDelay <= 0) {
          // Find closest enemy in range
          let closest = null, cDist = Infinity;
          for (const s of ships) {
            if (!s.alive || s.id === d.ownerId) continue;
            if (d.ownerTeam > 0 && s.team === d.ownerTeam) continue;
            const dd = dist(d, s);
            if (dd < cDist) { cDist = dd; closest = s; }
          }
          if (closest) {
            // Launch toward target
            d.state = 'pursuing';
            d._drawScale = 1;
            d.life = 2.0; // reset lifetime so drones don't all expire at once
            const tAng = angle(d, closest);
            d.vx = Math.cos(tAng) * d.speed;
            d.vy = Math.sin(tAng) * d.speed;
            // Breakaway ellipse particle
            shockwaves.push({ x: d.x, y: d.y, r: 0, maxR: 15, life: 0.2, maxLife: 0.2, color: d.color, ellipse: true, ellipseAng: tAng });
          }
        }
      }

      // Collision damage while orbiting (contact damage)
      for (const s of ships) {
        if (!s.alive || s.id === d.ownerId) continue;
        if (dist(d, s) < d.r + s.r) {
          // Deal damage
          s.hp -= d.damage;
          s.hpBarTimer = 1;
          s.lastAttacker = d.ownerId;
          s.lastAttackerTime = gameTime;
          spawnExplosion(d.x, d.y, d.color, 6, 30);
          shipDrones.splice(i, 1);
          if (s.hp <= 0 && s.alive) {
            killShip(s, d.ownerId);
          }
          break;
        }
      }
      if (!shipDrones[i] || shipDrones[i] !== d) continue;

      // Orbiting/armed drones neutralize enemy bullets on contact
      let droneZapped = false;
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (b.owner === d.ownerId) continue;
        if (dist(d, b) < d.r + 4) {
          spawnExplosion(b.x, b.y, '#fff', 4, 20);
          bullets.splice(j, 1);
          shipDrones.splice(i, 1);
          droneZapped = true;
          break;
        }
      }
      if (droneZapped) continue;
    }

    if (d.state === 'pursuing') {
      // Moderate homing — tracks nearby enemies
      let closest = null, cDist = Infinity;
      for (const s of ships) {
        if (!s.alive || s.id === d.ownerId) continue;
        const dd = dist(d, s);
        if (dd < cDist) { cDist = dd; closest = s; }
      }
      if (closest) {
        const tAng = angle(d, closest);
        const cAng = Math.atan2(d.vy, d.vx);
        const da = shortAngleDist(cAng, tAng);
        const turn = Math.sign(da) * Math.min(Math.abs(da), d.turnRate * dt);
        const nAng = cAng + turn;
        const spd = Math.hypot(d.vx, d.vy);
        d.vx = Math.cos(nAng) * spd;
        d.vy = Math.sin(nAng) * spd;
      }

      // Move
      d.x += d.vx * dt;
      d.y += d.vy * dt;
      d.ang = Math.atan2(d.vy, d.vx);

      // Box particle trail
      if (Math.random() < 0.5) {
        particles.push({
          x: d.x + rand(-3, 3), y: d.y + rand(-3, 3),
          vx: -d.vx * 0.2 + rand(-15, 15), vy: -d.vy * 0.2 + rand(-15, 15),
          life: rand(0.2, 0.4), maxLife: 0.4, color: d.color, size: rand(1.5, 3),
          isSquare: true,
        });
      }

      // Hit ships
      let hit = false;
      for (const s of ships) {
        if (!s.alive || s.id === d.ownerId || s.invuln > 0) continue;
        if (d.ownerTeam > 0 && s.team === d.ownerTeam) continue;
        if (dist(d, s) < d.r + s.r) {
          // Shield passive: absorb first hit
          if (s.shieldActive) {
            s.shieldActive = false;
            spawnExplosion(d.x, d.y, '#fff', 8, 50);
          } else {
            s.hp -= d.damage;
            if (s.hp <= 0 && s.alive) {
              killShip(s, d.ownerId);
            }
          }
          s.hpBarTimer = 1;
          s.lastAttacker = d.ownerId;
          s.lastAttackerTime = gameTime;
          spawnExplosion(d.x, d.y, d.color, 8, 40);
          hit = true;
          break;
        }
      }

      // Hit asteroids — drone and asteroid both destroyed
      if (!hit) {
        for (let ai = asteroids.length - 1; ai >= 0; ai--) {
          const ast = asteroids[ai];
          if (dist(d, ast) < d.r + ast.r * 0.85) {
            // Break the asteroid like a bullet would
            const explodeScale = ast.r / 50;
            spawnExplosion(ast.x, ast.y, 'rgba(255,255,255,0.6)', Math.floor(8 * explodeScale), 100 * explodeScale);
            playAsteroidBreak();
            if (ast.sizeIdx < 3) {
              const spread = ast.r * 0.4;
              for (let k = 0; k < 2; k++) {
                asteroids.push(spawnAsteroid(ast.sizeIdx + 1, ast.x + rand(-spread, spread), ast.y + rand(-spread, spread)));
              }
            } else if (CFG.RESPAWN_ASTEROIDS && asteroids.length < CFG.NUM_ASTEROIDS * 1.3) {
              const spawnChance = 0.25 + Math.min(0.35, gameTime / 90);
              if (Math.random() < spawnChance) {
                const edge = randInt(0, 3);
                const ex = edge === 0 ? 0 : edge === 2 ? CFG.WORLD_W : rand(0, CFG.WORLD_W);
                const ey = edge === 1 ? 0 : edge === 3 ? CFG.WORLD_H : rand(0, CFG.WORLD_H);
                asteroids.push(spawnAsteroid(1, ex, ey));
              }
            }
            asteroids.splice(ai, 1);
            spawnExplosion(d.x, d.y, d.color, 5, 25);
            hit = true;
            break;
          }
        }
      }

      // Pursuing drones also neutralize enemy bullets on contact
      if (!hit) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (b.owner === d.ownerId) continue;
          if (dist(d, b) < d.r + 4) {
            spawnExplosion(b.x, b.y, '#fff', 4, 20);
            bullets.splice(j, 1);
            hit = true;
            break;
          }
        }
      }

      if (hit) {
        shipDrones.splice(i, 1);
        continue;
      }

      // Bounds — soft bounce
      if (d.x < 0 || d.x > CFG.WORLD_W) d.vx = -d.vx;
      if (d.y < 0 || d.y > CFG.WORLD_H) d.vy = -d.vy;
    }
  }

  // Set 4s cooldown when all drones are gone for a drone-weapon ship
  for (const ship of ships) {
    if (!ship.alive || ship.weapon.type !== 'drone') continue;
    const hasDrones = shipDrones.some(d => d.ownerId === ship.id);
    if (!hasDrones && ship.fireCooldown < 4.0 && ship._droneWasActive) {
      ship.fireCooldown = 4.0;
      ship._droneWasActive = false;
    }
    if (hasDrones) ship._droneWasActive = true;
  }

  // Camera — follow alive ships centroid, zoom to fit action
  const alive = ships.filter(s => s.alive);
  if (alive.length > 0 && !finaleMode) {

    if (cameraMode === 'manual') {
      // Track selected ships
      const tracked = manualShips.filter(id => shipById[id] && shipById[id].alive);
      if (tracked.length <= 1) {
        if (cameraLinger <= 0 && !cameraTransitioning) {
          // Start linger — hold on the action
          cameraLinger = 1.2;
        } else if (cameraLinger > 0) {
          cameraLinger -= rawDt;
          if (cameraLinger <= 0) {
            cameraTransitioning = true;
          }
        } else if (cameraTransitioning) {
          // Slowly pull out to overview
          cameraMode = 'overview';
          manualShips = [];
          cameraTransitioning = true; // keep slow transition flag
          updateCameraModeUI();
          // Set overview target
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          for (const s of alive) {
            minX = Math.min(minX, s.x); maxX = Math.max(maxX, s.x);
            minY = Math.min(minY, s.y); maxY = Math.max(maxY, s.y);
          }
          targetCamX = (minX + maxX) / 2;
          targetCamY = (minY + maxY) / 2;
          const spreadX = maxX - minX + 600;
          const spreadY = maxY - minY + 600;
          targetZoom = Math.max(0.15, Math.min(1.5, Math.min(W / spreadX, H / spreadY)));
        }
      } else {
        manualShips = tracked;
        cameraLinger = 0;
        cameraTransitioning = false;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const id of tracked) {
          const s = shipById[id];
          minX = Math.min(minX, s.x); maxX = Math.max(maxX, s.x);
          minY = Math.min(minY, s.y); maxY = Math.max(maxY, s.y);
        }
        targetCamX = (minX + maxX) / 2;
        targetCamY = (minY + maxY) / 2;
        const spreadX = maxX - minX + 400;
        const spreadY = maxY - minY + 400;
        const needZoomX = W / spreadX;
        const needZoomY = H / spreadY;
        targetZoom = Math.min(needZoomX, needZoomY);
        targetZoom = Math.max(0.3, Math.min(2.5, targetZoom));
      }

    } else {
      // Overview mode — original behavior
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const s of alive) {
        minX = Math.min(minX, s.x);
        maxX = Math.max(maxX, s.x);
        minY = Math.min(minY, s.y);
        maxY = Math.max(maxY, s.y);
      }
      targetCamX = (minX + maxX) / 2;
      targetCamY = (minY + maxY) / 2;

      const camPad = 200 + alive.length * 15;
      const spreadX = maxX - minX + camPad;
      const spreadY = maxY - minY + camPad;
      const needZoomX = W / spreadX;
      const needZoomY = H / spreadY;
      targetZoom = Math.min(needZoomX, needZoomY);
      targetZoom = Math.max(0.15, Math.min(1.5, targetZoom));
    }
  }

  // Camera speed: slow when transitioning away from a fight, frozen when lingering
  let baseCamSpeed;
  if (cameraLinger > 0) {
    baseCamSpeed = 0; // hold still during linger
  } else if (cameraTransitioning) {
    baseCamSpeed = 0.02; // slow pull-out from fights
  } else if (cameraMode === 'manual') {
    baseCamSpeed = 0.08; // snappy tracking during active fights
  } else {
    baseCamSpeed = CFG.CAMERA_LERP;
    // Gradually restore normal speed after transitioning
    if (cameraTransitioning) {
      baseCamSpeed = 0.02;
      // Clear once zoom is close enough to target
      if (Math.abs(camZoom - targetZoom) / Math.max(0.01, targetZoom) < 0.1) {
        cameraTransitioning = false;
      }
    }
  }
  const camSpeed = finaleMode ? 0.12 : baseCamSpeed;
  if (cameraMode !== 'overview') updateCameraModeUI();
  const camLerp = 1 - Math.pow(1 - camSpeed, rawDt * 60);
  // During transitions: zoom out first, pan follows. Normal: pan leads slightly.
  const zoomMult = cameraTransitioning ? 2.5 : 0.7;
  const panMult = cameraTransitioning ? 0.5 : 1.0;
  cameraX = lerp(cameraX, targetCamX, camLerp * panMult);
  cameraY = lerp(cameraY, targetCamY, camLerp * panMult);
  camZoom = lerp(camZoom, targetZoom, camLerp * zoomMult);

  // Finale slow-mo: triggered by the killing blow in killShip
  if (finaleMode) {
    finaleTimer += rawDt;
    // Gradual slowdown: starts at ~0.3x speed, eases to near-zero over 3.5s
    const t = Math.min(1, finaleTimer / 3.5);
    finaleSlowMo = 0.3 * (1 - t) * (1 - t); // quadratic ease to zero
    finaleFlash = Math.max(0, finaleFlash - rawDt * 2.5);

    // Screen shake — intense at first, decays over ~1.5s
    const shakeIntensity = Math.max(0, 1 - finaleTimer / 1.5);
    const shakeAmount = shakeIntensity * 12;
    screenShakeX = (Math.random() - 0.5) * 2 * shakeAmount;
    screenShakeY = (Math.random() - 0.5) * 2 * shakeAmount;

    // Camera stays where it is — no target override

    if (finaleTimer > 3.5 && !gameOver) {
      gameOver = true;
      winner = ships.find(s => s.alive) || null; // null = draw
      setTimeout(showWinner, 500);
    }
  } else {
    screenShakeX = 0;
    screenShakeY = 0;
  }

  // Normal win check (fallback if somehow missed)
  const aliveCount = ships.filter(s => s.alive).length;
  document.getElementById('alive-num').textContent = aliveCount;
  let shouldEnd = false;
  if (matchMode === 'teams') {
    const teamsAlive = new Set(ships.filter(s => s.alive && s.team > 0).map(s => s.team));
    if (teamsAlive.size <= 1) shouldEnd = true;
  } else {
    if (aliveCount <= 1) shouldEnd = true;
  }
  if (shouldEnd && !gameOver && !finaleMode) {
    gameOver = true;
    winner = ships.find(s => s.alive) || null;
    setTimeout(showWinner, 1000);
  }

  updateScoreboard();
}

function killShip(ship, killerId) {
  ship.alive = false;
  ship.deathTime = gameTime;
  ship.placement = ships.filter(s => s.alive).length + 1;
  // Death explosion — longer-lasting particles than normal (3x for flagship)
  const deathLifeMult = ship.passive === 'flagship' ? 3 : 1;
  const deathCount = ship.passive === 'flagship' ? 80 : 40;
  for (let i = 0; i < deathCount; i++) {
    const a = rand(0, Math.PI * 2);
    const sp = rand(20, 200);
    particles.push({
      x: ship.x, y: ship.y,
      vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
      life: rand(0.6, 2.4) * deathLifeMult, maxLife: 2.4 * deathLifeMult,
      color: ship.color, size: rand(1, 3),
    });
  }
  shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: ship.passive === 'flagship' ? 300 : 160, life: 0.4, color: ship.color });
  playExplosion();
  // Death glow — temporary color tint at kill site
  deathGlows.push({ x: ship.x, y: ship.y, color: ship.color, life: 7.5, maxLife: 7.5 });

  // If killed by asteroid but recently damaged by a pilot (within 5s), credit that pilot
  if (killerId < 0 && ship.lastAttacker >= 0 && (gameTime - ship.lastAttackerTime) < 2.5) {
    killerId = ship.lastAttacker;
  }

  const killer = killerId >= 0 ? shipById[killerId] : null;
  if (killer && killer.alive) {
    killer.kills++;
    // Scrap Armor passive: heal +1.5 HP on kill (can overheal)
    if (killer.passive === 'scrapRepair') {
      killer.hp += 1.5;
      killer.hpBarTimer = 0.75;
      // Plus sign particle effect
      for (let p = 0; p < 8; p++) {
        const isHoriz = p < 4;
        const t = (p % 4) / 3 - 0.5;
        const px = isHoriz ? t * 20 : 0;
        const py = isHoriz ? 0 : t * 20;
        particles.push({
          x: killer.x + px, y: killer.y + py - 15,
          vx: rand(-10, 10), vy: rand(-30, -15),
          life: 0.8, maxLife: 0.8,
          color: '#0f0', size: 2.5,
        });
      }
    }
    // Detonator passive: 25 projectiles from kill site
    if (killer.passive === 'detonator') {
      for (let di = 0; di < 25; di++) {
        const a = (di / 25) * Math.PI * 2;
        const sp = 500;
        bullets.push(makeBullet(killer, ship.x, ship.y, Math.cos(a) * sp, Math.sin(a) * sp,
          { life: 1, damage: 2, type: 'basic', size: 2.5, isShrapnel: true, fireAng: a }));
      }
      spawnExplosion(ship.x, ship.y, killer.color, 30, 250);
    }
  }
  if (killerId < 0) asteroidKills++;

  const killerName = killer ? killer.name : 'ASTEROID';
  const killerColor = killer ? killer.color : '#888';
  ship.killedBy = killerName;
  addKillMessage(killerName, killerColor, ship.name, ship.color);

  const aliveCount = ships.filter(s => s.alive).length;
  // Check win: FFA = 1 ship left, Teams = 1 team left
  let shouldFinale = false;
  if (matchMode === 'teams') {
    const teamsAlive = new Set(ships.filter(s => s.alive && s.team > 0).map(s => s.team));
    if (teamsAlive.size <= 1) shouldFinale = true;
  } else {
    if (aliveCount <= 1) shouldFinale = true;
  }
  if (shouldFinale && !finaleMode) {
    finaleMode = true;
    finaleTimer = 0;
    finaleFlash = 1;
    // Grant invuln to all survivors
    for (const s of ships) { if (s.alive) s.invuln = Infinity; }
    finaleDeath = {
      x: ship.x, y: ship.y,
      color: ship.color,
      killerColor: killerColor,
      killerName: killerName,
    };
    playFinaleExplosion();
    spawnExplosion(ship.x, ship.y, killerColor, 60, 300);
    spawnExplosion(ship.x, ship.y, ship.color, 40, 250);
    spawnExplosion(ship.x, ship.y, killerColor, 30, 200);
  }
  // Detect draw — finaleMode already triggered but now nobody's alive
  if (aliveCount === 0 && finaleMode && !gameOver) {
    // Let the finale play out, winner will be null → draw
  }
}

// ─── RENDER ───────────────────────────────────────────────────
function render() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  // Camera transform
  ctx.translate(W / 2 + screenShakeX, H / 2 + screenShakeY);
  ctx.scale(camZoom, camZoom);
  ctx.translate(-cameraX, -cameraY);

  // Scale glow inversely with zoom — 1x at close, ~2x when zoomed out
  const baseGlowScale = Math.min(8, 0.35 / camZoom);
  // Countdown glow boost: 2× at start, decaying to 1× by end
  const countdownGlowMult = countdown ? 1 + (countdownTimer / COUNTDOWN_DURATION) : 1;
  const glowScale = baseGlowScale * countdownGlowMult;

  // Stars (parallax)
  drawStars();

  // Death glows — fading radial tint at kill sites
  for (const g of deathGlows) {
    const alpha = (g.life / g.maxLife) * 0.25;
    const radius = 200 + (1 - g.life / g.maxLife) * 100; // expand slightly as it fades
    const grad = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, radius);
    grad.addColorStop(0, g.color);
    grad.addColorStop(1, 'transparent');
    ctx.globalAlpha = alpha;
    ctx.fillStyle = grad;
    ctx.fillRect(g.x - radius, g.y - radius, radius * 2, radius * 2);
  }
  ctx.globalAlpha = 1;

  // Shockwaves
  for (const s of shockwaves) {
    const alpha = s.life / (s.maxLife || 0.4);
    ctx.save();
    ctx.globalAlpha = alpha * 0.6;
    ctx.strokeStyle = s.color;
    ctx.lineWidth = 2;
    if (s.ellipse) {
      // Elliptical shockwave (Fierce passive) — thin perpendicular to ship direction
      ctx.translate(s.x, s.y);
      ctx.rotate(s.ellipseAng);
      ctx.beginPath();
      ctx.ellipse(0, 0, s.r * 0.3, s.r, 0, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Asteroids
  for (const ast of asteroids) {
    // Visible on screen?
    const sx = (ast.x - cameraX) * camZoom + W/2;
    const sy = (ast.y - cameraY) * camZoom + H/2;
    const sr = ast.r * camZoom;
    if (sx < -sr*2 || sx > W+sr*2 || sy < -sr*2 || sy > H+sr*2) continue;

    ctx.save();
    ctx.translate(ast.x, ast.y);
    ctx.rotate(ast.rot);
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(ast.verts[0].x, ast.verts[0].y);
    for (let i = 1; i < ast.verts.length; i++) {
      ctx.lineTo(ast.verts[i].x, ast.verts[i].y);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fill();
    ctx.restore();
  }

  // Debris field (Dump Debris) — rendered as squares
  ctx.shadowBlur = 0;
  for (const d of debrisField) {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.life * 3); // slow tumble
    ctx.globalAlpha = Math.min(1, d.life * 0.8);
    ctx.fillStyle = d.color;
    const hs = d.size * 0.5;
    ctx.fillRect(-hs, -hs, d.size, d.size);
    ctx.restore();
  }

  // Ship clones (Double Team)
  for (const clone of shipClones) {
    if (!clone.alive) continue;
    ctx.save();
    if (clone.hit) {
      // Flash rapidly when hit
      ctx.globalAlpha = Math.sin(gameTime * 30) > 0 ? 0.8 : 0.15;
    } else if (clone.orbitElapsed < 0.5) {
      // Hologram flicker on spawn — rapid on/off
      const t = clone.orbitElapsed;
      const flicker = Math.sin(t * 60) * Math.sin(t * 23) * Math.sin(t * 47);
      ctx.globalAlpha = flicker > 0 ? 0.8 : 0.05;
    } else {
      ctx.globalAlpha = 0.7;
    }
    drawShipShape(ctx, clone.x, clone.y, clone.ang, clone.r, clone.color, 1, 1, 0, clone.shipId, 0, clone._designForced);
    ctx.restore();
  }

  // Ship drones (Drone Array) — small pentagons
  for (const d of shipDrones) {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.ang);
    const ds = (d._drawScale || 1) * d.r;
    ctx.fillStyle = d.color + '88';
    ctx.strokeStyle = d.color;
    ctx.shadowColor = d.color;
    ctx.shadowBlur = (d.state === 'pursuing' ? 10 : 4) * glowScale;
    ctx.lineWidth = 1.2;
    // Pentagon
    ctx.beginPath();
    for (let v = 0; v < 5; v++) {
      const a = (v / 5) * Math.PI * 2 - Math.PI / 2;
      const px = Math.cos(a) * ds, py = Math.sin(a) * ds;
      if (v === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // Ship drones (Drone Array) — small pentagons
  for (const d of shipDrones) {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.ang);
    const ds = (d._drawScale || 1) * d.r;
    ctx.fillStyle = d.color + '88';
    ctx.strokeStyle = d.color;
    ctx.lineWidth = 1.2;
    ctx.shadowColor = d.color;
    ctx.shadowBlur = (d.state === 'pursuing' ? 10 : 5) * glowScale;
    ctx.beginPath();
    for (let p = 0; p < 5; p++) {
      const a = (p / 5) * Math.PI * 2 - Math.PI / 2;
      const px = Math.cos(a) * ds, py = Math.sin(a) * ds;
      if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Inner dot when armed/pursuing
    if (d.state !== 'orbiting') {
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(0, 0, ds * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Mines (Mine Field) — flashing stationary projectiles
  for (const mine of mines) {
    ctx.save();
    const armed = !mine.armTimer || mine.armTimer <= 0;
    // Flash: bright pulse every 1 second (only when armed)
    const flash = armed && Math.sin(gameTime * Math.PI) > 0.7;
    ctx.fillStyle = mine.color;
    ctx.shadowColor = mine.color;
    ctx.shadowBlur = (flash ? 20 : armed ? 6 : 2) * glowScale;
    ctx.globalAlpha = flash ? 1.0 : armed ? 0.6 : 0.25;
    ctx.beginPath();
    ctx.arc(mine.x, mine.y, mine.r, 0, Math.PI * 2);
    ctx.fill();
    // Inner dot
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = flash ? 0.9 : armed ? 0.3 : 0.1;
    ctx.beginPath();
    ctx.arc(mine.x, mine.y, mine.r * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Reflector shields — glowing lines orbiting the ship
  for (const rs of reflectorShields) {
    ctx.save();
    ctx.strokeStyle = rs.color;
    ctx.shadowColor = rs.color;
    ctx.shadowBlur = (12) * glowScale;
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.85;
    const cosA = Math.cos(rs.ang), sinA = Math.sin(rs.ang);
    ctx.beginPath();
    ctx.moveTo(rs.cx - cosA * rs.halfLength, rs.cy - sinA * rs.halfLength);
    ctx.lineTo(rs.cx + cosA * rs.halfLength, rs.cy + sinA * rs.halfLength);
    ctx.stroke();
    // Thicker inner glow
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.4;
    ctx.shadowBlur = (20) * glowScale;
    ctx.stroke();
    ctx.restore();
  }

  // Bullets
  for (const b of bullets) {
    ctx.fillStyle = b.color;
    ctx.shadowColor = b.color;
    ctx.shadowBlur = (b.ownerPassive === 'sparkDrive' ? 28 : 14) * glowScale;
    if (b.type === 'sniper') {
      // Beam trail
      if (b.trail && b.trail.length > 1) {
        ctx.shadowBlur = (8) * glowScale;
        for (let t = 1; t < b.trail.length; t++) {
          const alpha = b.trail[t].life / 0.35;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 2.5 * alpha;
          ctx.beginPath();
          ctx.moveTo(b.trail[t-1].x, b.trail[t-1].y);
          ctx.lineTo(b.trail[t].x, b.trail[t].y);
          ctx.stroke();
        }
        // Connect last trail point to bullet
        const last = b.trail[b.trail.length - 1];
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      // Elongated bright line for sniper bullet head
      ctx.shadowBlur = (14) * glowScale;
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*10, b.y - Math.sin(bAng)*10);
      ctx.lineTo(b.x + Math.cos(bAng)*10, b.y + Math.sin(bAng)*10);
      ctx.stroke();
    } else if (b.type === 'alternating') {
      // Parallel laser lines
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*7, b.y - Math.sin(bAng)*7);
      ctx.lineTo(b.x + Math.cos(bAng)*7, b.y + Math.sin(bAng)*7);
      ctx.stroke();
    } else if (b.type === 'homing' && !b.isShrapnel) {
      // Diamond shape for missiles
      const bAng = Math.atan2(b.vy, b.vx);
      const sz = b.armed ? 5 : 3;
      ctx.beginPath();
      ctx.moveTo(b.x + Math.cos(bAng)*sz, b.y + Math.sin(bAng)*sz);
      ctx.lineTo(b.x + Math.cos(bAng+Math.PI/2)*sz*0.4, b.y + Math.sin(bAng+Math.PI/2)*sz*0.4);
      ctx.lineTo(b.x - Math.cos(bAng)*sz*0.6, b.y - Math.sin(bAng)*sz*0.6);
      ctx.lineTo(b.x + Math.cos(bAng-Math.PI/2)*sz*0.4, b.y + Math.sin(bAng-Math.PI/2)*sz*0.4);
      ctx.closePath();
      ctx.fill();
    } else if (b.type === 'chaotic' && b.trail && b.trail.length > 0) {
      // Chaotic: perpendicular line trails
      for (const tp of b.trail) {
        const alpha = tp.life / 0.25;
        const perp = tp.ang + Math.PI / 2;
        const len = 6 + 4 * alpha;
        ctx.globalAlpha = alpha * 0.7;
        ctx.strokeStyle = b.color;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(tp.x - Math.cos(perp) * len, tp.y - Math.sin(perp) * len);
        ctx.lineTo(tp.x + Math.cos(perp) * len, tp.y + Math.sin(perp) * len);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      // Bullet dot
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size || 3, 0, Math.PI * 2);
      ctx.fill();
    } else if (b.type === 'triple') {
      // Short line for triple-guns
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*5, b.y - Math.sin(bAng)*5);
      ctx.lineTo(b.x + Math.cos(bAng)*5, b.y + Math.sin(bAng)*5);
      ctx.stroke();
    } else if (b.type === 'doublehelix') {
      // Cross-link trail lines between helix pair
      if (b.trail && b.trail.length > 0 && b.helixSide === 1) {
        for (const tp of b.trail) {
          const alpha = tp.life / 0.3;
          ctx.globalAlpha = alpha * 0.5;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(tp.x - Math.cos(tp.ang) * tp.len, tp.y - Math.sin(tp.ang) * tp.len);
          ctx.lineTo(tp.x + Math.cos(tp.ang) * tp.len, tp.y + Math.sin(tp.ang) * tp.len);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size || 3, 0, Math.PI * 2);
      ctx.fill();
    } else if (b.type === 'crossshot') {
      // Beam trail
      if (b.trail && b.trail.length > 1) {
        ctx.shadowBlur = (6) * glowScale;
        for (let t = 1; t < b.trail.length; t++) {
          const alpha = b.trail[t].life / 0.25;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 2 * alpha;
          ctx.beginPath();
          ctx.moveTo(b.trail[t-1].x, b.trail[t-1].y);
          ctx.lineTo(b.trail[t].x, b.trail[t].y);
          ctx.stroke();
        }
        const last = b.trail[b.trail.length - 1];
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
      // Short laser line head
      ctx.shadowBlur = (14) * glowScale;
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*6, b.y - Math.sin(bAng)*6);
      ctx.lineTo(b.x + Math.cos(bAng)*6, b.y + Math.sin(bAng)*6);
      ctx.stroke();
    } else if (b.type === 'lightning') {
      // Lightning: jagged beam trail
      if (b.trail && b.trail.length > 1) {
        ctx.shadowBlur = (10) * glowScale;
        for (let t = 1; t < b.trail.length; t++) {
          const alpha = b.trail[t].life / 0.4;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 2.5 * alpha;
          ctx.beginPath();
          ctx.moveTo(b.trail[t-1].x, b.trail[t-1].y);
          ctx.lineTo(b.trail[t].x, b.trail[t].y);
          ctx.stroke();
        }
        const last = b.trail[b.trail.length - 1];
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      // Bright point at tip
      ctx.shadowBlur = (18) * glowScale;
      ctx.beginPath();
      ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      if (b.ownerPassive === 'piercing') {
        // Piercing: pointed triangle bullet
        const bAng = Math.atan2(b.vy, b.vx);
        const sz = b.size || 3;
        ctx.beginPath();
        ctx.moveTo(b.x + Math.cos(bAng) * sz * 1.5, b.y + Math.sin(bAng) * sz * 1.5);
        ctx.lineTo(b.x + Math.cos(bAng + 2.4) * sz, b.y + Math.sin(bAng + 2.4) * sz);
        ctx.lineTo(b.x + Math.cos(bAng - 2.4) * sz, b.y + Math.sin(bAng - 2.4) * sz);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size || 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.shadowBlur = 0;
  }

  // Orphan lightning trails (persist after bullet death)
  for (const ot of orphanTrails) {
    if (ot.trail.length < 2) continue;
    ctx.shadowColor = ot.color;
    ctx.shadowBlur = (10) * glowScale;
    for (let t = 1; t < ot.trail.length; t++) {
      const alpha = ot.trail[t].life / 0.4;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = ot.color;
      ctx.lineWidth = 2.5 * alpha;
      ctx.beginPath();
      ctx.moveTo(ot.trail[t-1].x, ot.trail[t-1].y);
      ctx.lineTo(ot.trail[t].x, ot.trail[t].y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }

  // Ships
  for (const ship of ships) {
    if (!ship.alive) continue;
    if (ship._teleportPhase === 'phasing') continue; // invisible during teleport

    // ── STEALTH BEAM TRAIL (draw before ship) ──
    if (ship.passive === 'stealth' && ship.beamTrail && ship.beamTrail.length > 1) {
      ctx.save();
      ctx.shadowColor = ship.color;
      ctx.shadowBlur = (6) * glowScale;
      for (let t = 1; t < ship.beamTrail.length; t++) {
        const alpha = ship.beamTrail[t].life / ship.beamTrail[t].maxLife;
        ctx.globalAlpha = alpha * 0.5;
        ctx.strokeStyle = ship.color;
        ctx.lineWidth = 2.5 * alpha;
        ctx.beginPath();
        ctx.moveTo(ship.beamTrail[t-1].x, ship.beamTrail[t-1].y);
        ctx.lineTo(ship.beamTrail[t].x, ship.beamTrail[t].y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // Zoom-dependent glow ring — visible at distance, fades when close
    const zoomRingAlpha = Math.max(0, Math.min(0.35, (0.5 - camZoom) * 1));
    if (zoomRingAlpha > 0.01) {
      const ringR = ship.r * 6;
      const hc = ship.color;
      const r = parseInt(hc.slice(1,3),16), g = parseInt(hc.slice(3,5),16), bl = parseInt(hc.slice(5,7),16);
      const grad = ctx.createRadialGradient(ship.x, ship.y, ship.r * 0.5, ship.x, ship.y, ringR);
      grad.addColorStop(0, `rgba(${r},${g},${bl},${zoomRingAlpha})`);
      grad.addColorStop(0.3, `rgba(${r},${g},${bl},${zoomRingAlpha * 0.5})`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(ship.x, ship.y, ringR, 0, Math.PI * 2);
      ctx.fill();
    }

    drawShipShape(ctx, ship.x, ship.y, ship.ang, ship.r, ship.color, ship.hp, ship.maxHp, ship.invuln, ship.shipType, ship.hpBarTimer, ship._designForced);

    // ── PASSIVE VISUAL OVERLAYS ──
    ctx.save();

    // Shield: hex ring around ship until damaged
    if (ship.passive === 'shield' && ship.shieldActive) {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.ang);
      const shieldR = (ship.r + 6) * 1.2;
      const pulse = 0.35 + 0.15 * Math.sin(gameTime * 3);
      ctx.strokeStyle = ship.color;
      ctx.globalAlpha = pulse;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let v = 0; v < 6; v++) {
        const a = (v / 6) * Math.PI * 2 - Math.PI / 6;
        const px = Math.cos(a) * shieldR, py = Math.sin(a) * shieldR;
        if (v === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Titanium: two shield-like chevrons on each side of the ship
    if (ship.passive === 'titanium') {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.ang);
      ctx.strokeStyle = ship.color;
      ctx.globalAlpha = 0.25 + 0.05 * Math.sin(gameTime * 2);
      ctx.lineWidth = 1.4;
      const cR = ship.r + 6;
      for (const side of [-1, 1]) {
        // Very obtuse (~155°) chevron pointing sideways like a shield bracket
        ctx.beginPath();
        ctx.moveTo(cR * 0.8, side * cR * 0.95);    // front arm
        ctx.lineTo(0, side * cR * 1.15);             // outward tip
        ctx.lineTo(-cR * 0.8, side * cR * 0.95);    // rear arm
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Drillbore: small chevron on the front of the ship's nose
    if (ship.passive === 'drillbore') {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.ang);
      ctx.strokeStyle = ship.color;
      ctx.globalAlpha = 0.6;
      ctx.lineWidth = 1.8;
      const noseOff = ship.r + 4;
      ctx.beginPath();
      ctx.moveTo(noseOff - 4, -5);
      ctx.lineTo(noseOff + 2, 0);
      ctx.lineTo(noseOff - 4, 5);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    ctx.restore();
  }

  // Particles
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    if (p.isArc && p.arcPoints) {
      // Mini lightning arc — jagged connected segments
      ctx.strokeStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 6 * glowScale;
      ctx.lineWidth = 1.5 * alpha;
      ctx.beginPath();
      ctx.moveTo(p.x + p.arcPoints[0].x, p.y + p.arcPoints[0].y);
      for (let a = 1; a < p.arcPoints.length; a++) {
        ctx.lineTo(p.x + p.arcPoints[a].x, p.y + p.arcPoints[a].y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (p.isLine) {
      // Line particle for debuff effects
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(p.x - Math.cos(p.lineAng) * p.lineLen * 0.5, p.y - Math.sin(p.lineAng) * p.lineLen * 0.5);
      ctx.lineTo(p.x + Math.cos(p.lineAng) * p.lineLen * 0.5, p.y + Math.sin(p.lineAng) * p.lineLen * 0.5);
      ctx.stroke();
    } else if (p.isDiamond) {
      // Diamond/rhombus crystal
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spinAng || 0);
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 5 * glowScale;
      ctx.strokeStyle = p.color;
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha * 0.4;
      const s = p.size;
      ctx.beginPath();
      ctx.moveTo(0, -s);
      ctx.lineTo(s * 0.6, 0);
      ctx.lineTo(0, s);
      ctx.lineTo(-s * 0.6, 0);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    } else if (p.isSnowflake) {
      // Six-pointed snowflake cross
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spinAng || 0);
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 5 * glowScale;
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1;
      const s = p.size;
      for (let arm = 0; arm < 6; arm++) {
        const a = (arm / 6) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a) * s, Math.sin(a) * s);
        ctx.stroke();
        // Small barbs at 60% length
        const bx = Math.cos(a) * s * 0.6, by = Math.sin(a) * s * 0.6;
        const bLen = s * 0.3;
        const b1 = a + 0.5, b2 = a - 0.5;
        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(bx + Math.cos(b1) * bLen, by + Math.sin(b1) * bLen);
        ctx.moveTo(bx, by);
        ctx.lineTo(bx + Math.cos(b2) * bLen, by + Math.sin(b2) * bLen);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      ctx.restore();
    } else if (p.isPlus) {
      // Plus sign particle (Bio-Hull)
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1.5;
      const s = p.size * 0.6;
      ctx.beginPath();
      ctx.moveTo(p.x - s, p.y); ctx.lineTo(p.x + s, p.y);
      ctx.moveTo(p.x, p.y - s); ctx.lineTo(p.x, p.y + s);
      ctx.stroke();
    } else {
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // ── ANIME FINALE EFFECTS ──
  if (finaleMode && finaleDeath) {
    const t = finaleTimer;

    // WHITE FLASH on impact
    if (finaleFlash > 0) {
      ctx.fillStyle = `rgba(255,255,255,${finaleFlash * 0.9})`;
      ctx.fillRect(0, 0, W, H);
    }

    // Screen-space position of death
    const dx = (finaleDeath.x - cameraX) * camZoom + W/2;
    const dy = (finaleDeath.y - cameraY) * camZoom + H/2;

    // SPEED LINES radiating from kill point
    if (t < 3) {
      const lineAlpha = Math.max(0, 1 - t / 3);
      const numLines = 60;
      ctx.save();
      ctx.globalAlpha = lineAlpha * 0.6;
      for (let i = 0; i < numLines; i++) {
        const a = (i / numLines) * Math.PI * 2 + t * 0.3;
        const innerR = 40 + t * 100;
        const outerR = innerR + 200 + Math.random() * 300;
        const thickness = 1 + Math.random() * 2;
        ctx.strokeStyle = i % 3 === 0 ? finaleDeath.killerColor : (i % 3 === 1 ? '#fff' : finaleDeath.color);
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(dx + Math.cos(a) * innerR, dy + Math.sin(a) * innerR);
        ctx.lineTo(dx + Math.cos(a) * outerR, dy + Math.sin(a) * outerR);
        ctx.stroke();
      }
      ctx.restore();
    }

    // IMPACT RINGS
    if (t < 2) {
      const numRings = 3;
      for (let i = 0; i < numRings; i++) {
        const ringT = t - i * 0.15;
        if (ringT < 0) continue;
        const ringR = ringT * 400;
        const ringAlpha = Math.max(0, 1 - ringT / 1.5);
        ctx.strokeStyle = i === 0 ? '#fff' : finaleDeath.killerColor;
        ctx.globalAlpha = ringAlpha * 0.5;
        ctx.lineWidth = 3 - i;
        ctx.beginPath();
        ctx.arc(dx, dy, ringR, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // DRAMATIC VIGNETTE
    const vGrad = ctx.createRadialGradient(dx, dy, W * 0.1, W / 2, H / 2, W * 0.8);
    vGrad.addColorStop(0, 'transparent');
    vGrad.addColorStop(1, `rgba(0,0,0,${Math.min(0.7, t * 0.3)})`);
    ctx.fillStyle = vGrad;
    ctx.fillRect(0, 0, W, H);

    // WINNER TEXT — slides in after a beat
    if (t > 1.2) {
      const textT = t - 1.2;
      const textAlpha = Math.min(1, textT * 2);
      const slideX = Math.max(0, 30 - textT * 60);

      const w = ships.find(s => s.alive);
      // In team mode, show winning team name and color
      let winName = w ? w.name : null;
      let winColor = w ? w.color : null;
      if (matchMode === 'teams' && w && w.team > 0) {
        winName = teamNames[w.team - 1] || winName;
        const tc = getTeamColors();
        winColor = tc[w.team - 1] || winColor;
      }
      if (winName) {
        ctx.save();
        ctx.globalAlpha = textAlpha;

        // Glowing name
        ctx.font = '900 56px "Orbitron"';
        ctx.textAlign = 'center';
        ctx.shadowColor = winColor;
        ctx.shadowBlur = (40) * glowScale;
        ctx.fillStyle = winColor;
        ctx.fillText(winName, W/2 + slideX, H/2);
        ctx.shadowBlur = 0;

        // "WINS" subtitle
        ctx.font = '400 16px "Orbitron"';
        ctx.fillStyle = `rgba(255,255,255,${textAlpha * 0.6})`;
        ctx.letterSpacing = '12px';
        ctx.fillText('W I N S', W/2 + slideX, H/2 + 35);

        ctx.restore();
      } else {
        ctx.save();
        ctx.globalAlpha = textAlpha;
        ctx.font = '900 56px "Orbitron"';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#888';
        ctx.shadowBlur = (40) * glowScale;
        ctx.fillStyle = '#888';
        ctx.fillText('DRAW', W/2 + slideX, H/2);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // Chromatic aberration-style color split on edges during the flash
    if (t < 0.5) {
      const abAmount = (0.5 - t) * 8;
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = (0.5 - t) * 0.3;
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(abAmount, 0, W, H);
      ctx.fillStyle = '#0000ff';
      ctx.fillRect(-abAmount, 0, W, H);
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
    }
  }

  // ── SELECTION BOX ──
  if (isSelecting && selectBoxStart && selectBoxEnd) {
    const x = Math.min(selectBoxStart.x, selectBoxEnd.x);
    const y = Math.min(selectBoxStart.y, selectBoxEnd.y);
    const w = Math.abs(selectBoxEnd.x - selectBoxStart.x);
    const h = Math.abs(selectBoxEnd.y - selectBoxStart.y);
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 1;
    ctx.setLineDash([6, 4]);
    ctx.strokeRect(x, y, w, h);
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    ctx.fillRect(x, y, w, h);
  }

  // ── SCOREBOARD HUD ──
  // (scoreboard HUD removed for cleaner look)
}

// ─── STARS ────────────────────────────────────────────────────
let stars = [];
function initStars() {
  for (let i = 0; i < 700; i++) {
    stars.push({
      x: rand(0, CFG.WORLD_W),
      y: rand(0, CFG.WORLD_H),
      s: rand(0.5, 2),
      b: rand(0.4, 1.0),
    });
  }
}

function drawStars() {
  for (const star of stars) {
    ctx.fillStyle = `rgba(255,255,255,${star.b * (0.5 + 0.5 * Math.sin(gameTime * 0.5 + star.x))})`;
    ctx.fillRect(star.x, star.y, star.s, star.s);
  }
}

function lerpHexColor(c1, c2, t) {
  const h = s => parseInt(s.slice(1), 16);
  const v1 = h(c1), v2 = h(c2);
  const r1 = (v1>>16)&0xff, g1 = (v1>>8)&0xff, b1 = v1&0xff;
  const r2 = (v2>>16)&0xff, g2 = (v2>>8)&0xff, b2 = v2&0xff;
  const r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
  return '#' + ((1<<24)|(r<<16)|(g<<8)|b).toString(16).slice(1);
}

function getTeamColors() {
  // Pick most common color from each team, avoiding duplicates
  const result = [];
  const used = new Set();
  for (let t = 0; t < teamAssignments.length; t++) {
    const freq = {};
    const teamShips = ships.filter(s => s.team === t + 1);
    for (const s of teamShips) {
      const c = s.origColor;
      freq[c] = (freq[c] || 0) + 1;
    }
    let best = null, bestN = 0;
    for (const [c, n] of Object.entries(freq)) {
      if (used.has(c)) continue;
      if (n > bestN) { bestN = n; best = c; }
    }
    if (!best) {
      for (const [c, n] of Object.entries(freq)) if (n > bestN || !best) { bestN = n; best = c; }
    }
    if (!best) best = TEAM_COLORS[t] || '#888';
    result.push(best);
    used.add(best);
  }
  return result;
}

function buildPregameRoster() {
  const el = document.getElementById('pregame-roster');
  el.innerHTML = '';
  for (let i = 0; i < ships.length; i++) {
    const ship = ships[i];
    const tag = document.createElement('div');
    tag.className = 'roster-tag';
    tag.style.borderColor = ship.color + '55';
    tag.style.background = ship.color + '11';
    tag.style.animationDelay = `${i * 0.06}s`;
    tag.appendChild(createShipIcon(ship.shipType, ship.color, 22, false));
    const nameSpan = document.createElement('span');
    nameSpan.style.color = ship.color;
    if (ship.name === 'MAGENTA') nameSpan.style.marginLeft = '2px';
    nameSpan.textContent = ship.name;
    tag.appendChild(nameSpan);
    el.appendChild(tag);
  }
}


// ─── TEAM BUILDER UI ─────────────────────────────────────────
let teamBuilderTarget = 0; // which team index gets next ship click

function setMatchModeUI(mode) {
  matchMode = mode;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
  const roster = document.getElementById('pregame-roster');
  const builder = document.getElementById('team-builder');
  const startBtn = document.getElementById('start-btn');
  const shipCountRow = document.getElementById('ship-count-selector');

  if (mode === 'tournament') {
    // Open tournament overlay, hide pregame
    document.getElementById('pregame-overlay').classList.add('hidden');
    document.getElementById('tournament-overlay').classList.add('active');
    document.getElementById('tourney-bracket-title').textContent = 'TOURNAMENT';
    document.getElementById('tourney-bracket-title').style.color = '#fff';
    document.getElementById('tourney-bracket-subtitle').textContent = 'SINGLE ELIMINATION';
    renderBracket();
    return;
  }

  if (mode === 'ffa') {
    roster.style.display = 'grid';
    builder.classList.remove('active');
    startBtn.textContent = 'START MATCH';
    startBtn.disabled = false;
  } else {
    roster.style.display = 'none';
    builder.classList.add('active');
    // Initialize teams if empty
    if (teamAssignments.length < 2) {
      teamAssignments = [[], []];
      teamNames = ['TEAM 1', 'TEAM 2'];
      teamWeapons = [[], []];
      teamPassives = [[], []];
      teamManeuvers = [[], []];
      teamShipDesigns = [[], []];
      teamBuilderTarget = 0;
    }
    // Team mode active
    renderTeamBuilder();
  }
}

let _activeWpnDropdown = null;
function closeWeaponDropdown() {
  if (_activeWpnDropdown) { _activeWpnDropdown.remove(); _activeWpnDropdown = null; }
}
function toggleLoadoutDropdown(teamIdx, btn, type) {
  const ddKey = `${type}-${teamIdx}`;
  if (_activeWpnDropdown && _activeWpnDropdown._ddKey === ddKey) {
    closeWeaponDropdown(); return;
  }
  closeWeaponDropdown();
  const dd = document.createElement('div');
  dd.className = 'team-wpn-dropdown';
  dd._ddKey = ddKey;

  let keys, defs, stateArr;
  if (type === 'designs') { keys = SHIP_DESIGN_KEYS; defs = SHIP_DESIGN_DEFS; stateArr = teamShipDesigns; }
  else if (type === 'weapons') { keys = Object.keys(WEAPON_DEFS); defs = WEAPON_DEFS; stateArr = teamWeapons; }
  else if (type === 'passives') { keys = PASSIVE_KEYS; defs = PASSIVE_DEFS; stateArr = teamPassives; }
  else { keys = MANEUVER_KEYS; defs = MANEUVER_DEFS; stateArr = teamManeuvers; }

  for (const key of keys) {
    const item = document.createElement('label');
    item.className = 'team-wpn-item';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = stateArr[teamIdx].includes(key);
    cb.onchange = () => {
      if (cb.checked) {
        if (!stateArr[teamIdx].includes(key)) stateArr[teamIdx].push(key);
      } else {
        stateArr[teamIdx] = stateArr[teamIdx].filter(k => k !== key);
      }
      const allBtns = document.querySelectorAll(`.team-wpn-btn[data-type="${type}"][data-team="${teamIdx}"]`);
      const b = allBtns[0];
      if (b) {
        const count = stateArr[teamIdx].length;
        const icon = type === 'designs' ? '🚀' : type === 'weapons' ? '⚔' : type === 'passives' ? '◈' : '↻';
        b.textContent = count === 0 ? icon : count === 1 ? defs[stateArr[teamIdx][0]]?.name || stateArr[teamIdx][0] : `${icon}${count}`;
        b.classList.toggle('active', count > 0);
      }
      // Live-update slot icons when designs change
      if (type === 'designs') {
        const col = b?.closest('.team-col');
        if (col) {
          const slots = col.querySelectorAll('.team-slot');
          const designs = stateArr[teamIdx] || [];
          slots.forEach((slot, si) => {
            const shipIdx = teamAssignments[teamIdx][si];
            if (shipIdx === undefined) return;
            const oldIcon = slot.querySelector('.ship-icon, svg');
            if (oldIcon) {
              const designIdx = designs.length > 0 ? parseInt(designs[si % designs.length]) : shipIdx;
              const newIcon = createShipIcon(designIdx, PILOT_COLORS[shipIdx], 22);
              slot.replaceChild(newIcon, oldIcon);
            }
          });
        }
      }
    };
    item.appendChild(cb);
    const label = document.createElement('span');
    if (type === 'designs') {
      const colorIdx = parseInt(key);
      // Add inline SVG ship icon
      const iconSvg = createShipIconSVG(colorIdx, PILOT_COLORS[colorIdx], 16);
      if (iconSvg) {
        iconSvg.style.flexShrink = '0';
        item.appendChild(iconSvg);
      }
      label.style.color = PILOT_COLORS[colorIdx];
      label.textContent = defs[key].name;
    } else {
      label.textContent = defs[key].name;
    }
    item.appendChild(label);
    dd.appendChild(item);
  }

  const rect = btn.getBoundingClientRect();
  dd.style.position = 'fixed';
  dd.style.top = rect.bottom + 2 + 'px';
  const leftPos = Math.min(rect.left, window.innerWidth - 140);
  dd.style.left = Math.max(0, leftPos) + 'px';
  document.body.appendChild(dd);
  _activeWpnDropdown = dd;
}
document.addEventListener('click', (e) => {
  if (_activeWpnDropdown && !_activeWpnDropdown.contains(e.target) && !e.target.classList.contains('team-wpn-btn')) {
    closeWeaponDropdown();
  }
});

function renderTeamBuilder() {
  // Ship picker grid
  const picker = document.getElementById('ship-picker');
  picker.innerHTML = '';
  const assignedShips = new Set(teamAssignments.flat());
  for (let i = 0; i < PILOT_NAMES.length; i++) {
    const el = document.createElement('div');
    el.className = 'picker-ship';
    el.appendChild(createShipIcon(i, PILOT_COLORS[i], 22));
    const name = document.createElement('span');
    name.style.color = PILOT_COLORS[i];
    name.textContent = PILOT_NAMES[i];
    el.appendChild(name);
    el.onclick = () => addShipToTeam(i);
    picker.appendChild(el);
  }

  // Team columns
  const colArea = document.getElementById('team-columns');
  colArea.innerHTML = '';
  const tc = teamAssignments.length > 0 ? getTeamBuilderColors() : TEAM_COLORS;

  for (let t = 0; t < teamAssignments.length; t++) {
    const col = document.createElement('div');
    col.className = 'team-col';
    col.style.borderColor = (tc[t] || '#888') + '40';

    // Header
    const header = document.createElement('div');
    header.className = 'team-col-header';
    header.id = 'team-header-' + t;
    header.style.color = tc[t] || '#888';
    header.textContent = teamNames[t];
    header.ondblclick = () => editTeamName(t);
    col.appendChild(header);

    // Per-team loadout selectors
    const loadoutRow = document.createElement('div');
    loadoutRow.className = 'team-loadout-row';
    const loadoutTypes = [
      { type: 'designs', arr: teamShipDesigns, defs: SHIP_DESIGN_DEFS, icon: '🚀' },
      { type: 'weapons', arr: teamWeapons, defs: WEAPON_DEFS, icon: '⚔' },
      { type: 'passives', arr: teamPassives, defs: PASSIVE_DEFS, icon: '◈' },
      { type: 'maneuvers', arr: teamManeuvers, defs: MANEUVER_DEFS, icon: '↻' },
    ];
    for (const lt of loadoutTypes) {
      const btn = document.createElement('div');
      btn.className = 'team-wpn-btn' + (lt.arr[t] && lt.arr[t].length > 0 ? ' active' : '');
      btn.setAttribute('data-type', lt.type);
      btn.setAttribute('data-team', t);
      btn.title = lt.type.charAt(0).toUpperCase() + lt.type.slice(1);
      const count = lt.arr[t] ? lt.arr[t].length : 0;
      btn.textContent = count === 0 ? lt.icon : count === 1 ? lt.defs[lt.arr[t][0]]?.name || lt.arr[t][0] : `${lt.icon}${count}`;
      const _type = lt.type, _t = t;
      btn.onclick = (e) => { e.stopPropagation(); toggleLoadoutDropdown(_t, btn, _type); };
      loadoutRow.appendChild(btn);
    }
    col.appendChild(loadoutRow);

    // Slots area (fixed height, items shrink beyond 10)
    const slotsArea = document.createElement('div');
    slotsArea.className = 'team-slots-area';

    // Filled slots
    const designs = teamShipDesigns[t] || [];
    for (let i = 0; i < teamAssignments[t].length; i++) {
      const si = teamAssignments[t][i];
      const slot = document.createElement('div');
      slot.className = 'team-slot';
      // If designs are overridden, show the design icon instead
      if (designs.length > 0) {
        const designIdx = parseInt(designs[i % designs.length]);
        slot.appendChild(createShipIcon(designIdx, PILOT_COLORS[si], 22));
      } else {
        slot.appendChild(createShipIcon(si, PILOT_COLORS[si], 22));
      }
      const name = document.createElement('span');
      name.className = 'team-slot-name';
      name.style.color = PILOT_COLORS[si];
      name.textContent = PILOT_NAMES[si];
      slot.appendChild(name);
      const rem = document.createElement('span');
      rem.className = 'team-slot-remove';
      rem.textContent = '✕';
      const slotIdx = i;
      rem.onclick = (e) => { e.stopPropagation(); removeFromTeam(t, slotIdx); };
      slot.appendChild(rem);
      slotsArea.appendChild(slot);
    }

    col.appendChild(slotsArea);

    // "Add" slot
    const addSlot = document.createElement('div');
    addSlot.className = 'team-add-slot' + (teamBuilderTarget === t ? ' target' : '');
    addSlot.textContent = '+ Add';
    addSlot.onclick = () => { teamBuilderTarget = t; renderTeamBuilder(); };
    col.appendChild(addSlot);

    // Remove team button (if >2 teams)
    if (teamAssignments.length > 2) {
      const remBtn = document.createElement('div');
      remBtn.className = 'team-col-remove';
      remBtn.textContent = '✕ remove';
      remBtn.onclick = () => removeTeamFromBuilder(t);
      col.appendChild(remBtn);
    }
    colArea.appendChild(col);
  }

  // Add team button
  if (teamAssignments.length < MAX_TEAMS) {
    const addCol = document.createElement('div');
    addCol.className = 'add-team-col';
    addCol.textContent = '+ TEAM';
    addCol.onclick = addTeamToBuilder;
    colArea.appendChild(addCol);
  }

  // Update start button
  updateTeamStartButton();
}

function getTeamBuilderColors() {
  // For builder UI, use default team colors (no ships assigned yet for color detection)
  const result = [];
  for (let t = 0; t < teamAssignments.length; t++) {
    if (teamAssignments[t].length > 0) {
      // Pick most common color in this team
      const freq = {};
      for (const idx of teamAssignments[t]) {
        const c = PILOT_COLORS[idx];
        freq[c] = (freq[c] || 0) + 1;
      }
      let best = null, bestN = 0;
      for (const [c, n] of Object.entries(freq)) {
        if (n > bestN) { bestN = n; best = c; }
      }
      result.push(best || TEAM_COLORS[t]);
    } else {
      result.push(TEAM_COLORS[t]);
    }
  }
  return result;
}

function addShipToTeam(shipIdx) {
  teamAssignments[teamBuilderTarget].push(shipIdx);
  renderTeamBuilder();
}

function removeFromTeam(teamIdx, slotIdx) {
  if (slotIdx >= 0 && slotIdx < teamAssignments[teamIdx].length) {
    teamAssignments[teamIdx].splice(slotIdx, 1);
  }
  renderTeamBuilder();
}

function addTeamToBuilder() {
  if (teamAssignments.length >= MAX_TEAMS) return;
  teamAssignments.push([]);
  teamNames.push('TEAM ' + teamAssignments.length);
  teamWeapons.push([]);
  teamPassives.push([]);
  teamManeuvers.push([]);
  teamShipDesigns.push([]);
  teamBuilderTarget = teamAssignments.length - 1;
  renderTeamBuilder();
}

function removeTeamFromBuilder(t) {
  if (teamAssignments.length <= 2) return;
  teamAssignments.splice(t, 1);
  teamNames.splice(t, 1);
  teamWeapons.splice(t, 1);
  teamPassives.splice(t, 1);
  teamManeuvers.splice(t, 1);
  teamShipDesigns.splice(t, 1);
  if (teamBuilderTarget >= teamAssignments.length) teamBuilderTarget = teamAssignments.length - 1;
  renderTeamBuilder();
}

function editTeamName(t) {
  const header = document.getElementById('team-header-' + t);
  if (!header) return;
  const tc = getTeamBuilderColors();
  const input = document.createElement('input');
  input.type = 'text';
  input.value = teamNames[t];
  input.maxLength = 16;
  input.style.cssText = 'background:transparent; border:none; border-bottom:1px solid ' + (tc[t] || '#fff') + '80; color:inherit; font-family:Orbitron,sans-serif; font-size:inherit; font-weight:inherit; letter-spacing:inherit; text-align:center; width:100%; outline:none; padding:0;';
  const commit = () => {
    const val = input.value.trim();
    teamNames[t] = val || ('TEAM ' + (t + 1));
    header.textContent = teamNames[t];
  };
  input.addEventListener('blur', commit);
  input.addEventListener('keydown', (e) => { if (e.key === 'Enter') input.blur(); });
  header.textContent = '';
  header.appendChild(input);
  input.focus();
  input.select();
}

// ─── TOURNAMENT MODE ─────────────────────────────────────────
let tourneySize = 8;
let tourneyTeams = []; // array of { name, ships:[], weapons:[], passives:[], maneuvers:[], designs:[], color:null }
let tourneyBracket = []; // array of rounds, each round = array of matches {team1idx, team2idx, winnerIdx}
let tourneyRound = 0;
let tourneyMatchIdx = 0;
let tourneyActive = false; // true = tournament is in progress (playing matches)
let tourneyAnimating = false; // true = bracket transition animation in progress
let tourneyBaseScale = 1; // stored auto-scale factor for zoom in/out
let tourneyEliminated = new Set(); // team indices that have been eliminated (for persistent dim)
let tourneyModalSlot = -1; // which bracket slot is being edited
let _tourneyModalShips = [];
let _tourneyModalWeapons = [];
let _tourneyModalPassives = [];
let _tourneyModalManeuvers = [];
let _tourneyModalDesigns = [];

function setTourneySize(n) {
  tourneySize = n;
  document.querySelectorAll('.tourney-size-btn').forEach(b =>
    b.classList.toggle('active', parseInt(b.dataset.size) === n)
  );
  initTourneyTeams();
  buildBracket();
  renderBracket();
}

function initTourneyTeams() {
  // Preserve existing teams that fit, pad or trim
  const old = tourneyTeams.slice(0, tourneySize);
  tourneyTeams = [];
  for (let i = 0; i < tourneySize; i++) {
    if (old[i]) {
      tourneyTeams.push(old[i]);
    } else {
      tourneyTeams.push({ name: '', ships: [], weapons: [], passives: [], maneuvers: [], designs: [], color: null });
    }
  }
  tourneyRound = 0;
  tourneyMatchIdx = 0;
  tourneyActive = false;
}

function buildBracket() {
  tourneyBracket = [];
  let teamsInRound = tourneySize;
  while (teamsInRound > 1) {
    const matches = [];
    for (let i = 0; i < teamsInRound / 2; i++) {
      matches.push({ team1: null, team2: null, winner: null });
    }
    tourneyBracket.push(matches);
    teamsInRound /= 2;
  }
  // Seed first round
  if (tourneyBracket.length > 0) {
    for (let i = 0; i < tourneyBracket[0].length; i++) {
      tourneyBracket[0][i].team1 = i * 2;
      tourneyBracket[0][i].team2 = i * 2 + 1;
    }
  }
}

function getTourneyTeamLabel(idx) {
  if (idx === null || idx === undefined) return null;
  const t = tourneyTeams[idx];
  if (!t) return null;
  if (t.name) return t.name;
  if (t.ships.length > 0) return t.ships.map(si => PILOT_NAMES[si]).join('/');
  return null;
}

function getTourneyTeamColor(idx) {
  if (idx === null || idx === undefined) return 'rgba(255,255,255,0.15)';
  const t = tourneyTeams[idx];
  if (!t || t.ships.length === 0) return 'rgba(255,255,255,0.15)';
  if (t.color) return t.color;
  // Use first ship's color
  return PILOT_COLORS[t.ships[0]] || '#888';
}

function getRoundName(roundIdx, totalRounds) {
  const fromFinal = totalRounds - 1 - roundIdx;
  if (fromFinal === 0) return 'FINAL';
  if (fromFinal === 1) return 'SEMIS';
  if (fromFinal === 2) return 'QUARTERS';
  return 'ROUND ' + (roundIdx + 1);
}

function renderBracket() {
  const container = document.getElementById('bracket-container');
  container.innerHTML = '';
  if (tourneyBracket.length === 0) return;

  const totalRounds = tourneyBracket.length;
  const isLarge = tourneySize >= 32;
  const isHuge = tourneySize >= 64;
  const slotH = isHuge ? 34 : isLarge ? 40 : 48;
  const slotW = isHuge ? 100 : isLarge ? 120 : 140;
  const connW = isHuge ? 14 : isLarge ? 18 : 24;
  const fontSize = isHuge ? '8px' : isLarge ? '9px' : '10px';
  const lineColor = 'rgba(255,255,255,0.15)';
  const matchGap = 2;
  const matchH = slotH * 2 + matchGap;
  const cellPad = isHuge ? 2 : isLarge ? 3 : 4;
  const cellH0 = matchH + cellPad * 2;

  const halfRounds = totalRounds - 1; // rounds per half (excluding final)

  // Get match indices for a given half of a round
  function getHalfMatchIndices(roundIdx, side) {
    const count = tourneyBracket[roundIdx].length;
    const half = Math.ceil(count / 2);
    if (side === 'left') return Array.from({length: half}, (_, i) => i);
    return Array.from({length: count - half}, (_, i) => half + i);
  }

  // Create a single bracket slot element
  function makeSlot(teamIdx, match, roundIdx, globalMatchIdx, isTop) {
    const slot = document.createElement('div');
    slot.className = 'bracket-slot' + (isTop ? ' slot-top' : ' slot-bot');
    slot.style.minWidth = slotW + 'px';
    slot.style.fontSize = fontSize;
    if (teamIdx !== null) slot.dataset.team = teamIdx;

    const teamLabel = getTourneyTeamLabel(teamIdx);
    const teamColor = getTourneyTeamColor(teamIdx);
    const isFilled = teamIdx !== null && tourneyTeams[teamIdx] && tourneyTeams[teamIdx].ships.length > 0;
    const isWinner = match.winner !== null && match.winner === teamIdx;
    const isLoser = match.winner !== null && match.winner !== teamIdx && teamIdx !== null;
    const isCurrentMatch = tourneyActive && roundIdx === tourneyRound && globalMatchIdx === tourneyMatchIdx && match.winner === null;

    if (isWinner) slot.classList.add('winner');
    if (isFilled) slot.classList.add('filled');
    if (isCurrentMatch) slot.classList.add('current-match');
    // Use persistent eliminated state during tournaments, .loser outside
    if (isLoser) {
      if (tourneyActive || tourneyAnimating) {
        if (tourneyEliminated.has(teamIdx)) slot.classList.add('eliminated');
      } else {
        slot.classList.add('loser');
      }
    }

    // Colored border
    if (isFilled) {
      slot.style.borderColor = teamColor + '55';
      if (isCurrentMatch) slot.style.borderColor = 'rgba(68,255,136,0.5)';
    }

    // Top row: [seed] dot name
    const topRow = document.createElement('div');
    topRow.className = 'slot-top-row';

    const name = document.createElement('span');
    name.className = 'slot-name';
    if (teamLabel) {
      name.textContent = teamLabel;
      name.style.color = isFilled ? teamColor : 'rgba(255,255,255,0.3)';
    } else {
      name.textContent = teamIdx !== null ? 'EMPTY' : '—';
      name.style.color = 'rgba(255,255,255,0.2)';
    }
    topRow.appendChild(name);
    slot.appendChild(topRow);

    // Bottom row: ship vector icons
    if (isFilled) {
      const shipsRow = document.createElement('div');
      shipsRow.className = 'slot-ships-row';
      const team = tourneyTeams[teamIdx];
      const designs = team.designs || [];
      const iconSize = isHuge ? 12 : isLarge ? 14 : 16;
      team.ships.forEach((si, idx) => {
        const designIdx = designs.length > 0 ? parseInt(designs[idx % designs.length]) : si;
        shipsRow.appendChild(createShipIconSVG(designIdx, PILOT_COLORS[si], iconSize));
      });
      slot.appendChild(shipsRow);
    }

    if (roundIdx === 0 && !tourneyActive && teamIdx !== null) {
      slot.onclick = () => openTourneyTeamModal(teamIdx);
      slot.title = 'Click to edit team';
    } else {
      slot.style.cursor = 'default';
    }
    if (teamIdx !== null) slot.dataset.teamIdx = teamIdx;
    return slot;
  }

  // Create a connector column between rounds
  // side='left': merges rightward (┐├┘), side='right': merges leftward (┌┤└)
  function makeConnectors(sourceRoundIdx, side, numGroups) {
    const col = document.createElement('div');
    col.style.cssText = `display:flex; flex-direction:column; width:${connW}px; flex-shrink:0;`;
    const groupH = cellH0 * Math.pow(2, sourceRoundIdx + 1);

    for (let g = 0; g < numGroups; g++) {
      const group = document.createElement('div');
      group.style.cssText = `height:${groupH}px; display:flex; flex-shrink:0;`;

      if (side === 'left') {
        // Merge part: ┐ over ┘
        const merge = document.createElement('div');
        merge.style.cssText = 'flex:1; display:flex; flex-direction:column;';
        const top = document.createElement('div');
        top.style.cssText = `flex:1; border-bottom:1px solid ${lineColor}; border-right:1px solid ${lineColor};`;
        const bot = document.createElement('div');
        bot.style.cssText = `flex:1; border-top:1px solid ${lineColor}; border-right:1px solid ${lineColor};`;
        merge.appendChild(top);
        merge.appendChild(bot);
        group.appendChild(merge);
        // Exit: horizontal line →
        const exit = document.createElement('div');
        exit.style.cssText = 'flex:1; display:flex; align-items:center;';
        const line = document.createElement('div');
        line.style.cssText = `height:0; width:100%; border-top:1px solid ${lineColor};`;
        exit.appendChild(line);
        group.appendChild(exit);
      } else {
        // Entry: horizontal line ←
        const entry = document.createElement('div');
        entry.style.cssText = 'flex:1; display:flex; align-items:center;';
        const line = document.createElement('div');
        line.style.cssText = `height:0; width:100%; border-top:1px solid ${lineColor};`;
        entry.appendChild(line);
        group.appendChild(entry);
        // Merge part: ┌ over └ (mirrored)
        const merge = document.createElement('div');
        merge.style.cssText = 'flex:1; display:flex; flex-direction:column;';
        const top = document.createElement('div');
        top.style.cssText = `flex:1; border-bottom:1px solid ${lineColor}; border-left:1px solid ${lineColor};`;
        const bot = document.createElement('div');
        bot.style.cssText = `flex:1; border-top:1px solid ${lineColor}; border-left:1px solid ${lineColor};`;
        merge.appendChild(top);
        merge.appendChild(bot);
        group.appendChild(merge);
      }
      col.appendChild(group);
    }
    return col;
  }

  // Build one half of the bracket
  function buildHalf(side) {
    const div = document.createElement('div');
    div.className = 'bracket-half';

    // Left: rounds 0,1,...,halfRounds-1 (R1 far left → semi near center)
    // Right: rounds halfRounds-1,...,1,0 (semi near center → R1 far right)
    const roundSeq = side === 'left'
      ? Array.from({length: halfRounds}, (_, i) => i)
      : Array.from({length: halfRounds}, (_, i) => halfRounds - 1 - i);

    for (let si = 0; si < roundSeq.length; si++) {
      const r = roundSeq[si];
      const matchIdxs = getHalfMatchIndices(r, side);
      const cellH = cellH0 * Math.pow(2, r);

      // Connector before this round (if not first column)
      if (si > 0) {
        const prevR = roundSeq[si - 1];
        if (side === 'left') {
          // prevR → r: prevR pairs merge into r matches
          div.appendChild(makeConnectors(prevR, 'left', matchIdxs.length));
        } else {
          // r pairs merge into prevR (prevR is closer to final, displayed to the left)
          const prevIdxs = getHalfMatchIndices(prevR, side);
          div.appendChild(makeConnectors(r, 'right', prevIdxs.length));
        }
      }

      // Round column
      const roundCol = document.createElement('div');
      roundCol.className = 'bracket-round';
      for (const mi of matchIdxs) {
        const match = tourneyBracket[r][mi];
        const cell = document.createElement('div');
        cell.style.cssText = `height:${cellH}px; display:flex; align-items:center; flex-shrink:0;`;
        const md = document.createElement('div');
        md.className = 'bracket-match';
        md.dataset.round = r;
        md.dataset.match = mi;
        md.appendChild(makeSlot(match.team1, match, r, mi, true));
        md.appendChild(makeSlot(match.team2, match, r, mi, false));
        cell.appendChild(md);
        roundCol.appendChild(cell);
      }
      div.appendChild(roundCol);
    }
    return div;
  }

  // Simple horizontal line connector to/from the final
  function makeHLine() {
    const d = document.createElement('div');
    d.style.cssText = `width:${connW}px; display:flex; align-items:center; flex-shrink:0;`;
    const l = document.createElement('div');
    l.style.cssText = `height:0; width:100%; border-top:1px solid ${lineColor};`;
    d.appendChild(l);
    return d;
  }

  // Assemble: [Left half] [line] [FINAL] [line] [Right half]
  container.appendChild(buildHalf('left'));
  container.appendChild(makeHLine());

  // Final match
  const finalMatch = tourneyBracket[totalRounds - 1][0];
  const finalDiv = document.createElement('div');
  finalDiv.className = 'bracket-final-area';
  const finalLabel = document.createElement('div');
  finalLabel.className = 'bracket-final-label';
  finalLabel.textContent = 'FINAL';
  finalDiv.appendChild(finalLabel);
  const fmd = document.createElement('div');
  fmd.className = 'bracket-match';
  fmd.dataset.round = totalRounds - 1;
  fmd.dataset.match = 0;
  fmd.appendChild(makeSlot(finalMatch.team1, finalMatch, totalRounds - 1, 0, true));
  fmd.appendChild(makeSlot(finalMatch.team2, finalMatch, totalRounds - 1, 0, false));
  finalDiv.appendChild(fmd);
  container.appendChild(finalDiv);

  container.appendChild(makeHLine());
  container.appendChild(buildHalf('right'));

  // Auto-scale bracket to fill available space
  if (!tourneyAnimating) {
    container.style.transition = 'none';
    container.style.transform = '';
    container.style.transformOrigin = 'center center';
    requestAnimationFrame(() => {
      const area = document.getElementById('tourney-bracket-area');
      if (!area) return;
      const areaRect = area.getBoundingClientRect();
      const titleH = (document.getElementById('tourney-bracket-title')?.offsetHeight || 0)
                    + (document.getElementById('tourney-bracket-subtitle')?.offsetHeight || 0) + 24;
      const availW = areaRect.width - 32;
      const availH = areaRect.height - titleH - 16;
      const bracketW = container.scrollWidth;
      const bracketH = container.scrollHeight;
      if (bracketW > 0 && bracketH > 0 && availW > 0 && availH > 0) {
        const scaleX = availW / bracketW;
        const scaleY = availH / bracketH;
        const scale = Math.min(scaleX, scaleY, 1.5);
        tourneyBaseScale = scale;
        container.style.transform = `scale(${scale})`;
      }
      // Commit position, then restore CSS transitions
      container.offsetHeight;
      container.style.transition = '';
    });
  } else {
    // During animation: DOM was rebuilt — restore base scale instantly (no transition)
    container.style.transition = 'none';
    container.style.transform = `scale(${tourneyBaseScale})`;
    container.offsetHeight; // force commit
    container.style.transition = '';
  }

  updateTourneyStatus();
}

function updateTourneyStatus() {
  const statusEl = document.getElementById('tourney-status');
  const startBtn = document.getElementById('tourney-start-btn');
  const filled = tourneyTeams.filter(t => t.ships.length > 0).length;
  statusEl.textContent = `${filled} / ${tourneySize} TEAMS SET`;

  if (tourneyActive) {
    startBtn.textContent = 'IN PROGRESS';
    startBtn.disabled = true;
  } else if (filled === tourneySize) {
    startBtn.textContent = 'BEGIN';
    startBtn.disabled = false;
  } else {
    startBtn.textContent = 'BEGIN';
    startBtn.disabled = true;
  }
}

// ─── Tournament Team Modal ──────────────────────────────────
function openTourneyTeamModal(slotIdx) {
  if (slotIdx === null || slotIdx === undefined) return;
  tourneyModalSlot = slotIdx;
  const team = tourneyTeams[slotIdx];
  _tourneyModalShips = [...team.ships];
  _tourneyModalWeapons = [...team.weapons];
  _tourneyModalPassives = [...team.passives];
  _tourneyModalManeuvers = [...team.maneuvers];
  _tourneyModalDesigns = [...(team.designs || [])];
  document.getElementById('tourney-modal-name-input').value = team.name;
  renderTourneyModal();
  document.getElementById('tourney-team-modal').classList.add('active');
}

function closeTourneyTeamModal() {
  document.getElementById('tourney-team-modal').classList.remove('active');
  tourneyModalSlot = -1;
}

function saveTourneyTeam() {
  if (tourneyModalSlot < 0) return;
  const team = tourneyTeams[tourneyModalSlot];
  team.ships = [..._tourneyModalShips];
  team.weapons = [..._tourneyModalWeapons];
  team.passives = [..._tourneyModalPassives];
  team.maneuvers = [..._tourneyModalManeuvers];
  team.designs = [..._tourneyModalDesigns];
  team.name = document.getElementById('tourney-modal-name-input').value.trim();
  // Auto color from first ship
  team.color = team.ships.length > 0 ? PILOT_COLORS[team.ships[0]] : null;
  closeTourneyTeamModal();
  renderBracket();
}

function renderTourneyModal() {
  // Ship picker
  const picker = document.getElementById('tourney-modal-picker');
  picker.innerHTML = '';
  for (let i = 0; i < PILOT_NAMES.length; i++) {
    const el = document.createElement('div');
    el.className = 'picker-ship';
    el.appendChild(createShipIcon(i, PILOT_COLORS[i], 22));
    const name = document.createElement('span');
    name.style.color = PILOT_COLORS[i];
    name.textContent = PILOT_NAMES[i];
    el.appendChild(name);
    const _i = i;
    el.onclick = () => { _tourneyModalShips.push(_i); renderTourneyModal(); };
    picker.appendChild(el);
  }

  // Current slots
  const slotsEl = document.getElementById('tourney-modal-slots');
  slotsEl.innerHTML = '';
  if (_tourneyModalShips.length === 0) {
    slotsEl.innerHTML = '<span style="color:rgba(255,255,255,0.2); font-size:10px;">No fighters added yet</span>';
  } else {
    _tourneyModalShips.forEach((si, idx) => {
      const chip = document.createElement('div');
      chip.className = 'tourney-modal-ship';
      // Show design override icon if designs are selected
      if (_tourneyModalDesigns.length > 0) {
        const designIdx = parseInt(_tourneyModalDesigns[idx % _tourneyModalDesigns.length]);
        chip.appendChild(createShipIcon(designIdx, PILOT_COLORS[si], 20));
      } else {
        chip.appendChild(createShipIcon(si, PILOT_COLORS[si], 20));
      }
      const n = document.createElement('span');
      n.style.color = PILOT_COLORS[si];
      n.textContent = PILOT_NAMES[si];
      chip.appendChild(n);
      const rem = document.createElement('span');
      rem.className = 'tm-remove';
      rem.textContent = '✕';
      rem.onclick = () => { _tourneyModalShips.splice(idx, 1); renderTourneyModal(); };
      chip.appendChild(rem);
      slotsEl.appendChild(chip);
    });
  }

  // Loadout buttons
  const loadoutsEl = document.getElementById('tourney-modal-loadouts');
  loadoutsEl.innerHTML = '';
  const loadoutTypes = [
    { type: 'designs', arr: _tourneyModalDesigns, defs: SHIP_DESIGN_DEFS, icon: '🚀', keys: SHIP_DESIGN_KEYS },
    { type: 'weapons', arr: _tourneyModalWeapons, defs: WEAPON_DEFS, icon: '⚔', keys: Object.keys(WEAPON_DEFS) },
    { type: 'passives', arr: _tourneyModalPassives, defs: PASSIVE_DEFS, icon: '◈', keys: PASSIVE_KEYS },
    { type: 'maneuvers', arr: _tourneyModalManeuvers, defs: MANEUVER_DEFS, icon: '↻', keys: MANEUVER_KEYS },
  ];
  for (const lt of loadoutTypes) {
    const btn = document.createElement('div');
    btn.className = 'team-wpn-btn' + (lt.arr.length > 0 ? ' active' : '');
    btn.setAttribute('data-type', 'tourney-' + lt.type);
    btn.title = lt.type.charAt(0).toUpperCase() + lt.type.slice(1);
    const count = lt.arr.length;
    btn.textContent = count === 0 ? lt.icon : count === 1 ? lt.defs[lt.arr[0]]?.name || lt.arr[0] : `${lt.icon}${count}`;
    btn.onclick = (e) => { e.stopPropagation(); toggleTourneyLoadoutDropdown(lt, btn); };
    loadoutsEl.appendChild(btn);
  }
}

function toggleTourneyLoadoutDropdown(lt, btn) {
  const ddKey = 'tourney-' + lt.type;
  if (_activeWpnDropdown && _activeWpnDropdown._ddKey === ddKey) {
    closeWeaponDropdown(); return;
  }
  closeWeaponDropdown();
  const dd = document.createElement('div');
  dd.className = 'team-wpn-dropdown';
  dd._ddKey = ddKey;

  for (const key of lt.keys) {
    const item = document.createElement('label');
    item.className = 'team-wpn-item';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = lt.arr.includes(key);
    cb.onchange = () => {
      if (cb.checked) {
        if (!lt.arr.includes(key)) lt.arr.push(key);
      } else {
        const idx = lt.arr.indexOf(key);
        if (idx >= 0) lt.arr.splice(idx, 1);
      }
      // Update button label
      const count = lt.arr.length;
      btn.textContent = count === 0 ? lt.icon : count === 1 ? lt.defs[lt.arr[0]]?.name || lt.arr[0] : `${lt.icon}${count}`;
      btn.classList.toggle('active', count > 0);
      // Live-update ship chip icons when designs change
      if (lt.type === 'designs') {
        const chips = document.querySelectorAll('#tourney-modal-slots .tourney-modal-ship');
        const designs = lt.arr;
        chips.forEach((chip, ci) => {
          const shipIdx = _tourneyModalShips[ci];
          if (shipIdx === undefined) return;
          const oldIcon = chip.querySelector('.ship-icon, svg');
          if (oldIcon) {
            const designIdx = designs.length > 0 ? parseInt(designs[ci % designs.length]) : shipIdx;
            const newIcon = createShipIcon(designIdx, PILOT_COLORS[shipIdx], 20);
            chip.replaceChild(newIcon, oldIcon);
          }
        });
      }
    };
    item.appendChild(cb);
    const label = document.createElement('span');
    if (lt.type === 'designs') {
      const colorIdx = parseInt(key);
      const iconSvg = createShipIconSVG(colorIdx, PILOT_COLORS[colorIdx], 16);
      if (iconSvg) {
        iconSvg.style.flexShrink = '0';
        item.appendChild(iconSvg);
      }
      label.style.color = PILOT_COLORS[colorIdx];
    }
    label.textContent = lt.defs[key].name;
    item.appendChild(label);
    dd.appendChild(item);
  }

  const rect = btn.getBoundingClientRect();
  dd.style.position = 'fixed';
  dd.style.top = rect.bottom + 2 + 'px';
  dd.style.left = Math.max(0, Math.min(rect.left, window.innerWidth - 140)) + 'px';
  document.body.appendChild(dd);
  _activeWpnDropdown = dd;
}

// ─── Tournament Flow ─────────────────────────────────────────
function startTournament() {
  if (tourneyTeams.some(t => t.ships.length === 0)) return;
  tourneyActive = true;
  tourneyRound = 0;
  tourneyMatchIdx = 0;
  tourneyEliminated.clear();
  buildBracket();
  renderBracket();

  // Show bracket with first match flashing, others dimmed
  const overlay = document.getElementById('tournament-overlay');
  overlay.classList.add('bracket-transition');
  document.getElementById('tourney-sidebar').style.display = 'none';
  const container = document.getElementById('bracket-container');
  container.classList.add('tourney-focus');

  // After a moment, fade out and start first match
  setTimeout(() => {
    container.classList.remove('tourney-focus');
    overlay.classList.remove('active');  // triggers fade-out

    setTimeout(() => {
      overlay.classList.remove('bracket-transition');
      document.getElementById('tourney-sidebar').style.display = '';
      playNextTourneyMatch();
    }, 550);
  }, 2000);
}

function playNextTourneyMatch() {
  if (tourneyRound >= tourneyBracket.length) {
    finishTournament();
    return;
  }
  const round = tourneyBracket[tourneyRound];
  while (tourneyMatchIdx < round.length && round[tourneyMatchIdx].winner !== null) {
    tourneyMatchIdx++;
  }
  if (tourneyMatchIdx >= round.length) {
    advanceTourneyRound();
    return;
  }

  const match = round[tourneyMatchIdx];
  const t1 = tourneyTeams[match.team1];
  const t2 = tourneyTeams[match.team2];

  matchMode = 'teams';
  teamAssignments = [[...t1.ships], [...t2.ships]];
  teamNames = [
    getTourneyTeamLabel(match.team1) || ('TEAM ' + (match.team1 + 1)),
    getTourneyTeamLabel(match.team2) || ('TEAM ' + (match.team2 + 1))
  ];
  teamWeapons = [[...t1.weapons], [...t2.weapons]];
  teamPassives = [[...t1.passives], [...t2.passives]];
  teamManeuvers = [[...t1.maneuvers], [...t2.maneuvers]];
  teamShipDesigns = [[...(t1.designs || [])], [...(t2.designs || [])]];
  settings.numShips = teamAssignments.flat().length;

  document.getElementById('tournament-overlay').classList.remove('active');
  document.getElementById('pregame-overlay').classList.add('hidden');
  pregame = true;

  const roundName = getRoundName(tourneyRound, tourneyBracket.length);
  const banner = document.getElementById('tourney-progress-banner');
  banner.textContent = `${roundName} -- ${teamNames[0]} vs ${teamNames[1]}`;
  banner.classList.add('active');

  document.getElementById('alive-counter').style.display = 'none';
  document.getElementById('camera-mode').style.display = 'none';

  startMatch();
}

function advanceTourneyRound() {
  const round = tourneyBracket[tourneyRound];
  const nextRound = tourneyBracket[tourneyRound + 1];
  if (!nextRound) {
    finishTournament();
    return;
  }
  for (let m = 0; m < round.length; m++) {
    const nextMatchIdx = Math.floor(m / 2);
    const slotInMatch = m % 2;
    if (slotInMatch === 0) {
      nextRound[nextMatchIdx].team1 = round[m].winner;
    } else {
      nextRound[nextMatchIdx].team2 = round[m].winner;
    }
  }
  tourneyRound++;
  tourneyMatchIdx = 0;
  playNextTourneyMatch();
}

function onTourneyMatchEnd() {
  const round = tourneyBracket[tourneyRound];
  const match = round[tourneyMatchIdx];
  if (!match || match.winner !== null) return;

  const teamsAlive = [...new Set(ships.filter(s => s.alive && s.team > 0).map(s => s.team))];
  if (teamsAlive.length === 1) {
    match.winner = teamsAlive[0] === 1 ? match.team1 : match.team2;
  } else {
    const t1Kills = ships.filter(s => s.team === 1).reduce((sum, s) => sum + (s.kills || 0), 0);
    const t2Kills = ships.filter(s => s.team === 2).reduce((sum, s) => sum + (s.kills || 0), 0);
    match.winner = t1Kills >= t2Kills ? match.team1 : match.team2;
  }
}

// ─── BRACKET TRANSITION ANIMATION ─────────────────────────────
function tourneyBracketTransition() {
  tourneyAnimating = true;
  const savedRound = tourneyRound;
  const savedMatch = tourneyMatchIdx;

  // Record result
  onTourneyMatchEnd();
  const match = tourneyBracket[savedRound][savedMatch];
  const winnerIdx = match.winner;
  const loserIdx = winnerIdx === match.team1 ? match.team2 : match.team1;
  const isFinal = savedRound === tourneyBracket.length - 1;
  const roundComplete = tourneyBracket[savedRound].every(m => m.winner !== null);

  // Hide winner overlay and banner
  document.getElementById('winner-overlay').classList.remove('show');
  document.getElementById('tourney-progress-banner').classList.remove('active');
  clearAutoRestart();

  // Prepare bracket while overlay is still hidden
  const overlay = document.getElementById('tournament-overlay');
  overlay.classList.remove('active', 'bracket-transition');
  document.getElementById('tourney-sidebar').style.display = 'none';
  renderBracket();

  const container = document.getElementById('bracket-container');

  // Fade in overlay on next frame
  requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    overlay.classList.add('active', 'bracket-transition');

    // Wait for fade-in, then zoom
    setTimeout(() => {
      zoomToMatch(container, savedRound, savedMatch, () => {
        doElimination();
      });
    }, 550);
  });
  });

  function doElimination() {
    const matchEl = container.querySelector(
      `.bracket-match[data-round="${savedRound}"][data-match="${savedMatch}"]`
    );
    if (!matchEl) { tourneyAnimating = false; return; }

    const loserSlot = matchEl.querySelector(`.bracket-slot[data-team="${loserIdx}"]`);
    const winnerSlot = matchEl.querySelector(`.bracket-slot[data-team="${winnerIdx}"]`);

    // Reset loser to full opacity before flicker
    if (loserSlot) {
      loserSlot.classList.remove('loser');
      loserSlot.style.opacity = '1';
    }

    // Flash loser erratically
    if (loserSlot) loserSlot.classList.add('flash-eliminate');
    if (winnerSlot) winnerSlot.classList.add('highlight-winner');
    playTourneyEliminate();

    setTimeout(() => {
      // Stop flashing, go permanently dim
      if (loserSlot) {
        loserSlot.classList.remove('flash-eliminate');
        loserSlot.style.opacity = '';
        loserSlot.classList.add('eliminated');
      }
      tourneyEliminated.add(loserIdx);

      setTimeout(() => {
        if (isFinal) {
          finishChampionSequence(winnerIdx);
          return;
        }
        // Always zoom out smoothly first, then swap content
        if (!roundComplete) {
          tourneyMatchIdx = savedMatch + 1;
        }
        zoomOut(container, () => {
          afterZoomOut();
        });
      }, 600);
    }, 500);
  }

  function afterZoomOut() {
    // Fade bracket out for content swap
    container.classList.add('fade-content');
    setTimeout(() => {
      // If round complete, advance bracket data
      if (roundComplete) {
        advanceTourneyRound_data();
      }
      renderBracket();

      // If round complete, highlight the advancing winner
      if (roundComplete) {
        requestAnimationFrame(() => {
          const advancedSlots = container.querySelectorAll(
            `.bracket-slot[data-team="${winnerIdx}"]`
          );
          advancedSlots.forEach(s => {
            const m = s.closest('.bracket-match');
            if (m && parseInt(m.dataset.round) === savedRound + 1) {
              s.classList.add('highlight-winner');
              s.style.animation = 'advanceGlow 0.8s ease-out';
            }
          });
        });
      }

      // Fade bracket back in
      requestAnimationFrame(() => {
        container.classList.remove('fade-content');

        // Wait for advance glow if round complete, then show next match focus
        setTimeout(() => {
          showNextMatchFocus();
        }, roundComplete ? 1200 : 400);
      });
    }, 350);
  }

  function showNextMatchFocus() {
    // Fade out, re-render with focus highlights, fade in
    container.classList.add('fade-content');
    setTimeout(() => {
      renderBracket();
      container.classList.add('tourney-focus');
      requestAnimationFrame(() => {
        container.classList.remove('fade-content');

        setTimeout(() => {
          // Fade overlay out, then start next match
          container.classList.remove('tourney-focus');
          overlay.classList.remove('active');

          setTimeout(() => {
            tourneyAnimating = false;
            overlay.classList.remove('bracket-transition');
            document.getElementById('tourney-sidebar').style.display = '';
            playNextTourneyMatch();
          }, 550);
        }, 1800);
      });
    }, 350);
  }
}

// Advance bracket data without starting next match
function advanceTourneyRound_data() {
  const round = tourneyBracket[tourneyRound];
  const nextRound = tourneyBracket[tourneyRound + 1];
  if (!nextRound) return;
  for (let m = 0; m < round.length; m++) {
    const nextMatchIdx = Math.floor(m / 2);
    const slotInMatch = m % 2;
    if (slotInMatch === 0) {
      nextRound[nextMatchIdx].team1 = round[m].winner;
    } else {
      nextRound[nextMatchIdx].team2 = round[m].winner;
    }
  }
  tourneyRound++;
  tourneyMatchIdx = 0;
}

const BRACKET_ZOOM_DURATION = 1200;

function zoomToMatch(container, roundIdx, matchIdx, callback) {
  const matchEl = container.querySelector(
    `.bracket-match[data-round="${roundIdx}"][data-match="${matchIdx}"]`
  );
  if (!matchEl) { if (callback) callback(); return; }

  const containerRect = container.getBoundingClientRect();
  const matchRect = matchEl.getBoundingClientRect();
  const area = document.getElementById('tourney-bracket-area');
  const areaRect = area.getBoundingClientRect();

  const currentScale = tourneyBaseScale || 1;
  // Match center in container's un-scaled coordinate space
  const mcx = (matchRect.left + matchRect.width / 2 - containerRect.left) / currentScale;
  const mcy = (matchRect.top + matchRect.height / 2 - containerRect.top) / currentScale;
  // Container center in un-scaled space
  const ccx = containerRect.width / currentScale / 2;
  const ccy = containerRect.height / currentScale / 2;

  const fullZoom = Math.min(
    (areaRect.width * 0.35) / (matchRect.width / currentScale),
    (areaRect.height * 0.4) / (matchRect.height / currentScale),
    currentScale * 4
  );
  const zoomScale = currentScale + (fullZoom - currentScale) * 0.325; // gentle zoom

  // Translate to center the match, then scale — origin stays fixed at center
  const tx = (ccx - mcx);
  const ty = (ccy - mcy);
  container.style.transform = `translate(${tx}px, ${ty}px) scale(${zoomScale})`;

  setTimeout(() => { if (callback) callback(); }, BRACKET_ZOOM_DURATION + 50);
}

function zoomOut(container, callback) {
  container.style.transform = `scale(${tourneyBaseScale})`;
  setTimeout(() => { if (callback) callback(); }, BRACKET_ZOOM_DURATION + 50);
}

function finishChampionSequence(winnerIdx) {
  // Keep animating true through zoom out
  document.getElementById('alive-counter').style.display = '';
  document.getElementById('camera-mode').style.display = '';

  const container = document.getElementById('bracket-container');
  const overlay = document.getElementById('tournament-overlay');

  // Zoom out, then fade-swap to final state
  zoomOut(container, () => {
    container.classList.add('fade-content');
    setTimeout(() => {
      tourneyAnimating = false;
      tourneyActive = false;
      overlay.classList.remove('bracket-transition');
      overlay.classList.add('champion-screen');
      document.getElementById('tourney-sidebar').style.display = '';
      renderBracket();

      // Find the champion slot and add glow
      requestAnimationFrame(() => {
        const champSlots = container.querySelectorAll(
          `.bracket-slot[data-team="${winnerIdx}"]`
        );
        const finalRound = tourneyBracket.length - 1;
        champSlots.forEach(s => {
          const m = s.closest('.bracket-match');
          if (m && parseInt(m.dataset.round) === finalRound) {
            const champColor = getTourneyTeamColor(winnerIdx);
            s.classList.add('champion-glow');
            s.style.setProperty('--glow-color', champColor + '88');
          }
        });
        container.classList.remove('fade-content');
      });

      // Update title
      const champName = getTourneyTeamLabel(winnerIdx) || 'TEAM ' + (winnerIdx + 1);
      const champColor = getTourneyTeamColor(winnerIdx);
      document.getElementById('tourney-bracket-title').innerHTML = `${champName}`;
      document.getElementById('tourney-bracket-title').style.color = champColor;
      document.getElementById('tourney-bracket-subtitle').textContent = 'TOURNAMENT CHAMPION';

      document.getElementById('tourney-start-btn').textContent = 'NEW TOURNAMENT';
      document.getElementById('tourney-start-btn').disabled = false;
      document.getElementById('tourney-start-btn').onclick = () => {
        tourneyEliminated.clear();
        overlay.classList.remove('champion-screen');
        buildBracket();
        document.getElementById('tourney-bracket-title').textContent = 'TOURNAMENT';
        document.getElementById('tourney-bracket-title').style.color = '#fff';
        document.getElementById('tourney-bracket-subtitle').textContent = 'SINGLE ELIMINATION';
        document.getElementById('tourney-start-btn').onclick = () => startTournament();
        renderBracket();
      };
    }, 350);
  });
}

// Hook into the restart button during tournament (fallback)
function tourneyRestartHandler() {
  if (!tourneyActive) return false;
  clearAutoRestart();
  document.getElementById('winner-overlay').classList.remove('show');
  tourneyBracketTransition();
  return true;
}

function finishTournament() {
  // This is only called if advanceTourneyRound finds no next round
  // and the final hasn't been played yet — it triggers the last match
  // The champion sequence is handled by tourneyBracketTransition for the final
  if (tourneyBracket[tourneyBracket.length - 1][0].winner !== null) {
    // Final already decided, show champion
    const finalMatch = tourneyBracket[tourneyBracket.length - 1][0];
    finishChampionSequence(finalMatch.winner);
  }
}

function exitTournament() {
  if (tourneyActive || tourneyAnimating) {
    if (!confirm('Exit tournament in progress?')) return;
    tourneyActive = false;
    tourneyAnimating = false;
    tourneyEliminated.clear();
  }
  document.getElementById('tournament-overlay').classList.remove('active', 'bracket-transition', 'champion-screen');
  document.getElementById('tourney-sidebar').style.display = '';
  document.getElementById('tourney-progress-banner').classList.remove('active');
  document.getElementById('winner-overlay').classList.remove('show');
  document.getElementById('alive-counter').style.display = '';
  document.getElementById('camera-mode').style.display = '';
  clearAutoRestart();
  matchMode = 'ffa';
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === 'ffa'));
  document.getElementById('pregame-overlay').classList.remove('hidden');
  pregame = true;
  gameOver = false;
  init();
}

// Initialize tournament on first load
initTourneyTeams();
buildBracket();

// Re-scale bracket on window resize
window.addEventListener('resize', () => {
  if (document.getElementById('tournament-overlay').classList.contains('active')) {
    renderBracket();
  }
});

function updateTeamStartButton() {
  const btn = document.getElementById('start-btn');
  if (matchMode !== 'teams') return;
  const filledTeams = teamAssignments.filter(t => t.length >= 1).length;
  const ready = filledTeams >= 2;
  btn.disabled = !ready;
  if (ready) {
    const sizes = teamAssignments.filter(t => t.length > 0).map(t => t.length).join('v');
    btn.textContent = 'FIGHT (' + sizes + ')';
  } else {
    btn.textContent = 'ADD FIGHTERS';
  }
}

function autoFillTeams() {
  const all = Array.from({length: 16}, (_, i) => i);
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  let idx = 0;
  for (let t = 0; t < teamAssignments.length; t++) {
    const count = randInt(2, 5);
    teamAssignments[t] = [];
    for (let i = 0; i < count; i++) teamAssignments[t].push(all[(idx++) % all.length]);
  }
  renderTeamBuilder();
}

document.getElementById('start-btn').addEventListener('click', startMatch);

// ─── SCOREBOARD ───────────────────────────────────────────────
function buildScoreboard() {} // no-op, drawn on canvas now

function updateScoreboard() {} // no-op, drawn on canvas now

let showScoreboard = false;

function drawScoreboard(ctx) {
  if (!showScoreboard) return;

  const half = Math.ceil(ships.length / 2);
  const tagW = 140;
  const gap = 6;
  const hasHP = ships[0] && ships[0].maxHp > 1;

  // How many info lines to show (weapon/passive, maneuver)
  const showLine1 = settings.showWeaponTag || settings.showPassiveTag;
  const showLine2 = settings.showManeuverTag;
  const infoLines = (showLine1 ? 1 : 0) + (showLine2 ? 1 : 0);
  const tagH = 20 + infoLines * 10;

  // Draw a row of player tags
  function drawRow(list, y) {
    const totalW = list.length * tagW + (list.length - 1) * gap;
    let x = (W - totalW) / 2;

    for (const ship of list) {
      const alpha = ship.alive ? 1.0 : 0.25;
      ctx.save();
      ctx.globalAlpha = alpha;

      // Background
      ctx.fillStyle = ship.color + '18';
      ctx.strokeStyle = ship.color + '55';
      ctx.lineWidth = 1;
      ctx.fillRect(x, y, tagW, tagH);
      ctx.strokeRect(x, y, tagW, tagH);

      // Ship shape icon
      const iconSize = 12;
      const iconX = x + 10;
      const iconY = y + 10;
      const verts = getShipVerts(ship.shipType, ship._designForced);
      const ir = iconSize * 0.38;
      ctx.save();
      ctx.translate(iconX, iconY);
      ctx.strokeStyle = ship.color;
      ctx.lineWidth = 1.2;
      ctx.fillStyle = ship.color + '44';
      ctx.beginPath();
      ctx.moveTo(verts[0][0] * ir, verts[0][1] * ir);
      for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i][0] * ir, verts[i][1] * ir);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // Name
      ctx.font = '9px "Share Tech Mono", monospace';
      ctx.fillStyle = ship.alive ? ship.color : 'rgba(255,255,255,0.4)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const nameX = x + 20;
      if (ship.alive) {
        ctx.fillText(ship.name, nameX, y + 10);
      } else {
        // Strikethrough for dead
        const text = ship.name;
        ctx.fillText(text, nameX, y + 10);
        const tw = ctx.measureText(text).width;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(nameX, y + 10);
        ctx.lineTo(nameX + tw, y + 10);
        ctx.stroke();
      }

      // Info lines
      ctx.font = '7px "Share Tech Mono", monospace';
      ctx.fillStyle = ship.alive ? 'rgba(255,255,255,0.35)' : 'rgba(255,255,255,0.15)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      let lineY = y + 20;

      // Line 1: Weapon | Passive (or just one if the other is hidden)
      if (showLine1) {
        const wpnName = settings.showWeaponTag ? (ship.weapon?.name || 'Basic') : null;
        const pasName = settings.showPassiveTag ? (PASSIVE_DEFS[ship.passive]?.name || 'None') : null;
        const line1 = [wpnName, pasName].filter(Boolean).join(' | ');
        ctx.fillText(line1, nameX, lineY);
        lineY += 10;
      }

      // Line 2: Maneuver
      if (showLine2) {
        const manName = MANEUVER_DEFS[ship.maneuver]?.name || 'None';
        ctx.fillText(manName, nameX, lineY);
      }

      // HP bar (if multi-HP)
      if (hasHP) {
        const barX = x + 68;
        const barW = 52;
        const barH = 3;
        const barY = y + 10 - barH / 2;
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(barX, barY, barW, barH);
        const pct = Math.max(0, ship.hp / ship.maxHp);
        const hpColor = pct > 0.5 ? ship.color : pct > 0.25 ? '#ffaa22' : '#ff4444';
        ctx.fillStyle = hpColor;
        ctx.fillRect(barX, barY, barW * pct, barH);
      }

      // Kill count
      ctx.font = '700 9px "Orbitron", sans-serif';
      ctx.fillStyle = ship.color;
      ctx.textAlign = 'right';
      ctx.fillText(ship.kills, x + tagW - 5, y + 10);

      ctx.restore();
      x += tagW + gap;
    }
  }

  drawRow(ships.slice(0, half), 8);
  drawRow(ships.slice(half), H - tagH - 8);
}

// ─── KILLFEED ─────────────────────────────────────────────────
function addKillMessage(killerName, killerColor, victimName, victimColor) {
  const feed = document.getElementById('killfeed');
  const msg = document.createElement('div');
  msg.className = 'kill-msg';
  msg.style.borderLeftColor = killerColor;
  msg.innerHTML = `<span style="color:${killerColor}">${killerName}</span> <span style="color:rgba(255,255,255,0.3)">▸</span> <span style="color:${victimColor}">${victimName}</span>`;
  feed.appendChild(msg);
  setTimeout(() => msg.remove(), 3200);
}

// ─── WINNER ───────────────────────────────────────────────────
let autoRestartInterval = null;

function clearAutoRestart() {
  if (autoRestartInterval) {
    clearInterval(autoRestartInterval);
    autoRestartInterval = null;
  }
  const el = document.getElementById('auto-restart-countdown');
  el.style.display = 'none';
  el.textContent = '';
}

function startMatch() {
  // Chaos mode: randomize settings and reinit
  if (settings.chaosMode) {
    applyChaosMode();
    init();
  } else if (matchMode === 'teams') {
    // Team mode: set numShips to total team members and reinit
    const totalShips = teamAssignments.flat().length;
    if (totalShips < 2) return;
    settings.numShips = totalShips;
    init();
  } else if (ships.length !== settings.numShips) {
    init();
  }
  ensureAudio();
  // ═══ STARCHIP DEMO INTEGRATION ═══
  const _scLineup = localStorage.getItem('starchip_lineup');
  let _starchipConfigs = null;
  let _starchipTeams = false;
  // Check localStorage first, fall back to saved global (rematch)
  const _scRaw = _scLineup || (_starchipSavedLineup ? JSON.stringify(_starchipSavedLineup) : null);
  if (_scRaw) {
    if (_scLineup) localStorage.removeItem('starchip_lineup');
    try {
      const _scData = JSON.parse(_scRaw);
      // Support both array (legacy) and object { ships, teams } format
      const _scShips = Array.isArray(_scData) ? _scData : _scData.ships;
      _starchipTeams = !Array.isArray(_scData) && _scData.teams;
      if (Array.isArray(_scShips) && _scShips.length >= 2) {
        settings.numShips = _scShips.length;
        settings.uniqueShips = true; // force unique ship shapes
        _starchipConfigs = _scShips;
        _starchipSavedLineup = _scData; // save for rematch
        // Set up team mode if requested
        if (_starchipTeams) {
          matchMode = 'teams';
          // Group ships by playerName to build team assignments
          const playerGroups = {};
          _scShips.forEach((s, idx) => {
            const pn = s.playerName || 'Player';
            if (!playerGroups[pn]) playerGroups[pn] = [];
            playerGroups[pn].push(idx);
          });
          // Build teamAssignments: array of arrays of ship indices
          // Here indices refer to position in the flat _scShips array (0..n-1)
          teamAssignments = Object.values(playerGroups);
          // Clear any leftover team weapon/design/passive pools
          teamWeapons = teamAssignments.map(() => []);
          teamShipDesigns = teamAssignments.map(() => []);
          teamPassives = teamAssignments.map(() => []);
          teamManeuvers = teamAssignments.map(() => []);
        } else {
          matchMode = 'ffa';
        }
        init();
      }
    } catch(e) { console.warn('StarChip lineup parse error', e); }
  }
  // ═══ END STARCHIP INTEGRATION ═══
  for (let i = 0; i < ships.length; i++) {
    const ship = ships[i];
    const p = PRESET_PROFILES[ship.shipType];
    ship.hp = settings.shipHP;
    ship.maxHp = settings.shipHP;
    ship.aiBehavior = settings.randomPersonalities ? randomBehavior() : p.behavior;
    ship.aggroPhase = settings.randomPersonalities ? rand(0, Math.PI * 2) : p.aggroPhase;
    ship.aggroSpeed = settings.randomPersonalities ? rand(0.15, 0.4) : p.aggroSpeed;
    ship.rockShooter = settings.randomPersonalities ? rand(0.1, 0.9) : p.rockShooter;
    ship.aimBaseline = settings.randomPersonalities ? rand(0.3, 0.9) : p.aimBaseline;
    ship.aimRange = settings.randomPersonalities ? rand(0.3, 0.5) : p.aimRange;
    ship.aimSpeed = settings.randomPersonalities ? rand(0.3, 0.8) : p.aimSpeed;
    ship.aimPhase = settings.randomPersonalities ? rand(0, Math.PI * 2) : p.aimPhase;
    ship.weapon = getWeapon(ship.shipType, ship.team || 0);
    ship.passive = getPassive(ship.shipType, ship.team || 0);
    ship.maneuver = getManeuver(ship.shipType, ship.team || 0);
    // ═══ STARCHIP OVERRIDE ═══
    if (_starchipConfigs && _starchipConfigs[i]) {
      const _sc = _starchipConfigs[i];
      ship.shipType = _sc.design;
      ship.color = _sc.color;
      ship.origColor = _sc.color;
      ship.name = _sc.playerName || PILOT_NAMES[_sc.design];
      if (WEAPON_DEFS[_sc.weapon]) ship.weapon = {...WEAPON_DEFS[_sc.weapon]};
      if (_sc.passive) ship.passive = _sc.passive;
      if (_sc.maneuver) ship.maneuver = _sc.maneuver;
      // Temperament override
      if (_sc.temperament !== undefined && _sc.temperament >= 0 && _sc.temperament < PRESET_PROFILES.length) {
        const tp = PRESET_PROFILES[_sc.temperament];
        ship.aiBehavior = tp.behavior;
        ship.aggroPhase = tp.aggroPhase;
        ship.aggroSpeed = tp.aggroSpeed;
        ship.rockShooter = tp.rockShooter;
        ship.aimBaseline = tp.aimBaseline;
        ship.aimRange = tp.aimRange;
        ship.aimSpeed = tp.aimSpeed;
        ship.aimPhase = tp.aimPhase;
      }
    }
    // ═══ END STARCHIP OVERRIDE ═══
    ship.maneuverCooldown = rand(3, 8);
    ship.maneuverActive = false;
    ship.maneuverTimer = 0;
    ship.maneuverCount = 0;
    ship._hyperSpeedActive = false;
    ship._teleportPhase = null;
    ship.burstQueue = [];
    ship.r = CFG.SHIP_RADIUS;
    if (ship.passive === 'bioHull') {
      ship.hp += 2;
      ship.maxHp += 2;
    }
    if (ship.passive === 'flagship') {
      ship.hp += 7;
      ship.maxHp += 7;
      ship.r = CFG.SHIP_RADIUS * 2.5;
      ship.maneuver = 'none';
    }
    ship.shieldActive = ship.passive === 'shield';
    if (ship.passive === 'obliterator') {
      ship.rockShooter = Math.min(1, ship.rockShooter + 0.3);
    }
    ship.stunTimer = 0;
    ship.overrideTimer = 0;
    ship.iceSlow = 0;
    ship.jamSlow = 0;
    ship.blindTimer = 0;
    ship.burnTimer = 0; ship.burnDps = 0; ship.iceDotTimer = 0;
    ship._bioRegenTimer = 0;
    ship.lastAttacker = -1;
    ship.lastAttackerTime = 0;
  }
  pregame = false;
  document.getElementById('pregame-overlay').classList.add('hidden');
  document.getElementById('settings-panel').classList.remove('open');

  // Enter countdown phase (skip for match logger to keep data collection fast)
  if (settings.matchLogger) {
    showScoreboard = true;
  } else {
    countdown = true;
    const cdDur = tourneyActive ? 3 : COUNTDOWN_DURATION;
    countdownTimer = cdDur;
    _lastCountdownSec = cdDur;
    playCountdownTick(cdDur);
    buildCountdownRoster();
    document.getElementById('countdown-bets').textContent = matchMode === 'teams' ? 'CHOOSE YOUR TEAM!' : 'PLACE YOUR BETS!';
    document.getElementById('countdown-overlay').classList.remove('hidden');
  }

  // ═══ STARCHIP: Pre-position camera so countdown doesn't have jarring zoom ═══
  if (_starchipConfigs && ships.length > 0) {
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const s of ships) {
      minX = Math.min(minX, s.x); maxX = Math.max(maxX, s.x);
      minY = Math.min(minY, s.y); maxY = Math.max(maxY, s.y);
    }
    cameraX = targetCamX = (minX + maxX) / 2;
    cameraY = targetCamY = (minY + maxY) / 2;
    const camPad = 200 + ships.length * 15;
    const zX = W / (maxX - minX + camPad);
    const zY = H / (maxY - minY + camPad);
    camZoom = targetZoom = Math.max(0.15, Math.min(1.5, Math.min(zX, zY)));
  }
}

function buildCountdownRoster() {
  const el = document.getElementById('countdown-roster');
  el.innerHTML = '';
  const showAnyTag = settings.showWeaponTag || settings.showPassiveTag || settings.showManeuverTag;
  if (showAnyTag) {
    let loadoutMode = matchMode === 'teams' ? 'TEAM BATTLE' : 'UNIQUE';
    if (settings.chaosMode) loadoutMode = 'RANDOM';
    else if (settings.randomWeapons) loadoutMode = 'RANDOM';
    else if (!settings.weapons) loadoutMode = 'STANDARD';
    document.getElementById('countdown-loadout').textContent = 'LOADOUTS: ' + loadoutMode;
  } else {
    document.getElementById('countdown-loadout').textContent = '';
  }
  document.getElementById('countdown-timer').textContent = 'MATCH BEGINNING IN 5!';

  // Adjust grid for team mode
  if (matchMode === 'teams') {
    el.style.gridTemplateColumns = 'repeat(' + teamAssignments.length + ', 1fr)';
    el.style.maxWidth = Math.max(600, teamAssignments.length * 200) + 'px';
  } else {
    el.style.gridTemplateColumns = 'repeat(4, 1fr)';
    el.style.maxWidth = '1250px';
  }

  if (matchMode === 'teams') {
    // Team mode: big team names with VS, bare ship icons fade in L→R
    const tc = getTeamColors();
    el.style.display = 'flex';
    el.style.flexDirection = 'row';
    el.style.justifyContent = 'center';
    el.style.alignItems = 'center';
    el.style.gap = '0';
    el.style.gridTemplateColumns = '';
    el.style.maxWidth = '100%';
    el.style.width = '100%';
    el.style.padding = '0 20px';

    const iconSize = 48;
    const iconGap = 18;
    const maxPerRow = 8;

    for (let t = 0; t < teamAssignments.length; t++) {
      // VS separator between teams
      if (t > 0) {
        const vs = document.createElement('div');
        vs.style.cssText = 'font-family:Orbitron,sans-serif; font-size:36px; font-weight:900; letter-spacing:8px; color:rgba(255,255,255,0.45); padding:0 30px; text-shadow:0 0 30px rgba(255,255,255,0.15); flex-shrink:0;';
        vs.textContent = 'VS';
        el.appendChild(vs);
      }
      const teamCol = document.createElement('div');
      teamCol.style.cssText = 'display:flex; flex-direction:column; align-items:center; gap:12px; flex:1; min-width:0;';
      // Team header
      const th = document.createElement('div');
      th.style.cssText = 'font-family:Orbitron,sans-serif; font-size:32px; font-weight:900; letter-spacing:8px; text-shadow:0 0 40px currentColor;';
      th.style.color = tc[t] || '#888';
      th.textContent = teamNames[t];
      teamCol.appendChild(th);
      // Ship icons — wrap into rows of maxPerRow, center-justified
      const iconsRow = document.createElement('div');
      const rowWidth = maxPerRow * (iconSize + iconGap);
      iconsRow.style.cssText = `display:flex; flex-wrap:wrap; justify-content:center; gap:${iconGap}px; padding:6px 0; max-width:${rowWidth}px;`;
      const teamShips = ships.filter(s => s.team === t + 1);
      for (let si = 0; si < teamShips.length; si++) {
        const ship = teamShips[si];
        const wrap = document.createElement('div');
        wrap.style.cssText = `opacity:0; animation:rosterIn 0.2s ease forwards; width:${iconSize}px; height:${iconSize}px; display:flex; align-items:center; justify-content:center;`;
        wrap.style.animationDelay = `${0.3 + si * 0.06}s`;
        wrap.appendChild(createShipIcon(ship.shipType, ship.color, iconSize, false));
        iconsRow.appendChild(wrap);
      }
      teamCol.appendChild(iconsRow);
      el.appendChild(teamCol);
    }
  } else {
    // FFA mode: flat grid
    el.style.display = 'grid';
    el.style.flexDirection = '';
    el.style.justifyContent = '';
    el.style.alignItems = '';
    el.style.width = '';
    el.style.padding = '';
    for (let i = 0; i < ships.length; i++) {
      const ship = ships[i];
      const card = document.createElement('div');
      card.className = 'cd-ship-card';
      card.style.borderColor = ship.color + '55';
      card.style.background = ship.color + '0d';
      card.style.animationDelay = `${i * 0.04}s`;
      const showAny = settings.showWeaponTag || settings.showPassiveTag || settings.showManeuverTag;
      if (showAny) {
        const header = document.createElement('div');
        header.className = 'cd-ship-header';
        header.appendChild(createShipIcon(ship.shipType, ship.color, 27, false));
        const nameSpan = document.createElement('span');
        nameSpan.className = 'cd-ship-name';
        nameSpan.style.color = ship.color;
        const cdName = ship.name.length > 5 ? '\u00a0\u00a0' + ship.name : ship.name;
        nameSpan.textContent = cdName;
        header.appendChild(nameSpan);
        card.appendChild(header);
        const lines = [];
        if (settings.showWeaponTag) lines.push(ship.weapon ? ship.weapon.name : 'Basic');
        if (settings.showPassiveTag) lines.push(PASSIVE_DEFS[ship.passive] ? PASSIVE_DEFS[ship.passive].name : 'None');
        if (settings.showManeuverTag) lines.push(MANEUVER_DEFS[ship.maneuver] ? MANEUVER_DEFS[ship.maneuver].name : 'None');
        const detail = document.createElement('div');
        detail.className = 'cd-ship-detail';
        detail.innerHTML = lines.join('<br>');
        card.appendChild(detail);
      } else {
        const nameSpan = document.createElement('div');
        nameSpan.className = 'cd-ship-name';
        nameSpan.style.color = ship.color;
        nameSpan.style.textAlign = 'center';
        nameSpan.style.width = '100%';
        nameSpan.style.marginBottom = '4px';
        nameSpan.textContent = ship.name.length > 5 ? '\u00a0\u00a0' + ship.name : ship.name;
        card.appendChild(nameSpan);
        const icon = createShipIcon(ship.shipType, ship.color, 36, false);
        icon.style.display = 'block';
        icon.style.margin = '0 auto';
        card.appendChild(icon);
      }
      el.appendChild(card);
    }
  }
}

function endCountdown() {
  countdown = false;
  countdownTimer = 0;
  _lastCountdownSec = -1;
  playMatchStart();
  document.getElementById('countdown-overlay').classList.add('hidden');
  showScoreboard = true;
}

function showWinner() {
  logMatchData();

  // Tournament mode: skip results screen, go straight to bracket transition
  if (tourneyActive) {
    showScoreboard = false;
    // Brief delay to let the anime cut-in finish, then transition
    setTimeout(() => tourneyBracketTransition(), 800);
    return;
  }

  const ov = document.getElementById('winner-overlay');
  ov.classList.add('show');
  showScoreboard = false;
  // Force animation replay on persistent elements
  for (const el of [ov.querySelector('h2'), document.getElementById('winner-name'), document.getElementById('restart-btn')]) {
    if (el) { el.style.animation = 'none'; el.offsetHeight; el.style.animation = ''; }
  }
  const nameEl = document.getElementById('winner-name');
  if (matchMode === 'teams') {
    const _wcArr = getTeamColors();
    const teamsAlive = [...new Set(ships.filter(s => s.alive && s.team > 0).map(s => s.team))];
    if (teamsAlive.length === 1) {
      const wt = teamsAlive[0];
      nameEl.textContent = teamNames[wt - 1];
      nameEl.style.color = _wcArr[wt - 1] || '#fff';
    } else {
      nameEl.textContent = 'DRAW';
      nameEl.style.color = '#888';
    }
  } else if (winner) {
    nameEl.textContent = winner.name;
    nameEl.style.color = winner.color;
  } else {
    nameEl.textContent = 'DRAW';
    nameEl.style.color = '#888';
  }

  // Build rankings sorted by placement (1st = winner, survived longest)
  const ranked = [...ships].sort((a, b) => {
    if (a.alive && !b.alive) return -1;
    if (!a.alive && b.alive) return 1;
    if (a.alive && b.alive) return 0;
    // Both dead — later deathTime = better placement
    return (b.deathTime || 0) - (a.deathTime || 0);
  });

  // Assign final placements
  ranked.forEach((s, i) => s.placement = i + 1);

  const container = document.getElementById('rankings');
  container.innerHTML = '';

  // Format time as M:SS
  function fmtTime(t) {
    if (t === null) return '—';
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  }

  if (matchMode === 'teams') {
    // Team rankings
    const _rcArr = getTeamColors();
    const teamStats = [];
    for (let t = 0; t < teamAssignments.length; t++) {
      const teamShips = ships.filter(s => s.team === t + 1);
      const totalKills = teamShips.reduce((s, sh) => s + (sh.kills || 0), 0);
      const lastDeath = Math.max(...teamShips.map(s => s.alive ? gameTime : (s.deathTime || 0)));
      const anyAlive = teamShips.some(s => s.alive);
      teamStats.push({ idx: t, teamShips, totalKills, lastDeath, anyAlive });
    }
    teamStats.sort((a, b) => {
      if (a.anyAlive && !b.anyAlive) return -1;
      if (!a.anyAlive && b.anyAlive) return 1;
      return b.lastDeath - a.lastDeath;
    });
    let delay = 0;
    teamStats.forEach((ts, rank) => {
      // Team header row
      const teamRow = document.createElement('div');
      teamRow.className = 'rank-row' + (rank === 0 ? ' top1' : rank === 1 ? ' top2' : rank === 2 ? ' top3' : '');
      teamRow.style.animationDelay = `${0.35 + delay * 0.08}s`;
      teamRow.style.fontWeight = '700';
      delay++;
      const numSpan = document.createElement('span');
      numSpan.className = 'rank-num';
      numSpan.textContent = rank + 1;
      teamRow.appendChild(numSpan);
      const teamDot = document.createElement('span');
      teamDot.style.cssText = `display:inline-block; width:16px; height:16px; border-radius:50%; background:${_rcArr[ts.idx] || '#888'}; margin:0 8px; flex-shrink:0;`;
      teamRow.appendChild(teamDot);
      const nameBlock = document.createElement('div');
      nameBlock.className = 'rank-name-block';
      const nameSpan = document.createElement('span');
      nameSpan.className = 'rank-name';
      nameSpan.style.color = _rcArr[ts.idx] || '#fff';
      nameSpan.textContent = teamNames[ts.idx];
      nameBlock.appendChild(nameSpan);
      const statusSpan = document.createElement('span');
      statusSpan.className = 'rank-loadout';
      statusSpan.textContent = ts.anyAlive ? `survived ${fmtTime(gameTime)}` : `eliminated ${fmtTime(ts.lastDeath)}`;
      nameBlock.appendChild(statusSpan);
      teamRow.appendChild(nameBlock);
      const causeSpan = document.createElement('span');
      causeSpan.className = 'rank-cause';
      causeSpan.textContent = '';
      teamRow.appendChild(causeSpan);
      const killSpan = document.createElement('span');
      killSpan.className = 'rank-kills';
      killSpan.textContent = ts.totalKills;
      teamRow.appendChild(killSpan);
      const timeSpan = document.createElement('span');
      timeSpan.className = 'rank-time';
      timeSpan.textContent = '';
      teamRow.appendChild(timeSpan);
      container.appendChild(teamRow);
      // Individual ships under team
      const sortedShips = [...ts.teamShips].sort((a, b) => {
        if (a.alive && !b.alive) return -1;
        if (!a.alive && b.alive) return 1;
        return (b.deathTime || 0) - (a.deathTime || 0);
      });
      sortedShips.forEach(ship => {
        const row = document.createElement('div');
        row.className = 'rank-row';
        row.style.animationDelay = `${0.35 + delay * 0.08}s`;
        row.style.paddingLeft = '28px';
        delay++;
        const numSpan2 = document.createElement('span');
        numSpan2.className = 'rank-num';
        numSpan2.textContent = '';
        row.appendChild(numSpan2);
        row.appendChild(createShipIcon(ship.shipType, ship.color, 24, false));
        const nb2 = document.createElement('div');
        nb2.className = 'rank-name-block';
        const ns2 = document.createElement('span');
        ns2.className = 'rank-name';
        ns2.style.color = ship.color;
        ns2.style.fontSize = '12px';
        ns2.textContent = ship.name;
        nb2.appendChild(ns2);
        row.appendChild(nb2);
        const cs2 = document.createElement('span');
        cs2.className = 'rank-cause';
        cs2.textContent = ship.alive ? '—' : (ship.killedBy === 'ASTEROID' ? 'ASTEROID' : `✕ ${ship.killedBy}`);
        row.appendChild(cs2);
        const ks2 = document.createElement('span');
        ks2.className = 'rank-kills';
        ks2.textContent = ship.kills;
        row.appendChild(ks2);
        const ts2 = document.createElement('span');
        ts2.className = 'rank-time';
        ts2.textContent = fmtTime(ship.alive ? gameTime : ship.deathTime);
        row.appendChild(ts2);
        container.appendChild(row);
      });
    });
  } else {
    // FFA rankings
    ranked.forEach((ship, i) => {
    const row = document.createElement('div');
    row.className = 'rank-row' + (i === 0 ? ' top1' : i === 1 ? ' top2' : i === 2 ? ' top3' : '');
    row.style.animationDelay = `${0.35 + i * 0.08}s`;
    const survivalTime = ship.alive ? gameTime : ship.deathTime;
    const causeText = ship.alive ? '—' : (ship.killedBy === 'ASTEROID' ? 'ASTEROID' : `✕ ${ship.killedBy}`);

    const numSpan = document.createElement('span');
    numSpan.className = 'rank-num';
    numSpan.textContent = i + 1;
    row.appendChild(numSpan);
    row.appendChild(createShipIcon(ship.shipType, ship.color, 32, false));
    const nameBlock = document.createElement('div');
    nameBlock.className = 'rank-name-block';
    const nameSpan = document.createElement('span');
    nameSpan.className = 'rank-name';
    nameSpan.style.color = ship.color;
    nameSpan.textContent = ship.name;
    nameBlock.appendChild(nameSpan);
    const showAnyTag = settings.showWeaponTag || settings.showPassiveTag || settings.showManeuverTag;
    if (showAnyTag) {
      const loadoutSpan = document.createElement('span');
      loadoutSpan.className = 'rank-loadout';
      const parts = [];
      if (settings.showWeaponTag) parts.push(ship.weapon?.name || 'Standard Issue');
      if (settings.showPassiveTag) parts.push(PASSIVE_DEFS[ship.passive]?.name || 'None');
      if (settings.showManeuverTag) parts.push(MANEUVER_DEFS[ship.maneuver]?.name || '');
      loadoutSpan.textContent = parts.filter(Boolean).join(' | ');
      nameBlock.appendChild(loadoutSpan);
    }
    row.appendChild(nameBlock);
    const causeSpan = document.createElement('span');
    causeSpan.className = 'rank-cause';
    causeSpan.textContent = causeText;
    row.appendChild(causeSpan);
    const killSpan = document.createElement('span');
    killSpan.className = 'rank-kills';
    killSpan.textContent = ship.kills;
    row.appendChild(killSpan);
    const timeSpan = document.createElement('span');
    timeSpan.className = 'rank-time';
    timeSpan.textContent = fmtTime(survivalTime);
    row.appendChild(timeSpan);
    container.appendChild(row);
    });
  }

  // Scale rankings to fit screen — measure after layout
  container.style.transform = '';
  requestAnimationFrame(() => {
    const ov = document.getElementById('winner-overlay');
    const rankingsTop = container.offsetTop;
    const rankingsH = container.scrollHeight;
    const availH = window.innerHeight - rankingsTop - 80; // leave room for button + padding
    if (rankingsH > availH && availH > 0) {
      const scale = availH / rankingsH;
      container.style.transform = `scale(${scale})`;
      container.style.transformOrigin = 'top center';
    }
  });

  // Set restart button animation delay after all rows
  const totalRows = container.querySelectorAll('.rank-row').length;
  const restartBtn = document.getElementById('restart-btn');
  restartBtn.style.animationDelay = `${0.35 + totalRows * 0.08}s`;

  // Tournament mode: change button text and auto-advance
  if (tourneyActive) {
    restartBtn.textContent = 'NEXT MATCH';
  } else if (_starchipSavedLineup) {
    restartBtn.textContent = 'REMATCH';
    const arenaBtn = document.getElementById('arena-btn');
    arenaBtn.style.display = '';
    arenaBtn.style.animationDelay = `${0.45 + totalRows * 0.08}s`;
  } else {
    restartBtn.textContent = 'NEW MATCH';
  }

  // Auto-restart countdown
  clearAutoRestart();
  if (settings.autoRestart || tourneyActive) {
    let remaining = (settings.matchLogger && !tourneyActive) ? 3 : 5;
    const cdEl = document.getElementById('auto-restart-countdown');
    cdEl.style.display = 'block';
    cdEl.innerHTML = `NEXT MATCH IN <span class="countdown-num">${remaining}</span>`;
    autoRestartInterval = setInterval(() => {
      remaining--;
      if (remaining <= 0) {
        clearAutoRestart();
        if (tourneyActive) {
          tourneyRestartHandler();
        } else {
          if (!settings.chaosMode) init();
          startMatch();
        }
      } else {
        cdEl.innerHTML = `NEXT MATCH IN <span class="countdown-num">${remaining}</span>`;
      }
    }, 1000);
  }
}

// ─── SPEED CONTROLS ───────────────────────────────────────────
document.querySelectorAll('#speed-selector button').forEach(btn => {
  btn.addEventListener('click', () => {
    simSpeed = parseFloat(btn.dataset.speed);
    document.querySelectorAll('#speed-selector button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

document.getElementById('restart-btn').addEventListener('click', () => {
  // ═══ STARCHIP: Rematch with same lineup ═══
  if (_starchipSavedLineup) {
    clearAutoRestart();
    startMatch();
    return;
  }
  if (tourneyActive) {
    tourneyRestartHandler();
    return;
  }
  clearAutoRestart();
  applyChaosMode();
  init();
});

document.getElementById('arena-btn').addEventListener('click', () => {
  _starchipSavedLineup = null;
  window.location.href = 'arena.html';
});

// ─── CAMERA MODE TOGGLE ──────────────────────────────────────
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && !pregame && !countdown) {
    e.preventDefault();
    cameraMode = 'overview';
    manualShips = [];
    cameraLinger = 0;
    cameraTransitioning = false;
    updateCameraModeUI();
  }
});

function updateCameraModeUI() {
  const el = document.getElementById('camera-mode');
  const text = document.getElementById('camera-mode-text');
  if (cameraMode === 'manual') {
    el.classList.add('manual');
    const tracked = manualShips.filter(id => shipById[id] && shipById[id].alive);
    if (tracked.length > 0) {
      text.textContent = tracked.map(id => shipById[id].name).join(' · ');
    } else {
      text.textContent = 'MANUAL — select ships';
    }
  } else {
    el.classList.remove('manual');
    text.textContent = 'OVERVIEW';
  }
}

// ─── MANUAL SELECTION ────────────────────────────────────────
function screenToWorld(sx, sy) {
  return {
    x: (sx - W / 2) / camZoom + cameraX,
    y: (sy - H / 2) / camZoom + cameraY
  };
}

canvas.addEventListener('mousedown', (e) => {
  if (pregame || gameOver) return;
  if (e.button !== 0) return; // left click only
  isSelecting = true;
  selectBoxStart = { x: e.clientX, y: e.clientY };
  selectBoxEnd = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener('mousemove', (e) => {
  if (!isSelecting) return;
  selectBoxEnd = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener('mouseup', (e) => {
  if (!isSelecting) return;
  isSelecting = false;
  selectBoxEnd = { x: e.clientX, y: e.clientY };

  // Convert screen box to world coords
  const w1 = screenToWorld(selectBoxStart.x, selectBoxStart.y);
  const w2 = screenToWorld(selectBoxEnd.x, selectBoxEnd.y);
  const minWX = Math.min(w1.x, w2.x), maxWX = Math.max(w1.x, w2.x);
  const minWY = Math.min(w1.y, w2.y), maxWY = Math.max(w1.y, w2.y);

  // Require a minimum drag size to avoid accidental clicks
  const screenDist = Math.hypot(selectBoxEnd.x - selectBoxStart.x, selectBoxEnd.y - selectBoxStart.y);
  if (screenDist < 20) {
    selectBoxStart = null;
    selectBoxEnd = null;
    return;
  }

  // Find alive ships inside the box
  const selected = [];
  for (const ship of ships) {
    if (!ship.alive) continue;
    if (ship.x >= minWX && ship.x <= maxWX && ship.y >= minWY && ship.y <= maxWY) {
      selected.push(ship.id);
    }
  }

  selectBoxStart = null;
  selectBoxEnd = null;

  if (selected.length >= 2) {
    manualShips = selected;
    cameraMode = 'manual';
    cameraLinger = 0;
    cameraTransitioning = false;
    updateCameraModeUI();
  }
});

// ─── GAME LOOP ────────────────────────────────────────────────
let lastTime = 0;
function gameLoop(time) {
  const rawDt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  update(rawDt);
  render();
  requestAnimationFrame(gameLoop);
}

initStars();
init();
requestAnimationFrame(gameLoop);

// ─── PWA SERVICE WORKER ──────────────────────────────────────
if ('serviceWorker' in navigator) {
  // ═══ STARCHIP AUTO-START ═══
  // If launched from arena with a lineup, skip pregame and start immediately
  if (localStorage.getItem('starchip_lineup')) {
    startMatch();
  }

  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js').catch(() => {});
  });
}
</script>
</body>
</html>
